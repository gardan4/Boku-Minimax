
+++++++++++++++++++ SYMBOLS ++++++++++++++++++++++
gdm* <int> name=int type=Primitive (int) => <int>, pack=game.functions.ints, label=int, cls=int, keyword=int, atomic=int, atomic path=int
gdm* <boolean> name=boolean type=Primitive (boolean) => <boolean>, pack=game.functions.booleans, label=boolean, cls=boolean, keyword=boolean, atomic=boolean, atomic path=boolean
gdm* <float> name=float type=Primitive (float) => <float>, pack=game.functions.floats, label=float, cls=float, keyword=float, atomic=float, atomic path=float
gdm~ <Integer> name=Integer type=Predefined (java.lang.Integer) => <Integer>, pack=game.functions.ints, label=int, cls=java.lang.Integer, keyword=int, atomic=int, atomic path=int
gdm~ <Boolean> name=Boolean type=Predefined (java.lang.Boolean) => <Boolean>, pack=game.functions.booleans, label=boolean, cls=java.lang.Boolean, keyword=boolean, atomic=boolean, atomic path=boolean
gdm~ <Float> name=Float type=Predefined (java.lang.Float) => <Float>, pack=game.functions.floats, label=float, cls=java.lang.Float, keyword=float, atomic=float, atomic path=float
gdm~ <String> name=String type=Predefined (java.lang.String) => <String>, pack=game.types, label=string, cls=java.lang.String, keyword=string, atomic=String, atomic path=java.lang.String
gd~* <Off> name=Off type=Primitive (Off) => <int>, pack=global, label=Off, cls=int, keyword=Off, atomic=Off, atomic path=Off
gd~* <End> name=End type=Primitive (End) => <int>, pack=global, label=End, cls=int, keyword=End, atomic=End, atomic path=End
gd~* <Undefined> name=Undefined type=Primitive (Undefined) => <int>, pack=global, label=Undefined, cls=int, keyword=Undefined, atomic=Undefined, atomic path=Undefined
gd~* <Infinity> name=Infinity type=Primitive (Infinity) => <int>, pack=global, label=Infinity, cls=int, keyword=Infinity, atomic=Infinity, atomic path=Infinity
~~~* <aPI> name=API type=Structural (game.API) => <aPI>, pack=game, label=aPI, cls=game.API, keyword=aPI, atomic=API, atomic path=game.API
gd~~ <game> name=Game type=Ludeme (game.Game) => <game>, pack=game, label=game, cls=game.Game, keyword=game, atomic=Game, atomic path=game.Game
gd~~ <equipment> name=Equipment type=Ludeme (game.equipment.Equipment) => <equipment>, pack=game.equipment, label=equipment, cls=game.equipment.Equipment, keyword=equipment, atomic=Equipment, atomic path=game.equipment.Equipment
g~~* <item> name=Item type=Structural (game.equipment.Item) => <item>, pack=game.equipment, label=item, cls=game.equipment.Item, keyword=item, atomic=Item, atomic path=game.equipment.Item
gd~~ <component.card> name=Card type=Ludeme (game.equipment.component.Card) => <component.card>, pack=game.equipment.component, label=component.card, cls=game.equipment.component.Card, keyword=card, atomic=Card, atomic path=game.equipment.component.Card
gd~~ <component> name=Component type=Ludeme (game.equipment.component.Component) => <component>, pack=game.equipment.component, label=component, cls=game.equipment.component.Component, keyword=component, atomic=Component, atomic path=game.equipment.component.Component
gd~~ <die> name=Die type=Ludeme (game.equipment.component.Die) => <die>, pack=game.equipment.component, label=die, cls=game.equipment.component.Die, keyword=die, atomic=Die, atomic path=game.equipment.component.Die
gd~~ <component.piece> name=Piece type=Ludeme (game.equipment.component.Piece) => <component.piece>, pack=game.equipment.component, label=component.piece, cls=game.equipment.component.Piece, keyword=piece, atomic=Piece, atomic path=game.equipment.component.Piece
gd~~ <domino> name=Domino type=Ludeme (game.equipment.component.tile.Domino) => <domino>, pack=game.equipment.component.tile, label=domino, cls=game.equipment.component.tile.Domino, keyword=domino, atomic=Domino, atomic path=game.equipment.component.tile.Domino
gd~~ <path> name=Path type=Ludeme (game.equipment.component.tile.Path) => <path>, pack=game.equipment.component.tile, label=path, cls=game.equipment.component.tile.Path, keyword=path, atomic=Path, atomic path=game.equipment.component.tile.Path
gd~~ <tile> name=Tile type=Ludeme (game.equipment.component.tile.Tile) => <tile>, pack=game.equipment.component.tile, label=tile, cls=game.equipment.component.tile.Tile, keyword=tile, atomic=Tile, atomic path=game.equipment.component.tile.Tile
g~~* <container> name=Container type=Structural (game.equipment.container.Container) => <container>, pack=game.equipment.container, label=container, cls=game.equipment.container.Container, keyword=container, atomic=Container, atomic path=game.equipment.container.Container
gd~~ <container.board.board> name=Board type=Ludeme (game.equipment.container.board.Board) => <container.board.board>, pack=game.equipment.container.board, label=container.board.board, cls=game.equipment.container.board.Board, keyword=board, atomic=Board, atomic path=game.equipment.container.board.Board
gd~~ <boardless> name=Boardless type=Ludeme (game.equipment.container.board.Boardless) => <boardless>, pack=game.equipment.container.board, label=boardless, cls=game.equipment.container.board.Boardless, keyword=boardless, atomic=Boardless, atomic path=game.equipment.container.board.Boardless
gd~~ <board.track> name=Track type=Ludeme (game.equipment.container.board.Track) => <board.track>, pack=game.equipment.container.board, label=board.track, cls=game.equipment.container.board.Track, keyword=track, atomic=Track, atomic path=game.equipment.container.board.Track
gd~~ <mancalaBoard> name=MancalaBoard type=Ludeme (game.equipment.container.board.custom.MancalaBoard) => <mancalaBoard>, pack=game.equipment.container.board.custom, label=mancalaBoard, cls=game.equipment.container.board.custom.MancalaBoard, keyword=mancalaBoard, atomic=MancalaBoard, atomic path=game.equipment.container.board.custom.MancalaBoard
gd~~ <surakartaBoard> name=SurakartaBoard type=Ludeme (game.equipment.container.board.custom.SurakartaBoard) => <surakartaBoard>, pack=game.equipment.container.board.custom, label=surakartaBoard, cls=game.equipment.container.board.custom.SurakartaBoard, keyword=surakartaBoard, atomic=SurakartaBoard, atomic path=game.equipment.container.board.custom.SurakartaBoard
gd~~ <deck> name=Deck type=Ludeme (game.equipment.container.other.Deck) => <deck>, pack=game.equipment.container.other, label=deck, cls=game.equipment.container.other.Deck, keyword=deck, atomic=Deck, atomic path=game.equipment.container.other.Deck
gd~~ <dice> name=Dice type=Ludeme (game.equipment.container.other.Dice) => <dice>, pack=game.equipment.container.other, label=dice, cls=game.equipment.container.other.Dice, keyword=dice, atomic=Dice, atomic path=game.equipment.container.other.Dice
gd~~ <other.hand> name=Hand type=Ludeme (game.equipment.container.other.Hand) => <other.hand>, pack=game.equipment.container.other, label=other.hand, cls=game.equipment.container.other.Hand, keyword=hand, atomic=Hand, atomic path=game.equipment.container.other.Hand
gd~~ <dominoes> name=Dominoes type=Ludeme (game.equipment.other.Dominoes) => <dominoes>, pack=game.equipment.other, label=dominoes, cls=game.equipment.other.Dominoes, keyword=dominoes, atomic=Dominoes, atomic path=game.equipment.other.Dominoes
gd~~ <hints> name=Hints type=Ludeme (game.equipment.other.Hints) => <hints>, pack=game.equipment.other, label=hints, cls=game.equipment.other.Hints, keyword=hints, atomic=Hints, atomic path=game.equipment.other.Hints
gd~~ <map> name=Map type=Ludeme (game.equipment.other.Map) => <map>, pack=game.equipment.other, label=map, cls=game.equipment.other.Map, keyword=map, atomic=Map, atomic path=game.equipment.other.Map
gd~~ <regions> name=Regions type=Ludeme (game.equipment.other.Regions) => <int>{<int>}, pack=game.equipment.other, label=regions, cls=game.equipment.other.Regions, keyword=regions, atomic=Regions, atomic path=game.equipment.other.Regions
~~~* <baseBooleanFunction> name=BaseBooleanFunction type=Ludeme (game.functions.booleans.BaseBooleanFunction) => <baseBooleanFunction>, pack=game.functions.booleans, label=baseBooleanFunction, cls=game.functions.booleans.BaseBooleanFunction, keyword=baseBooleanFunction, atomic=BaseBooleanFunction, atomic path=game.functions.booleans.BaseBooleanFunction
~~~~ <booleanConstant> name=BooleanConstant type=Ludeme (game.functions.booleans.BooleanConstant) => <boolean>, pack=game.functions.booleans, label=booleanConstant, cls=game.functions.booleans.BooleanConstant, keyword=booleanConstant, atomic=boolean, atomic path=boolean
g~~* <boolean> name=BooleanFunction type=Structural (game.functions.booleans.BooleanFunction) => <boolean>, pack=game.functions.booleans, label=boolean, cls=game.functions.booleans.BooleanFunction, keyword=booleanFunction, atomic=boolean, atomic path=boolean
gd~~ <toBool> name=ToBool type=Ludeme (game.functions.booleans.ToBool) => <boolean>, pack=game.functions.booleans, label=toBool, cls=game.functions.booleans.ToBool, keyword=toBool, atomic=ToBool, atomic path=game.functions.booleans.ToBool
gd~~ <booleans.all.all> name=All type=SuperLudeme (game.functions.booleans.all.All) => <boolean>, pack=game.functions.booleans.all, label=booleans.all.all, cls=game.functions.booleans.all.All, keyword=all, atomic=All, atomic path=game.functions.booleans.all.All
~~~~ <allGroupsType> name=AllGroupsType type=Structural (game.functions.booleans.all.AllGroupsType) => <allGroupsType>, pack=game.functions.booleans.all, label=allGroupsType, cls=game.functions.booleans.all.AllGroupsType, keyword=allGroupsType, atomic=AllGroupsType, atomic path=game.functions.booleans.all.AllGroupsType
g~~~ <allSimpleType> name=AllSimpleType type=Structural (game.functions.booleans.all.AllSimpleType) => <allSimpleType>, pack=game.functions.booleans.all, label=allSimpleType, cls=game.functions.booleans.all.AllSimpleType, keyword=allSimpleType, atomic=AllSimpleType, atomic path=game.functions.booleans.all.AllSimpleType
g~~~ <allSitesType> name=AllSitesType type=Structural (game.functions.booleans.all.AllSitesType) => <allSitesType>, pack=game.functions.booleans.all, label=allSitesType, cls=game.functions.booleans.all.AllSitesType, keyword=allSitesType, atomic=AllSitesType, atomic path=game.functions.booleans.all.AllSitesType
~~~~ <allValuesType> name=AllValuesType type=Structural (game.functions.booleans.all.AllValuesType) => <allValuesType>, pack=game.functions.booleans.all, label=allValuesType, cls=game.functions.booleans.all.AllValuesType, keyword=allValuesType, atomic=AllValuesType, atomic path=game.functions.booleans.all.AllValuesType
~~~~ <allGroups> name=AllGroups type=SubLudeme (game.functions.booleans.all.groups.AllGroups) => <boolean>, pack=game.functions.booleans.all.groups, label=allGroups, cls=game.functions.booleans.all.groups.AllGroups, keyword=allGroups, atomic=AllGroups, atomic path=game.functions.booleans.all.groups.AllGroups
~~~~ <allDiceEqual> name=AllDiceEqual type=SubLudeme (game.functions.booleans.all.simple.AllDiceEqual) => <boolean>, pack=game.functions.booleans.all.simple, label=allDiceEqual, cls=game.functions.booleans.all.simple.AllDiceEqual, keyword=allDiceEqual, atomic=AllDiceEqual, atomic path=game.functions.booleans.all.simple.AllDiceEqual
~~~~ <allDiceUsed> name=AllDiceUsed type=SubLudeme (game.functions.booleans.all.simple.AllDiceUsed) => <boolean>, pack=game.functions.booleans.all.simple, label=allDiceUsed, cls=game.functions.booleans.all.simple.AllDiceUsed, keyword=allDiceUsed, atomic=AllDiceUsed, atomic path=game.functions.booleans.all.simple.AllDiceUsed
~~~~ <allPassed> name=AllPassed type=SubLudeme (game.functions.booleans.all.simple.AllPassed) => <boolean>, pack=game.functions.booleans.all.simple, label=allPassed, cls=game.functions.booleans.all.simple.AllPassed, keyword=allPassed, atomic=AllPassed, atomic path=game.functions.booleans.all.simple.AllPassed
~~~~ <sites.allDifferent> name=AllDifferent type=SubLudeme (game.functions.booleans.all.sites.AllDifferent) => <boolean>, pack=game.functions.booleans.all.sites, label=sites.allDifferent, cls=game.functions.booleans.all.sites.AllDifferent, keyword=allDifferent, atomic=AllDifferent, atomic path=game.functions.booleans.all.sites.AllDifferent
~~~~ <allSites> name=AllSites type=SubLudeme (game.functions.booleans.all.sites.AllSites) => <boolean>, pack=game.functions.booleans.all.sites, label=allSites, cls=game.functions.booleans.all.sites.AllSites, keyword=allSites, atomic=AllSites, atomic path=game.functions.booleans.all.sites.AllSites
~~~~ <allValues> name=AllValues type=SubLudeme (game.functions.booleans.all.values.AllValues) => <boolean>, pack=game.functions.booleans.all.values, label=allValues, cls=game.functions.booleans.all.values.AllValues, keyword=allValues, atomic=AllValues, atomic path=game.functions.booleans.all.values.AllValues
gd~~ <can> name=Can type=SuperLudeme (game.functions.booleans.can.Can) => <boolean>, pack=game.functions.booleans.can, label=can, cls=game.functions.booleans.can.Can, keyword=can, atomic=Can, atomic path=game.functions.booleans.can.Can
~~~~ <canMove> name=CanMove type=SubLudeme (game.functions.booleans.can.CanMove) => <boolean>, pack=game.functions.booleans.can, label=canMove, cls=game.functions.booleans.can.CanMove, keyword=canMove, atomic=CanMove, atomic path=game.functions.booleans.can.CanMove
~~~~ <canType> name=CanType type=Structural (game.functions.booleans.can.CanType) => <canType>, pack=game.functions.booleans.can, label=canType, cls=game.functions.booleans.can.CanType, keyword=canType, atomic=CanType, atomic path=game.functions.booleans.can.CanType
gd~~ <forAll> name=ForAll type=Ludeme (game.functions.booleans.deductionPuzzle.ForAll) => <boolean>, pack=game.functions.booleans.deductionPuzzle, label=forAll, cls=game.functions.booleans.deductionPuzzle.ForAll, keyword=forAll, atomic=ForAll, atomic path=game.functions.booleans.deductionPuzzle.ForAll
gd~~ <deductionPuzzle.all.all> name=All type=SuperLudeme (game.functions.booleans.deductionPuzzle.all.All) => <boolean>, pack=game.functions.booleans.deductionPuzzle.all, label=deductionPuzzle.all.all, cls=game.functions.booleans.deductionPuzzle.all.All, keyword=all, atomic=All, atomic path=game.functions.booleans.deductionPuzzle.all.All
~~~~ <all.allDifferent> name=AllDifferent type=SubLudeme (game.functions.booleans.deductionPuzzle.all.AllDifferent) => <boolean>, pack=game.functions.booleans.deductionPuzzle.all, label=all.allDifferent, cls=game.functions.booleans.deductionPuzzle.all.AllDifferent, keyword=allDifferent, atomic=AllDifferent, atomic path=game.functions.booleans.deductionPuzzle.all.AllDifferent
~~~~ <allPuzzleType> name=AllPuzzleType type=Structural (game.functions.booleans.deductionPuzzle.all.AllPuzzleType) => <allPuzzleType>, pack=game.functions.booleans.deductionPuzzle.all, label=allPuzzleType, cls=game.functions.booleans.deductionPuzzle.all.AllPuzzleType, keyword=allPuzzleType, atomic=AllPuzzleType, atomic path=game.functions.booleans.deductionPuzzle.all.AllPuzzleType
gd~~ <deductionPuzzle.is.is> name=Is type=SuperLudeme (game.functions.booleans.deductionPuzzle.is.Is) => <boolean>, pack=game.functions.booleans.deductionPuzzle.is, label=deductionPuzzle.is.is, cls=game.functions.booleans.deductionPuzzle.is.Is, keyword=is, atomic=Is, atomic path=game.functions.booleans.deductionPuzzle.is.Is
~~~~ <isPuzzleGraphType> name=IsPuzzleGraphType type=Structural (game.functions.booleans.deductionPuzzle.is.IsPuzzleGraphType) => <isPuzzleGraphType>, pack=game.functions.booleans.deductionPuzzle.is, label=isPuzzleGraphType, cls=game.functions.booleans.deductionPuzzle.is.IsPuzzleGraphType, keyword=isPuzzleGraphType, atomic=IsPuzzleGraphType, atomic path=game.functions.booleans.deductionPuzzle.is.IsPuzzleGraphType
g~~~ <isPuzzleRegionResultType> name=IsPuzzleRegionResultType type=Structural (game.functions.booleans.deductionPuzzle.is.IsPuzzleRegionResultType) => <isPuzzleRegionResultType>, pack=game.functions.booleans.deductionPuzzle.is, label=isPuzzleRegionResultType, cls=game.functions.booleans.deductionPuzzle.is.IsPuzzleRegionResultType, keyword=isPuzzleRegionResultType, atomic=IsPuzzleRegionResultType, atomic path=game.functions.booleans.deductionPuzzle.is.IsPuzzleRegionResultType
~~~~ <isPuzzleSimpleType> name=IsPuzzleSimpleType type=Structural (game.functions.booleans.deductionPuzzle.is.IsPuzzleSimpleType) => <isPuzzleSimpleType>, pack=game.functions.booleans.deductionPuzzle.is, label=isPuzzleSimpleType, cls=game.functions.booleans.deductionPuzzle.is.IsPuzzleSimpleType, keyword=isPuzzleSimpleType, atomic=IsPuzzleSimpleType, atomic path=game.functions.booleans.deductionPuzzle.is.IsPuzzleSimpleType
~~~~ <isUnique> name=IsUnique type=SubLudeme (game.functions.booleans.deductionPuzzle.is.graph.IsUnique) => <boolean>, pack=game.functions.booleans.deductionPuzzle.is.graph, label=isUnique, cls=game.functions.booleans.deductionPuzzle.is.graph.IsUnique, keyword=isUnique, atomic=IsUnique, atomic path=game.functions.booleans.deductionPuzzle.is.graph.IsUnique
~~~~ <isCount> name=IsCount type=SubLudeme (game.functions.booleans.deductionPuzzle.is.regionResult.IsCount) => <boolean>, pack=game.functions.booleans.deductionPuzzle.is.regionResult, label=isCount, cls=game.functions.booleans.deductionPuzzle.is.regionResult.IsCount, keyword=isCount, atomic=IsCount, atomic path=game.functions.booleans.deductionPuzzle.is.regionResult.IsCount
~~~~ <isSum> name=IsSum type=SubLudeme (game.functions.booleans.deductionPuzzle.is.regionResult.IsSum) => <boolean>, pack=game.functions.booleans.deductionPuzzle.is.regionResult, label=isSum, cls=game.functions.booleans.deductionPuzzle.is.regionResult.IsSum, keyword=isSum, atomic=IsSum, atomic path=game.functions.booleans.deductionPuzzle.is.regionResult.IsSum
~~~~ <isSolved> name=IsSolved type=SubLudeme (game.functions.booleans.deductionPuzzle.is.simple.IsSolved) => <boolean>, pack=game.functions.booleans.deductionPuzzle.is.simple, label=isSolved, cls=game.functions.booleans.deductionPuzzle.is.simple.IsSolved, keyword=isSolved, atomic=IsSolved, atomic path=game.functions.booleans.deductionPuzzle.is.simple.IsSolved
~~~~ <isHidden> name=IsHidden type=SubLudeme (game.functions.booleans.is.Hidden.IsHidden) => <boolean>, pack=game.functions.booleans.is.Hidden, label=isHidden, cls=game.functions.booleans.is.Hidden.IsHidden, keyword=isHidden, atomic=IsHidden, atomic path=game.functions.booleans.is.Hidden.IsHidden
~~~~ <isHiddenCount> name=IsHiddenCount type=SubLudeme (game.functions.booleans.is.Hidden.IsHiddenCount) => <boolean>, pack=game.functions.booleans.is.Hidden, label=isHiddenCount, cls=game.functions.booleans.is.Hidden.IsHiddenCount, keyword=isHiddenCount, atomic=IsHiddenCount, atomic path=game.functions.booleans.is.Hidden.IsHiddenCount
~~~~ <isHiddenRotation> name=IsHiddenRotation type=SubLudeme (game.functions.booleans.is.Hidden.IsHiddenRotation) => <boolean>, pack=game.functions.booleans.is.Hidden, label=isHiddenRotation, cls=game.functions.booleans.is.Hidden.IsHiddenRotation, keyword=isHiddenRotation, atomic=IsHiddenRotation, atomic path=game.functions.booleans.is.Hidden.IsHiddenRotation
~~~~ <isHiddenState> name=IsHiddenState type=SubLudeme (game.functions.booleans.is.Hidden.IsHiddenState) => <boolean>, pack=game.functions.booleans.is.Hidden, label=isHiddenState, cls=game.functions.booleans.is.Hidden.IsHiddenState, keyword=isHiddenState, atomic=IsHiddenState, atomic path=game.functions.booleans.is.Hidden.IsHiddenState
~~~~ <isHiddenValue> name=IsHiddenValue type=SubLudeme (game.functions.booleans.is.Hidden.IsHiddenValue) => <boolean>, pack=game.functions.booleans.is.Hidden, label=isHiddenValue, cls=game.functions.booleans.is.Hidden.IsHiddenValue, keyword=isHiddenValue, atomic=IsHiddenValue, atomic path=game.functions.booleans.is.Hidden.IsHiddenValue
~~~~ <isHiddenWhat> name=IsHiddenWhat type=SubLudeme (game.functions.booleans.is.Hidden.IsHiddenWhat) => <boolean>, pack=game.functions.booleans.is.Hidden, label=isHiddenWhat, cls=game.functions.booleans.is.Hidden.IsHiddenWhat, keyword=isHiddenWhat, atomic=IsHiddenWhat, atomic path=game.functions.booleans.is.Hidden.IsHiddenWhat
~~~~ <isHiddenWho> name=IsHiddenWho type=SubLudeme (game.functions.booleans.is.Hidden.IsHiddenWho) => <boolean>, pack=game.functions.booleans.is.Hidden, label=isHiddenWho, cls=game.functions.booleans.is.Hidden.IsHiddenWho, keyword=isHiddenWho, atomic=IsHiddenWho, atomic path=game.functions.booleans.is.Hidden.IsHiddenWho
gd~~ <booleans.is.is> name=Is type=SuperLudeme (game.functions.booleans.is.Is) => <boolean>, pack=game.functions.booleans.is, label=booleans.is.is, cls=game.functions.booleans.is.Is, keyword=is, atomic=Is, atomic path=game.functions.booleans.is.Is
g~~~ <isAngleType> name=IsAngleType type=Structural (game.functions.booleans.is.IsAngleType) => <isAngleType>, pack=game.functions.booleans.is, label=isAngleType, cls=game.functions.booleans.is.IsAngleType, keyword=isAngleType, atomic=IsAngleType, atomic path=game.functions.booleans.is.IsAngleType
g~~~ <isComponentType> name=IsComponentType type=Structural (game.functions.booleans.is.IsComponentType) => <isComponentType>, pack=game.functions.booleans.is, label=isComponentType, cls=game.functions.booleans.is.IsComponentType, keyword=isComponentType, atomic=IsComponentType, atomic path=game.functions.booleans.is.IsComponentType
g~~~ <isConnectType> name=IsConnectType type=Structural (game.functions.booleans.is.IsConnectType) => <isConnectType>, pack=game.functions.booleans.is, label=isConnectType, cls=game.functions.booleans.is.IsConnectType, keyword=isConnectType, atomic=IsConnectType, atomic path=game.functions.booleans.is.IsConnectType
~~~~ <isEdgeType> name=IsEdgeType type=Structural (game.functions.booleans.is.IsEdgeType) => <isEdgeType>, pack=game.functions.booleans.is, label=isEdgeType, cls=game.functions.booleans.is.IsEdgeType, keyword=isEdgeType, atomic=IsEdgeType, atomic path=game.functions.booleans.is.IsEdgeType
g~~~ <isGraphType> name=IsGraphType type=Structural (game.functions.booleans.is.IsGraphType) => <isGraphType>, pack=game.functions.booleans.is, label=isGraphType, cls=game.functions.booleans.is.IsGraphType, keyword=isGraphType, atomic=IsGraphType, atomic path=game.functions.booleans.is.IsGraphType
~~~~ <isHiddenType> name=IsHiddenType type=Structural (game.functions.booleans.is.IsHiddenType) => <isHiddenType>, pack=game.functions.booleans.is, label=isHiddenType, cls=game.functions.booleans.is.IsHiddenType, keyword=isHiddenType, atomic=IsHiddenType, atomic path=game.functions.booleans.is.IsHiddenType
~~~~ <isInType> name=IsInType type=Structural (game.functions.booleans.is.IsInType) => <isInType>, pack=game.functions.booleans.is, label=isInType, cls=game.functions.booleans.is.IsInType, keyword=isInType, atomic=IsInType, atomic path=game.functions.booleans.is.IsInType
g~~~ <isIntegerType> name=IsIntegerType type=Structural (game.functions.booleans.is.IsIntegerType) => <isIntegerType>, pack=game.functions.booleans.is, label=isIntegerType, cls=game.functions.booleans.is.IsIntegerType, keyword=isIntegerType, atomic=IsIntegerType, atomic path=game.functions.booleans.is.IsIntegerType
~~~~ <isLineType> name=IsLineType type=Structural (game.functions.booleans.is.IsLineType) => <isLineType>, pack=game.functions.booleans.is, label=isLineType, cls=game.functions.booleans.is.IsLineType, keyword=isLineType, atomic=IsLineType, atomic path=game.functions.booleans.is.IsLineType
~~~~ <isLoopType> name=IsLoopType type=Structural (game.functions.booleans.is.IsLoopType) => <isLoopType>, pack=game.functions.booleans.is, label=isLoopType, cls=game.functions.booleans.is.IsLoopType, keyword=isLoopType, atomic=IsLoopType, atomic path=game.functions.booleans.is.IsLoopType
~~~~ <isPathType> name=IsPathType type=Structural (game.functions.booleans.is.IsPathType) => <isPathType>, pack=game.functions.booleans.is, label=isPathType, cls=game.functions.booleans.is.IsPathType, keyword=isPathType, atomic=IsPathType, atomic path=game.functions.booleans.is.IsPathType
~~~~ <isPatternType> name=IsPatternType type=Structural (game.functions.booleans.is.IsPatternType) => <isPatternType>, pack=game.functions.booleans.is, label=isPatternType, cls=game.functions.booleans.is.IsPatternType, keyword=isPatternType, atomic=IsPatternType, atomic path=game.functions.booleans.is.IsPatternType
g~~~ <isPlayerType> name=IsPlayerType type=Structural (game.functions.booleans.is.IsPlayerType) => <isPlayerType>, pack=game.functions.booleans.is, label=isPlayerType, cls=game.functions.booleans.is.IsPlayerType, keyword=isPlayerType, atomic=IsPlayerType, atomic path=game.functions.booleans.is.IsPlayerType
~~~~ <isRegularGraphType> name=IsRegularGraphType type=Structural (game.functions.booleans.is.IsRegularGraphType) => <isRegularGraphType>, pack=game.functions.booleans.is, label=isRegularGraphType, cls=game.functions.booleans.is.IsRegularGraphType, keyword=isRegularGraphType, atomic=IsRegularGraphType, atomic path=game.functions.booleans.is.IsRegularGraphType
~~~~ <isRelationType> name=IsRelationType type=Structural (game.functions.booleans.is.IsRelationType) => <isRelationType>, pack=game.functions.booleans.is, label=isRelationType, cls=game.functions.booleans.is.IsRelationType, keyword=isRelationType, atomic=IsRelationType, atomic path=game.functions.booleans.is.IsRelationType
~~~~ <isRepeatType> name=IsRepeatType type=Structural (game.functions.booleans.is.IsRepeatType) => <isRepeatType>, pack=game.functions.booleans.is, label=isRepeatType, cls=game.functions.booleans.is.IsRepeatType, keyword=isRepeatType, atomic=IsRepeatType, atomic path=game.functions.booleans.is.IsRepeatType
g~~~ <isSimpleType> name=IsSimpleType type=Structural (game.functions.booleans.is.IsSimpleType) => <isSimpleType>, pack=game.functions.booleans.is, label=isSimpleType, cls=game.functions.booleans.is.IsSimpleType, keyword=isSimpleType, atomic=IsSimpleType, atomic path=game.functions.booleans.is.IsSimpleType
g~~~ <isSiteType> name=IsSiteType type=Structural (game.functions.booleans.is.IsSiteType) => <isSiteType>, pack=game.functions.booleans.is, label=isSiteType, cls=game.functions.booleans.is.IsSiteType, keyword=isSiteType, atomic=IsSiteType, atomic path=game.functions.booleans.is.IsSiteType
g~~~ <isStringType> name=IsStringType type=Structural (game.functions.booleans.is.IsStringType) => <isStringType>, pack=game.functions.booleans.is, label=isStringType, cls=game.functions.booleans.is.IsStringType, keyword=isStringType, atomic=IsStringType, atomic path=game.functions.booleans.is.IsStringType
~~~~ <isTargetType> name=IsTargetType type=Structural (game.functions.booleans.is.IsTargetType) => <isTargetType>, pack=game.functions.booleans.is, label=isTargetType, cls=game.functions.booleans.is.IsTargetType, keyword=isTargetType, atomic=IsTargetType, atomic path=game.functions.booleans.is.IsTargetType
g~~~ <isTreeType> name=IsTreeType type=Structural (game.functions.booleans.is.IsTreeType) => <isTreeType>, pack=game.functions.booleans.is, label=isTreeType, cls=game.functions.booleans.is.IsTreeType, keyword=isTreeType, atomic=IsTreeType, atomic path=game.functions.booleans.is.IsTreeType
~~~~ <isTriggeredType> name=IsTriggeredType type=Structural (game.functions.booleans.is.IsTriggeredType) => <isTriggeredType>, pack=game.functions.booleans.is, label=isTriggeredType, cls=game.functions.booleans.is.IsTriggeredType, keyword=isTriggeredType, atomic=IsTriggeredType, atomic path=game.functions.booleans.is.IsTriggeredType
~~~~ <isAcute> name=IsAcute type=SubLudeme (game.functions.booleans.is.angle.IsAcute) => <boolean>, pack=game.functions.booleans.is.angle, label=isAcute, cls=game.functions.booleans.is.angle.IsAcute, keyword=isAcute, atomic=IsAcute, atomic path=game.functions.booleans.is.angle.IsAcute
~~~~ <isObtuse> name=IsObtuse type=SubLudeme (game.functions.booleans.is.angle.IsObtuse) => <boolean>, pack=game.functions.booleans.is.angle, label=isObtuse, cls=game.functions.booleans.is.angle.IsObtuse, keyword=isObtuse, atomic=IsObtuse, atomic path=game.functions.booleans.is.angle.IsObtuse
~~~~ <isReflex> name=IsReflex type=SubLudeme (game.functions.booleans.is.angle.IsReflex) => <boolean>, pack=game.functions.booleans.is.angle, label=isReflex, cls=game.functions.booleans.is.angle.IsReflex, keyword=isReflex, atomic=IsReflex, atomic path=game.functions.booleans.is.angle.IsReflex
~~~~ <isRight> name=IsRight type=SubLudeme (game.functions.booleans.is.angle.IsRight) => <boolean>, pack=game.functions.booleans.is.angle, label=isRight, cls=game.functions.booleans.is.angle.IsRight, keyword=isRight, atomic=IsRight, atomic path=game.functions.booleans.is.angle.IsRight
~~~~ <isThreatened> name=IsThreatened type=SubLudeme (game.functions.booleans.is.component.IsThreatened) => <boolean>, pack=game.functions.booleans.is.component, label=isThreatened, cls=game.functions.booleans.is.component.IsThreatened, keyword=isThreatened, atomic=IsThreatened, atomic path=game.functions.booleans.is.component.IsThreatened
~~~~ <isWithin> name=IsWithin type=SubLudeme (game.functions.booleans.is.component.IsWithin) => <boolean>, pack=game.functions.booleans.is.component, label=isWithin, cls=game.functions.booleans.is.component.IsWithin, keyword=isWithin, atomic=IsWithin, atomic path=game.functions.booleans.is.component.IsWithin
~~~~ <isBlocked> name=IsBlocked type=SubLudeme (game.functions.booleans.is.connect.IsBlocked) => <boolean>, pack=game.functions.booleans.is.connect, label=isBlocked, cls=game.functions.booleans.is.connect.IsBlocked, keyword=isBlocked, atomic=IsBlocked, atomic path=game.functions.booleans.is.connect.IsBlocked
~~~~ <isConnected> name=IsConnected type=SubLudeme (game.functions.booleans.is.connect.IsConnected) => <boolean>, pack=game.functions.booleans.is.connect, label=isConnected, cls=game.functions.booleans.is.connect.IsConnected, keyword=isConnected, atomic=IsConnected, atomic path=game.functions.booleans.is.connect.IsConnected
~~~~ <isCrossing> name=IsCrossing type=SubLudeme (game.functions.booleans.is.edge.IsCrossing) => <boolean>, pack=game.functions.booleans.is.edge, label=isCrossing, cls=game.functions.booleans.is.edge.IsCrossing, keyword=isCrossing, atomic=IsCrossing, atomic path=game.functions.booleans.is.edge.IsCrossing
~~~~ <isLastFrom> name=IsLastFrom type=SubLudeme (game.functions.booleans.is.graph.IsLastFrom) => <boolean>, pack=game.functions.booleans.is.graph, label=isLastFrom, cls=game.functions.booleans.is.graph.IsLastFrom, keyword=isLastFrom, atomic=IsLastFrom, atomic path=game.functions.booleans.is.graph.IsLastFrom
~~~~ <isLastTo> name=IsLastTo type=SubLudeme (game.functions.booleans.is.graph.IsLastTo) => <boolean>, pack=game.functions.booleans.is.graph, label=isLastTo, cls=game.functions.booleans.is.graph.IsLastTo, keyword=isLastTo, atomic=IsLastTo, atomic path=game.functions.booleans.is.graph.IsLastTo
~~~~ <isIn> name=IsIn type=SuperLudeme (game.functions.booleans.is.in.IsIn) => <boolean>, pack=game.functions.booleans.is.in, label=isIn, cls=game.functions.booleans.is.in.IsIn, keyword=isIn, atomic=IsIn, atomic path=game.functions.booleans.is.in.IsIn
~~~~ <isAnyDie> name=IsAnyDie type=SubLudeme (game.functions.booleans.is.integer.IsAnyDie) => <boolean>, pack=game.functions.booleans.is.integer, label=isAnyDie, cls=game.functions.booleans.is.integer.IsAnyDie, keyword=isAnyDie, atomic=IsAnyDie, atomic path=game.functions.booleans.is.integer.IsAnyDie
~~~~ <isEven> name=IsEven type=SubLudeme (game.functions.booleans.is.integer.IsEven) => <boolean>, pack=game.functions.booleans.is.integer, label=isEven, cls=game.functions.booleans.is.integer.IsEven, keyword=isEven, atomic=IsEven, atomic path=game.functions.booleans.is.integer.IsEven
~~~~ <isFlat> name=IsFlat type=SubLudeme (game.functions.booleans.is.integer.IsFlat) => <boolean>, pack=game.functions.booleans.is.integer, label=isFlat, cls=game.functions.booleans.is.integer.IsFlat, keyword=isFlat, atomic=IsFlat, atomic path=game.functions.booleans.is.integer.IsFlat
~~~~ <isOdd> name=IsOdd type=SubLudeme (game.functions.booleans.is.integer.IsOdd) => <boolean>, pack=game.functions.booleans.is.integer, label=isOdd, cls=game.functions.booleans.is.integer.IsOdd, keyword=isOdd, atomic=IsOdd, atomic path=game.functions.booleans.is.integer.IsOdd
~~~~ <isPipsMatch> name=IsPipsMatch type=SubLudeme (game.functions.booleans.is.integer.IsPipsMatch) => <boolean>, pack=game.functions.booleans.is.integer, label=isPipsMatch, cls=game.functions.booleans.is.integer.IsPipsMatch, keyword=isPipsMatch, atomic=IsPipsMatch, atomic path=game.functions.booleans.is.integer.IsPipsMatch
~~~~ <isSidesMatch> name=IsSidesMatch type=SubLudeme (game.functions.booleans.is.integer.IsSidesMatch) => <boolean>, pack=game.functions.booleans.is.integer, label=isSidesMatch, cls=game.functions.booleans.is.integer.IsSidesMatch, keyword=isSidesMatch, atomic=IsSidesMatch, atomic path=game.functions.booleans.is.integer.IsSidesMatch
~~~~ <isVisited> name=IsVisited type=SubLudeme (game.functions.booleans.is.integer.IsVisited) => <boolean>, pack=game.functions.booleans.is.integer, label=isVisited, cls=game.functions.booleans.is.integer.IsVisited, keyword=isVisited, atomic=IsVisited, atomic path=game.functions.booleans.is.integer.IsVisited
~~~~ <isLine> name=IsLine type=SubLudeme (game.functions.booleans.is.line.IsLine) => <boolean>, pack=game.functions.booleans.is.line, label=isLine, cls=game.functions.booleans.is.line.IsLine, keyword=isLine, atomic=IsLine, atomic path=game.functions.booleans.is.line.IsLine
~~~~ <isLoop> name=IsLoop type=SubLudeme (game.functions.booleans.is.loop.IsLoop) => <boolean>, pack=game.functions.booleans.is.loop, label=isLoop, cls=game.functions.booleans.is.loop.IsLoop, keyword=isLoop, atomic=IsLoop, atomic path=game.functions.booleans.is.loop.IsLoop
~~~~ <isPath> name=IsPath type=SubLudeme (game.functions.booleans.is.path.IsPath) => <boolean>, pack=game.functions.booleans.is.path, label=isPath, cls=game.functions.booleans.is.path.IsPath, keyword=isPath, atomic=IsPath, atomic path=game.functions.booleans.is.path.IsPath
~~~~ <isPattern> name=IsPattern type=SubLudeme (game.functions.booleans.is.pattern.IsPattern) => <boolean>, pack=game.functions.booleans.is.pattern, label=isPattern, cls=game.functions.booleans.is.pattern.IsPattern, keyword=isPattern, atomic=IsPattern, atomic path=game.functions.booleans.is.pattern.IsPattern
~~~~ <isActive> name=IsActive type=SubLudeme (game.functions.booleans.is.player.IsActive) => <boolean>, pack=game.functions.booleans.is.player, label=isActive, cls=game.functions.booleans.is.player.IsActive, keyword=isActive, atomic=IsActive, atomic path=game.functions.booleans.is.player.IsActive
~~~~ <isEnemy> name=IsEnemy type=SubLudeme (game.functions.booleans.is.player.IsEnemy) => <boolean>, pack=game.functions.booleans.is.player, label=isEnemy, cls=game.functions.booleans.is.player.IsEnemy, keyword=isEnemy, atomic=IsEnemy, atomic path=game.functions.booleans.is.player.IsEnemy
~~~~ <isFriend> name=IsFriend type=SubLudeme (game.functions.booleans.is.player.IsFriend) => <boolean>, pack=game.functions.booleans.is.player, label=isFriend, cls=game.functions.booleans.is.player.IsFriend, keyword=isFriend, atomic=IsFriend, atomic path=game.functions.booleans.is.player.IsFriend
~~~~ <isMover> name=IsMover type=SubLudeme (game.functions.booleans.is.player.IsMover) => <boolean>, pack=game.functions.booleans.is.player, label=isMover, cls=game.functions.booleans.is.player.IsMover, keyword=isMover, atomic=IsMover, atomic path=game.functions.booleans.is.player.IsMover
~~~~ <isNext> name=IsNext type=SubLudeme (game.functions.booleans.is.player.IsNext) => <boolean>, pack=game.functions.booleans.is.player, label=isNext, cls=game.functions.booleans.is.player.IsNext, keyword=isNext, atomic=IsNext, atomic path=game.functions.booleans.is.player.IsNext
~~~~ <isPrev> name=IsPrev type=SubLudeme (game.functions.booleans.is.player.IsPrev) => <boolean>, pack=game.functions.booleans.is.player, label=isPrev, cls=game.functions.booleans.is.player.IsPrev, keyword=isPrev, atomic=IsPrev, atomic path=game.functions.booleans.is.player.IsPrev
~~~~ <isRegularGraph> name=IsRegularGraph type=SubLudeme (game.functions.booleans.is.regularGraph.IsRegularGraph) => <boolean>, pack=game.functions.booleans.is.regularGraph, label=isRegularGraph, cls=game.functions.booleans.is.regularGraph.IsRegularGraph, keyword=isRegularGraph, atomic=IsRegularGraph, atomic path=game.functions.booleans.is.regularGraph.IsRegularGraph
~~~~ <isRelated> name=IsRelated type=SubLudeme (game.functions.booleans.is.related.IsRelated) => <boolean>, pack=game.functions.booleans.is.related, label=isRelated, cls=game.functions.booleans.is.related.IsRelated, keyword=isRelated, atomic=IsRelated, atomic path=game.functions.booleans.is.related.IsRelated
~~~~ <isRepeat> name=IsRepeat type=SubLudeme (game.functions.booleans.is.repeat.IsRepeat) => <boolean>, pack=game.functions.booleans.is.repeat, label=isRepeat, cls=game.functions.booleans.is.repeat.IsRepeat, keyword=isRepeat, atomic=IsRepeat, atomic path=game.functions.booleans.is.repeat.IsRepeat
~~~~ <isCycle> name=IsCycle type=SubLudeme (game.functions.booleans.is.simple.IsCycle) => <boolean>, pack=game.functions.booleans.is.simple, label=isCycle, cls=game.functions.booleans.is.simple.IsCycle, keyword=isCycle, atomic=IsCycle, atomic path=game.functions.booleans.is.simple.IsCycle
~~~~ <isFull> name=IsFull type=SubLudeme (game.functions.booleans.is.simple.IsFull) => <boolean>, pack=game.functions.booleans.is.simple, label=isFull, cls=game.functions.booleans.is.simple.IsFull, keyword=isFull, atomic=IsFull, atomic path=game.functions.booleans.is.simple.IsFull
~~~~ <isPending> name=IsPending type=SubLudeme (game.functions.booleans.is.simple.IsPending) => <boolean>, pack=game.functions.booleans.is.simple, label=isPending, cls=game.functions.booleans.is.simple.IsPending, keyword=isPending, atomic=IsPending, atomic path=game.functions.booleans.is.simple.IsPending
~~~~ <isEmpty> name=IsEmpty type=SubLudeme (game.functions.booleans.is.site.IsEmpty) => <boolean>, pack=game.functions.booleans.is.site, label=isEmpty, cls=game.functions.booleans.is.site.IsEmpty, keyword=isEmpty, atomic=IsEmpty, atomic path=game.functions.booleans.is.site.IsEmpty
~~~~ <isOccupied> name=IsOccupied type=SubLudeme (game.functions.booleans.is.site.IsOccupied) => <boolean>, pack=game.functions.booleans.is.site, label=isOccupied, cls=game.functions.booleans.is.site.IsOccupied, keyword=isOccupied, atomic=IsOccupied, atomic path=game.functions.booleans.is.site.IsOccupied
~~~~ <isDecided> name=IsDecided type=SubLudeme (game.functions.booleans.is.string.IsDecided) => <boolean>, pack=game.functions.booleans.is.string, label=isDecided, cls=game.functions.booleans.is.string.IsDecided, keyword=isDecided, atomic=IsDecided, atomic path=game.functions.booleans.is.string.IsDecided
~~~~ <isProposed> name=IsProposed type=SubLudeme (game.functions.booleans.is.string.IsProposed) => <boolean>, pack=game.functions.booleans.is.string, label=isProposed, cls=game.functions.booleans.is.string.IsProposed, keyword=isProposed, atomic=IsProposed, atomic path=game.functions.booleans.is.string.IsProposed
~~~~ <isTarget> name=IsTarget type=SubLudeme (game.functions.booleans.is.target.IsTarget) => <boolean>, pack=game.functions.booleans.is.target, label=isTarget, cls=game.functions.booleans.is.target.IsTarget, keyword=isTarget, atomic=IsTarget, atomic path=game.functions.booleans.is.target.IsTarget
~~~~ <isCaterpillarTree> name=IsCaterpillarTree type=SubLudeme (game.functions.booleans.is.tree.IsCaterpillarTree) => <boolean>, pack=game.functions.booleans.is.tree, label=isCaterpillarTree, cls=game.functions.booleans.is.tree.IsCaterpillarTree, keyword=isCaterpillarTree, atomic=IsCaterpillarTree, atomic path=game.functions.booleans.is.tree.IsCaterpillarTree
~~~~ <isSpanningTree> name=IsSpanningTree type=SubLudeme (game.functions.booleans.is.tree.IsSpanningTree) => <boolean>, pack=game.functions.booleans.is.tree, label=isSpanningTree, cls=game.functions.booleans.is.tree.IsSpanningTree, keyword=isSpanningTree, atomic=IsSpanningTree, atomic path=game.functions.booleans.is.tree.IsSpanningTree
~~~~ <isTree> name=IsTree type=SubLudeme (game.functions.booleans.is.tree.IsTree) => <boolean>, pack=game.functions.booleans.is.tree, label=isTree, cls=game.functions.booleans.is.tree.IsTree, keyword=isTree, atomic=IsTree, atomic path=game.functions.booleans.is.tree.IsTree
~~~~ <isTreeCentre> name=IsTreeCentre type=SubLudeme (game.functions.booleans.is.tree.IsTreeCentre) => <boolean>, pack=game.functions.booleans.is.tree, label=isTreeCentre, cls=game.functions.booleans.is.tree.IsTreeCentre, keyword=isTreeCentre, atomic=IsTreeCentre, atomic path=game.functions.booleans.is.tree.IsTreeCentre
~~~~ <isTriggered> name=IsTriggered type=SubLudeme (game.functions.booleans.is.triggered.IsTriggered) => <boolean>, pack=game.functions.booleans.is.triggered, label=isTriggered, cls=game.functions.booleans.is.triggered.IsTriggered, keyword=isTriggered, atomic=IsTriggered, atomic path=game.functions.booleans.is.triggered.IsTriggered
gd~~ <math.and> name=And type=Ludeme (game.functions.booleans.math.And) => <boolean>, pack=game.functions.booleans.math, label=math.and, cls=game.functions.booleans.math.And, keyword=and, atomic=And, atomic path=game.functions.booleans.math.And
gd~~ <=> name=Equals type=Ludeme (game.functions.booleans.math.Equals) => <boolean>, pack=game.functions.booleans.math, label==, cls=game.functions.booleans.math.Equals, keyword==, atomic=Equals, atomic path=game.functions.booleans.math.Equals
gd~~ <>=> name=Ge type=Ludeme (game.functions.booleans.math.Ge) => <boolean>, pack=game.functions.booleans.math, label=>=, cls=game.functions.booleans.math.Ge, keyword=>=, atomic=Ge, atomic path=game.functions.booleans.math.Ge
gd~~ <>> name=Gt type=Ludeme (game.functions.booleans.math.Gt) => <boolean>, pack=game.functions.booleans.math, label=>, cls=game.functions.booleans.math.Gt, keyword=>, atomic=Gt, atomic path=game.functions.booleans.math.Gt
gd~~ <booleans.math.if> name=If type=Ludeme (game.functions.booleans.math.If) => <boolean>, pack=game.functions.booleans.math, label=booleans.math.if, cls=game.functions.booleans.math.If, keyword=if, atomic=If, atomic path=game.functions.booleans.math.If
gd~~ <<=> name=Le type=Ludeme (game.functions.booleans.math.Le) => <boolean>, pack=game.functions.booleans.math, label=<=, cls=game.functions.booleans.math.Le, keyword=<=, atomic=Le, atomic path=game.functions.booleans.math.Le
gd~~ <<> name=Lt type=Ludeme (game.functions.booleans.math.Lt) => <boolean>, pack=game.functions.booleans.math, label=<, cls=game.functions.booleans.math.Lt, keyword=<, atomic=Lt, atomic path=game.functions.booleans.math.Lt
gd~~ <not> name=Not type=Ludeme (game.functions.booleans.math.Not) => <boolean>, pack=game.functions.booleans.math, label=not, cls=game.functions.booleans.math.Not, keyword=not, atomic=Not, atomic path=game.functions.booleans.math.Not
gd~~ <!=> name=NotEqual type=Ludeme (game.functions.booleans.math.NotEqual) => <boolean>, pack=game.functions.booleans.math, label=!=, cls=game.functions.booleans.math.NotEqual, keyword=!=, atomic=NotEqual, atomic path=game.functions.booleans.math.NotEqual
gd~~ <math.or> name=Or type=Ludeme (game.functions.booleans.math.Or) => <boolean>, pack=game.functions.booleans.math, label=math.or, cls=game.functions.booleans.math.Or, keyword=or, atomic=Or, atomic path=game.functions.booleans.math.Or
gd~~ <xor> name=Xor type=Ludeme (game.functions.booleans.math.Xor) => <boolean>, pack=game.functions.booleans.math, label=xor, cls=game.functions.booleans.math.Xor, keyword=xor, atomic=Xor, atomic path=game.functions.booleans.math.Xor
gd~~ <booleans.no.no> name=No type=SuperLudeme (game.functions.booleans.no.No) => <boolean>, pack=game.functions.booleans.no, label=booleans.no.no, cls=game.functions.booleans.no.No, keyword=no, atomic=No, atomic path=game.functions.booleans.no.No
~~~~ <noMoveType> name=NoMoveType type=Structural (game.functions.booleans.no.NoMoveType) => <noMoveType>, pack=game.functions.booleans.no, label=noMoveType, cls=game.functions.booleans.no.NoMoveType, keyword=noMoveType, atomic=NoMoveType, atomic path=game.functions.booleans.no.NoMoveType
~~~~ <noPieceType> name=NoPieceType type=Structural (game.functions.booleans.no.NoPieceType) => <noPieceType>, pack=game.functions.booleans.no, label=noPieceType, cls=game.functions.booleans.no.NoPieceType, keyword=noPieceType, atomic=NoPieceType, atomic path=game.functions.booleans.no.NoPieceType
~~~~ <noMoves> name=NoMoves type=SubLudeme (game.functions.booleans.no.moves.NoMoves) => <boolean>, pack=game.functions.booleans.no.moves, label=noMoves, cls=game.functions.booleans.no.moves.NoMoves, keyword=noMoves, atomic=NoMoves, atomic path=game.functions.booleans.no.moves.NoMoves
~~~~ <noPieces> name=NoPieces type=SubLudeme (game.functions.booleans.no.pieces.NoPieces) => <boolean>, pack=game.functions.booleans.no.pieces, label=noPieces, cls=game.functions.booleans.no.pieces.NoPieces, keyword=noPieces, atomic=NoPieces, atomic path=game.functions.booleans.no.pieces.NoPieces
gd~~ <was> name=Was type=SuperLudeme (game.functions.booleans.was.Was) => <boolean>, pack=game.functions.booleans.was, label=was, cls=game.functions.booleans.was.Was, keyword=was, atomic=Was, atomic path=game.functions.booleans.was.Was
~~~~ <wasPass> name=WasPass type=SubLudeme (game.functions.booleans.was.WasPass) => <boolean>, pack=game.functions.booleans.was, label=wasPass, cls=game.functions.booleans.was.WasPass, keyword=wasPass, atomic=WasPass, atomic path=game.functions.booleans.was.WasPass
~~~~ <wasType> name=WasType type=Structural (game.functions.booleans.was.WasType) => <wasType>, pack=game.functions.booleans.was, label=wasType, cls=game.functions.booleans.was.WasType, keyword=wasType, atomic=WasType, atomic path=game.functions.booleans.was.WasType
gd~* <dim> name=BaseDimFunction type=Ludeme (game.functions.dim.BaseDimFunction) => <dim>, pack=game.functions.dim, label=dim, cls=game.functions.dim.BaseDimFunction, keyword=dim, atomic=BaseDimFunction, atomic path=game.functions.dim.BaseDimFunction
~~~~ <dimConstant> name=DimConstant type=Ludeme (game.functions.dim.DimConstant) => <int>, pack=game.functions.dim, label=dimConstant, cls=game.functions.dim.DimConstant, keyword=dimConstant, atomic=int, atomic path=int
g~~* <dim> name=DimFunction type=Structural (game.functions.dim.DimFunction) => <int>, pack=game.functions.dim, label=dim, cls=game.functions.dim.DimFunction, keyword=dimFunction, atomic=int, atomic path=int
gd~~ <dim.math.abs> name=Abs type=Ludeme (game.functions.dim.math.Abs) => <int>, pack=game.functions.dim.math, label=dim.math.abs, cls=game.functions.dim.math.Abs, keyword=abs, atomic=Abs, atomic path=game.functions.dim.math.Abs
gd~~ <dim.math.+> name=Add type=Ludeme (game.functions.dim.math.Add) => <int>, pack=game.functions.dim.math, label=dim.math.+, cls=game.functions.dim.math.Add, keyword=+, atomic=Add, atomic path=game.functions.dim.math.Add
gd~~ <dim.math./> name=Div type=Ludeme (game.functions.dim.math.Div) => <int>, pack=game.functions.dim.math, label=dim.math./, cls=game.functions.dim.math.Div, keyword=/, atomic=Div, atomic path=game.functions.dim.math.Div
gd~~ <dim.math.max> name=Max type=Ludeme (game.functions.dim.math.Max) => <int>, pack=game.functions.dim.math, label=dim.math.max, cls=game.functions.dim.math.Max, keyword=max, atomic=Max, atomic path=game.functions.dim.math.Max
gd~~ <dim.math.min> name=Min type=Ludeme (game.functions.dim.math.Min) => <int>, pack=game.functions.dim.math, label=dim.math.min, cls=game.functions.dim.math.Min, keyword=min, atomic=Min, atomic path=game.functions.dim.math.Min
gd~~ <dim.math.*> name=Mul type=Ludeme (game.functions.dim.math.Mul) => <int>, pack=game.functions.dim.math, label=dim.math.*, cls=game.functions.dim.math.Mul, keyword=*, atomic=Mul, atomic path=game.functions.dim.math.Mul
gd~~ <dim.math.^> name=Pow type=Ludeme (game.functions.dim.math.Pow) => <int>, pack=game.functions.dim.math, label=dim.math.^, cls=game.functions.dim.math.Pow, keyword=^, atomic=Pow, atomic path=game.functions.dim.math.Pow
gd~~ <dim.math.-> name=Sub type=Ludeme (game.functions.dim.math.Sub) => <int>, pack=game.functions.dim.math, label=dim.math.-, cls=game.functions.dim.math.Sub, keyword=-, atomic=Sub, atomic path=game.functions.dim.math.Sub
gd~~ <directions.difference> name=Difference type=Ludeme (game.functions.directions.Difference) => <direction>, pack=game.functions.directions, label=directions.difference, cls=game.functions.directions.Difference, keyword=difference, atomic=Difference, atomic path=game.functions.directions.Difference
gd~~ <directions> name=Directions type=Ludeme (game.functions.directions.Directions) => <directions>, pack=game.functions.directions, label=directions, cls=game.functions.directions.Directions, keyword=directions, atomic=Directions, atomic path=game.functions.directions.Directions
~~~* <directions> name=DirectionsFunction type=Ludeme (game.functions.directions.DirectionsFunction) => <directions>, pack=game.functions.directions, label=directions, cls=game.functions.directions.DirectionsFunction, keyword=directionsFunction, atomic=DirectionsFunction, atomic path=game.functions.directions.DirectionsFunction
gd~~ <directions.if> name=If type=Ludeme (game.functions.directions.If) => <directions.if>, pack=game.functions.directions, label=directions.if, cls=game.functions.directions.If, keyword=if, atomic=If, atomic path=game.functions.directions.If
~~~~ <randomDirectionType> name=RandomDirectionType type=Structural (game.functions.directions.RandomDirectionType) => <randomDirectionType>, pack=game.functions.directions, label=randomDirectionType, cls=game.functions.directions.RandomDirectionType, keyword=randomDirectionType, atomic=RandomDirectionType, atomic path=game.functions.directions.RandomDirectionType
gd~~ <directions.union> name=Union type=Ludeme (game.functions.directions.Union) => <direction>, pack=game.functions.directions, label=directions.union, cls=game.functions.directions.Union, keyword=union, atomic=Union, atomic path=game.functions.directions.Union
~~~* <baseFloatFunction> name=BaseFloatFunction type=Ludeme (game.functions.floats.BaseFloatFunction) => <baseFloatFunction>, pack=game.functions.floats, label=baseFloatFunction, cls=game.functions.floats.BaseFloatFunction, keyword=baseFloatFunction, atomic=BaseFloatFunction, atomic path=game.functions.floats.BaseFloatFunction
~~~~ <floatConstant> name=FloatConstant type=Ludeme (game.functions.floats.FloatConstant) => <float>, pack=game.functions.floats, label=floatConstant, cls=game.functions.floats.FloatConstant, keyword=floatConstant, atomic=float, atomic path=float
g~~* <float> name=FloatFunction type=Structural (game.functions.floats.FloatFunction) => <float>, pack=game.functions.floats, label=float, cls=game.functions.floats.FloatFunction, keyword=floatFunction, atomic=float, atomic path=float
gd~~ <toFloat> name=ToFloat type=Ludeme (game.functions.floats.ToFloat) => <float>, pack=game.functions.floats, label=toFloat, cls=game.functions.floats.ToFloat, keyword=toFloat, atomic=ToFloat, atomic path=game.functions.floats.ToFloat
gd~~ <floats.math.abs> name=Abs type=Ludeme (game.functions.floats.math.Abs) => <float>, pack=game.functions.floats.math, label=floats.math.abs, cls=game.functions.floats.math.Abs, keyword=abs, atomic=Abs, atomic path=game.functions.floats.math.Abs
gd~~ <floats.math.+> name=Add type=Ludeme (game.functions.floats.math.Add) => <float>, pack=game.functions.floats.math, label=floats.math.+, cls=game.functions.floats.math.Add, keyword=+, atomic=Add, atomic path=game.functions.floats.math.Add
gd~~ <cos> name=Cos type=Ludeme (game.functions.floats.math.Cos) => <float>, pack=game.functions.floats.math, label=cos, cls=game.functions.floats.math.Cos, keyword=cos, atomic=Cos, atomic path=game.functions.floats.math.Cos
gd~~ <floats.math./> name=Div type=Ludeme (game.functions.floats.math.Div) => <float>, pack=game.functions.floats.math, label=floats.math./, cls=game.functions.floats.math.Div, keyword=/, atomic=Div, atomic path=game.functions.floats.math.Div
gd~~ <exp> name=Exp type=Ludeme (game.functions.floats.math.Exp) => <float>, pack=game.functions.floats.math, label=exp, cls=game.functions.floats.math.Exp, keyword=exp, atomic=Exp, atomic path=game.functions.floats.math.Exp
gd~~ <log> name=Log type=Ludeme (game.functions.floats.math.Log) => <float>, pack=game.functions.floats.math, label=log, cls=game.functions.floats.math.Log, keyword=log, atomic=Log, atomic path=game.functions.floats.math.Log
gd~~ <log10> name=Log10 type=Ludeme (game.functions.floats.math.Log10) => <float>, pack=game.functions.floats.math, label=log10, cls=game.functions.floats.math.Log10, keyword=log10, atomic=Log10, atomic path=game.functions.floats.math.Log10
gd~~ <floats.math.max> name=Max type=Ludeme (game.functions.floats.math.Max) => <float>, pack=game.functions.floats.math, label=floats.math.max, cls=game.functions.floats.math.Max, keyword=max, atomic=Max, atomic path=game.functions.floats.math.Max
gd~~ <floats.math.min> name=Min type=Ludeme (game.functions.floats.math.Min) => <float>, pack=game.functions.floats.math, label=floats.math.min, cls=game.functions.floats.math.Min, keyword=min, atomic=Min, atomic path=game.functions.floats.math.Min
gd~~ <floats.math.*> name=Mul type=Ludeme (game.functions.floats.math.Mul) => <float>, pack=game.functions.floats.math, label=floats.math.*, cls=game.functions.floats.math.Mul, keyword=*, atomic=Mul, atomic path=game.functions.floats.math.Mul
gd~~ <floats.math.^> name=Pow type=Ludeme (game.functions.floats.math.Pow) => <float>, pack=game.functions.floats.math, label=floats.math.^, cls=game.functions.floats.math.Pow, keyword=^, atomic=Pow, atomic path=game.functions.floats.math.Pow
gd~~ <sin> name=Sin type=Ludeme (game.functions.floats.math.Sin) => <float>, pack=game.functions.floats.math, label=sin, cls=game.functions.floats.math.Sin, keyword=sin, atomic=Sin, atomic path=game.functions.floats.math.Sin
gd~~ <sqrt> name=Sqrt type=Ludeme (game.functions.floats.math.Sqrt) => <float>, pack=game.functions.floats.math, label=sqrt, cls=game.functions.floats.math.Sqrt, keyword=sqrt, atomic=Sqrt, atomic path=game.functions.floats.math.Sqrt
gd~~ <floats.math.-> name=Sub type=Ludeme (game.functions.floats.math.Sub) => <float>, pack=game.functions.floats.math, label=floats.math.-, cls=game.functions.floats.math.Sub, keyword=-, atomic=Sub, atomic path=game.functions.floats.math.Sub
gd~~ <tan> name=Tan type=Ludeme (game.functions.floats.math.Tan) => <float>, pack=game.functions.floats.math, label=tan, cls=game.functions.floats.math.Tan, keyword=tan, atomic=Tan, atomic path=game.functions.floats.math.Tan
gd~* <baseGraphFunction> name=BaseGraphFunction type=Ludeme (game.functions.graph.BaseGraphFunction) => <graph>, pack=game.functions.graph, label=baseGraphFunction, cls=game.functions.graph.BaseGraphFunction, keyword=baseGraphFunction, atomic=BaseGraphFunction, atomic path=game.functions.graph.BaseGraphFunction
g~~* <graph> name=GraphFunction type=Structural (game.functions.graph.GraphFunction) => <graph>, pack=game.functions.graph, label=graph, cls=game.functions.graph.GraphFunction, keyword=graphFunction, atomic=Graph, atomic path=game.util.graph.Graph
g~~* <basis> name=Basis type=Structural (game.functions.graph.generators.basis.Basis) => <graph>, pack=game.functions.graph.generators.basis, label=basis, cls=game.functions.graph.generators.basis.Basis, keyword=basis, atomic=Basis, atomic path=game.functions.graph.generators.basis.Basis
gd~~ <brick> name=Brick type=SuperLudeme (game.functions.graph.generators.basis.brick.Brick) => <graph>, pack=game.functions.graph.generators.basis.brick, label=brick, cls=game.functions.graph.generators.basis.brick.Brick, keyword=brick, atomic=Brick, atomic path=game.functions.graph.generators.basis.brick.Brick
g~~~ <brickShapeType> name=BrickShapeType type=Structural (game.functions.graph.generators.basis.brick.BrickShapeType) => <brickShapeType>, pack=game.functions.graph.generators.basis.brick, label=brickShapeType, cls=game.functions.graph.generators.basis.brick.BrickShapeType, keyword=brickShapeType, atomic=BrickShapeType, atomic path=game.functions.graph.generators.basis.brick.BrickShapeType
~~~~ <diamondOrPrismOnBrick> name=DiamondOrPrismOnBrick type=SubLudeme (game.functions.graph.generators.basis.brick.DiamondOrPrismOnBrick) => <graph>, pack=game.functions.graph.generators.basis.brick, label=diamondOrPrismOnBrick, cls=game.functions.graph.generators.basis.brick.DiamondOrPrismOnBrick, keyword=diamondOrPrismOnBrick, atomic=DiamondOrPrismOnBrick, atomic path=game.functions.graph.generators.basis.brick.DiamondOrPrismOnBrick
~~~~ <spiralOnBrick> name=SpiralOnBrick type=SubLudeme (game.functions.graph.generators.basis.brick.SpiralOnBrick) => <graph>, pack=game.functions.graph.generators.basis.brick, label=spiralOnBrick, cls=game.functions.graph.generators.basis.brick.SpiralOnBrick, keyword=spiralOnBrick, atomic=SpiralOnBrick, atomic path=game.functions.graph.generators.basis.brick.SpiralOnBrick
~~~~ <squareOrRectangleOnBrick> name=SquareOrRectangleOnBrick type=SubLudeme (game.functions.graph.generators.basis.brick.SquareOrRectangleOnBrick) => <graph>, pack=game.functions.graph.generators.basis.brick, label=squareOrRectangleOnBrick, cls=game.functions.graph.generators.basis.brick.SquareOrRectangleOnBrick, keyword=squareOrRectangleOnBrick, atomic=SquareOrRectangleOnBrick, atomic path=game.functions.graph.generators.basis.brick.SquareOrRectangleOnBrick
gd~~ <celtic> name=Celtic type=Ludeme (game.functions.graph.generators.basis.celtic.Celtic) => <graph>, pack=game.functions.graph.generators.basis.celtic, label=celtic, cls=game.functions.graph.generators.basis.celtic.Celtic, keyword=celtic, atomic=Celtic, atomic path=game.functions.graph.generators.basis.celtic.Celtic
~~~~ <customOnHex> name=CustomOnHex type=SubLudeme (game.functions.graph.generators.basis.hex.CustomOnHex) => <graph>, pack=game.functions.graph.generators.basis.hex, label=customOnHex, cls=game.functions.graph.generators.basis.hex.CustomOnHex, keyword=customOnHex, atomic=CustomOnHex, atomic path=game.functions.graph.generators.basis.hex.CustomOnHex
~~~~ <diamondOnHex> name=DiamondOnHex type=SubLudeme (game.functions.graph.generators.basis.hex.DiamondOnHex) => <graph>, pack=game.functions.graph.generators.basis.hex, label=diamondOnHex, cls=game.functions.graph.generators.basis.hex.DiamondOnHex, keyword=diamondOnHex, atomic=DiamondOnHex, atomic path=game.functions.graph.generators.basis.hex.DiamondOnHex
gd~~ <hex> name=Hex type=SuperLudeme (game.functions.graph.generators.basis.hex.Hex) => <graph>, pack=game.functions.graph.generators.basis.hex, label=hex, cls=game.functions.graph.generators.basis.hex.Hex, keyword=hex, atomic=Hex, atomic path=game.functions.graph.generators.basis.hex.Hex
g~~~ <hexShapeType> name=HexShapeType type=Structural (game.functions.graph.generators.basis.hex.HexShapeType) => <hexShapeType>, pack=game.functions.graph.generators.basis.hex, label=hexShapeType, cls=game.functions.graph.generators.basis.hex.HexShapeType, keyword=hexShapeType, atomic=HexShapeType, atomic path=game.functions.graph.generators.basis.hex.HexShapeType
~~~~ <hexagonOnHex> name=HexagonOnHex type=SubLudeme (game.functions.graph.generators.basis.hex.HexagonOnHex) => <graph>, pack=game.functions.graph.generators.basis.hex, label=hexagonOnHex, cls=game.functions.graph.generators.basis.hex.HexagonOnHex, keyword=hexagonOnHex, atomic=HexagonOnHex, atomic path=game.functions.graph.generators.basis.hex.HexagonOnHex
~~~~ <rectangleOnHex> name=RectangleOnHex type=SubLudeme (game.functions.graph.generators.basis.hex.RectangleOnHex) => <graph>, pack=game.functions.graph.generators.basis.hex, label=rectangleOnHex, cls=game.functions.graph.generators.basis.hex.RectangleOnHex, keyword=rectangleOnHex, atomic=RectangleOnHex, atomic path=game.functions.graph.generators.basis.hex.RectangleOnHex
~~~~ <starOnHex> name=StarOnHex type=SubLudeme (game.functions.graph.generators.basis.hex.StarOnHex) => <graph>, pack=game.functions.graph.generators.basis.hex, label=starOnHex, cls=game.functions.graph.generators.basis.hex.StarOnHex, keyword=starOnHex, atomic=StarOnHex, atomic path=game.functions.graph.generators.basis.hex.StarOnHex
~~~~ <triangleOnHex> name=TriangleOnHex type=SubLudeme (game.functions.graph.generators.basis.hex.TriangleOnHex) => <graph>, pack=game.functions.graph.generators.basis.hex, label=triangleOnHex, cls=game.functions.graph.generators.basis.hex.TriangleOnHex, keyword=triangleOnHex, atomic=TriangleOnHex, atomic path=game.functions.graph.generators.basis.hex.TriangleOnHex
~~~~ <customOnMesh> name=CustomOnMesh type=SubLudeme (game.functions.graph.generators.basis.mesh.CustomOnMesh) => <graph>, pack=game.functions.graph.generators.basis.mesh, label=customOnMesh, cls=game.functions.graph.generators.basis.mesh.CustomOnMesh, keyword=customOnMesh, atomic=CustomOnMesh, atomic path=game.functions.graph.generators.basis.mesh.CustomOnMesh
~~~~ <mesh> name=Mesh type=SuperLudeme (game.functions.graph.generators.basis.mesh.Mesh) => <graph>, pack=game.functions.graph.generators.basis.mesh, label=mesh, cls=game.functions.graph.generators.basis.mesh.Mesh, keyword=mesh, atomic=Mesh, atomic path=game.functions.graph.generators.basis.mesh.Mesh
gd~~ <quadhex> name=Quadhex type=Ludeme (game.functions.graph.generators.basis.quadhex.Quadhex) => <graph>, pack=game.functions.graph.generators.basis.quadhex, label=quadhex, cls=game.functions.graph.generators.basis.quadhex.Quadhex, keyword=quadhex, atomic=Quadhex, atomic path=game.functions.graph.generators.basis.quadhex.Quadhex
~~~~ <customOnSquare> name=CustomOnSquare type=SubLudeme (game.functions.graph.generators.basis.square.CustomOnSquare) => <graph>, pack=game.functions.graph.generators.basis.square, label=customOnSquare, cls=game.functions.graph.generators.basis.square.CustomOnSquare, keyword=customOnSquare, atomic=CustomOnSquare, atomic path=game.functions.graph.generators.basis.square.CustomOnSquare
g~~~ <diagonalsType> name=DiagonalsType type=Structural (game.functions.graph.generators.basis.square.DiagonalsType) => <diagonalsType>, pack=game.functions.graph.generators.basis.square, label=diagonalsType, cls=game.functions.graph.generators.basis.square.DiagonalsType, keyword=diagonalsType, atomic=DiagonalsType, atomic path=game.functions.graph.generators.basis.square.DiagonalsType
~~~~ <diamondOnSquare> name=DiamondOnSquare type=SubLudeme (game.functions.graph.generators.basis.square.DiamondOnSquare) => <graph>, pack=game.functions.graph.generators.basis.square, label=diamondOnSquare, cls=game.functions.graph.generators.basis.square.DiamondOnSquare, keyword=diamondOnSquare, atomic=DiamondOnSquare, atomic path=game.functions.graph.generators.basis.square.DiamondOnSquare
~~~~ <rectangleOnSquare> name=RectangleOnSquare type=SubLudeme (game.functions.graph.generators.basis.square.RectangleOnSquare) => <graph>, pack=game.functions.graph.generators.basis.square, label=rectangleOnSquare, cls=game.functions.graph.generators.basis.square.RectangleOnSquare, keyword=rectangleOnSquare, atomic=RectangleOnSquare, atomic path=game.functions.graph.generators.basis.square.RectangleOnSquare
gd~~ <square> name=Square type=SuperLudeme (game.functions.graph.generators.basis.square.Square) => <graph>, pack=game.functions.graph.generators.basis.square, label=square, cls=game.functions.graph.generators.basis.square.Square, keyword=square, atomic=Square, atomic path=game.functions.graph.generators.basis.square.Square
g~~~ <squareShapeType> name=SquareShapeType type=Structural (game.functions.graph.generators.basis.square.SquareShapeType) => <squareShapeType>, pack=game.functions.graph.generators.basis.square, label=squareShapeType, cls=game.functions.graph.generators.basis.square.SquareShapeType, keyword=squareShapeType, atomic=SquareShapeType, atomic path=game.functions.graph.generators.basis.square.SquareShapeType
gd~~ <tiling> name=Tiling type=SuperLudeme (game.functions.graph.generators.basis.tiling.Tiling) => <graph>, pack=game.functions.graph.generators.basis.tiling, label=tiling, cls=game.functions.graph.generators.basis.tiling.Tiling, keyword=tiling, atomic=Tiling, atomic path=game.functions.graph.generators.basis.tiling.Tiling
g~~~ <tilingType> name=TilingType type=Structural (game.functions.graph.generators.basis.tiling.TilingType) => <tilingType>, pack=game.functions.graph.generators.basis.tiling, label=tilingType, cls=game.functions.graph.generators.basis.tiling.TilingType, keyword=tilingType, atomic=TilingType, atomic path=game.functions.graph.generators.basis.tiling.TilingType
~~~~ <tiling31212> name=Tiling31212 type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling31212.Tiling31212) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling31212, label=tiling31212, cls=game.functions.graph.generators.basis.tiling.tiling31212.Tiling31212, keyword=tiling31212, atomic=Tiling31212, atomic path=game.functions.graph.generators.basis.tiling.tiling31212.Tiling31212
~~~~ <tiling333333_33434> name=Tiling333333_33434 type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling333333_33434.Tiling333333_33434) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling333333_33434, label=tiling333333_33434, cls=game.functions.graph.generators.basis.tiling.tiling333333_33434.Tiling333333_33434, keyword=tiling333333_33434, atomic=Tiling333333_33434, atomic path=game.functions.graph.generators.basis.tiling.tiling333333_33434.Tiling333333_33434
~~~~ <tiling33336> name=Tiling33336 type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling33336.Tiling33336) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling33336, label=tiling33336, cls=game.functions.graph.generators.basis.tiling.tiling33336.Tiling33336, keyword=tiling33336, atomic=Tiling33336, atomic path=game.functions.graph.generators.basis.tiling.tiling33336.Tiling33336
~~~~ <customOn33344> name=CustomOn33344 type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling33344.CustomOn33344) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling33344, label=customOn33344, cls=game.functions.graph.generators.basis.tiling.tiling33344.CustomOn33344, keyword=customOn33344, atomic=CustomOn33344, atomic path=game.functions.graph.generators.basis.tiling.tiling33344.CustomOn33344
~~~~ <tiling33344> name=Tiling33344 type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling33344.Tiling33344) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling33344, label=tiling33344, cls=game.functions.graph.generators.basis.tiling.tiling33344.Tiling33344, keyword=tiling33344, atomic=Tiling33344, atomic path=game.functions.graph.generators.basis.tiling.tiling33344.Tiling33344
~~~~ <tiling33434> name=Tiling33434 type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling33434.Tiling33434) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling33434, label=tiling33434, cls=game.functions.graph.generators.basis.tiling.tiling33434.Tiling33434, keyword=tiling33434, atomic=Tiling33434, atomic path=game.functions.graph.generators.basis.tiling.tiling33434.Tiling33434
~~~~ <customOn3464> name=CustomOn3464 type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling3464.CustomOn3464) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=customOn3464, cls=game.functions.graph.generators.basis.tiling.tiling3464.CustomOn3464, keyword=customOn3464, atomic=CustomOn3464, atomic path=game.functions.graph.generators.basis.tiling.tiling3464.CustomOn3464
~~~~ <diamondOn3464> name=DiamondOn3464 type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling3464.DiamondOn3464) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=diamondOn3464, cls=game.functions.graph.generators.basis.tiling.tiling3464.DiamondOn3464, keyword=diamondOn3464, atomic=DiamondOn3464, atomic path=game.functions.graph.generators.basis.tiling.tiling3464.DiamondOn3464
~~~~ <hexagonOn3464> name=HexagonOn3464 type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling3464.HexagonOn3464) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=hexagonOn3464, cls=game.functions.graph.generators.basis.tiling.tiling3464.HexagonOn3464, keyword=hexagonOn3464, atomic=HexagonOn3464, atomic path=game.functions.graph.generators.basis.tiling.tiling3464.HexagonOn3464
~~~~ <parallelogramOn3464> name=ParallelogramOn3464 type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling3464.ParallelogramOn3464) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=parallelogramOn3464, cls=game.functions.graph.generators.basis.tiling.tiling3464.ParallelogramOn3464, keyword=parallelogramOn3464, atomic=ParallelogramOn3464, atomic path=game.functions.graph.generators.basis.tiling.tiling3464.ParallelogramOn3464
~~~~ <rectangleOn3464> name=RectangleOn3464 type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling3464.RectangleOn3464) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=rectangleOn3464, cls=game.functions.graph.generators.basis.tiling.tiling3464.RectangleOn3464, keyword=rectangleOn3464, atomic=RectangleOn3464, atomic path=game.functions.graph.generators.basis.tiling.tiling3464.RectangleOn3464
~~~~ <starOn3464> name=StarOn3464 type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling3464.StarOn3464) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=starOn3464, cls=game.functions.graph.generators.basis.tiling.tiling3464.StarOn3464, keyword=starOn3464, atomic=StarOn3464, atomic path=game.functions.graph.generators.basis.tiling.tiling3464.StarOn3464
~~~~ <tiling3464> name=Tiling3464 type=SuperLudeme (game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464) => <tiling3464>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=tiling3464, cls=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464, keyword=tiling3464, atomic=Tiling3464, atomic path=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464
~~~~ <tiling3464ShapeType> name=Tiling3464ShapeType type=Structural (game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType) => <tiling3464ShapeType>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=tiling3464ShapeType, cls=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType, keyword=tiling3464ShapeType, atomic=Tiling3464ShapeType, atomic path=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType
~~~~ <triangleOn3464> name=TriangleOn3464 type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling3464.TriangleOn3464) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=triangleOn3464, cls=game.functions.graph.generators.basis.tiling.tiling3464.TriangleOn3464, keyword=triangleOn3464, atomic=TriangleOn3464, atomic path=game.functions.graph.generators.basis.tiling.tiling3464.TriangleOn3464
~~~~ <customOn3636> name=CustomOn3636 type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling3636.CustomOn3636) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling3636, label=customOn3636, cls=game.functions.graph.generators.basis.tiling.tiling3636.CustomOn3636, keyword=customOn3636, atomic=CustomOn3636, atomic path=game.functions.graph.generators.basis.tiling.tiling3636.CustomOn3636
~~~~ <tiling3636> name=Tiling3636 type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling3636.Tiling3636) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling3636, label=tiling3636, cls=game.functions.graph.generators.basis.tiling.tiling3636.Tiling3636, keyword=tiling3636, atomic=Tiling3636, atomic path=game.functions.graph.generators.basis.tiling.tiling3636.Tiling3636
~~~~ <tiling4612> name=Tiling4612 type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling4612.Tiling4612) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling4612, label=tiling4612, cls=game.functions.graph.generators.basis.tiling.tiling4612.Tiling4612, keyword=tiling4612, atomic=Tiling4612, atomic path=game.functions.graph.generators.basis.tiling.tiling4612.Tiling4612
~~~~ <customOn488> name=CustomOn488 type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling488.CustomOn488) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling488, label=customOn488, cls=game.functions.graph.generators.basis.tiling.tiling488.CustomOn488, keyword=customOn488, atomic=CustomOn488, atomic path=game.functions.graph.generators.basis.tiling.tiling488.CustomOn488
~~~~ <squareOrRectangleOn488> name=SquareOrRectangleOn488 type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling488.SquareOrRectangleOn488) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling488, label=squareOrRectangleOn488, cls=game.functions.graph.generators.basis.tiling.tiling488.SquareOrRectangleOn488, keyword=squareOrRectangleOn488, atomic=SquareOrRectangleOn488, atomic path=game.functions.graph.generators.basis.tiling.tiling488.SquareOrRectangleOn488
~~~~ <tiling488> name=Tiling488 type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling488.Tiling488) => <tiling488>, pack=game.functions.graph.generators.basis.tiling.tiling488, label=tiling488, cls=game.functions.graph.generators.basis.tiling.tiling488.Tiling488, keyword=tiling488, atomic=Tiling488, atomic path=game.functions.graph.generators.basis.tiling.tiling488.Tiling488
~~~~ <customOnTri> name=CustomOnTri type=SubLudeme (game.functions.graph.generators.basis.tri.CustomOnTri) => <graph>, pack=game.functions.graph.generators.basis.tri, label=customOnTri, cls=game.functions.graph.generators.basis.tri.CustomOnTri, keyword=customOnTri, atomic=CustomOnTri, atomic path=game.functions.graph.generators.basis.tri.CustomOnTri
~~~~ <diamondOnTri> name=DiamondOnTri type=SubLudeme (game.functions.graph.generators.basis.tri.DiamondOnTri) => <graph>, pack=game.functions.graph.generators.basis.tri, label=diamondOnTri, cls=game.functions.graph.generators.basis.tri.DiamondOnTri, keyword=diamondOnTri, atomic=DiamondOnTri, atomic path=game.functions.graph.generators.basis.tri.DiamondOnTri
~~~~ <hexagonOnTri> name=HexagonOnTri type=SubLudeme (game.functions.graph.generators.basis.tri.HexagonOnTri) => <graph>, pack=game.functions.graph.generators.basis.tri, label=hexagonOnTri, cls=game.functions.graph.generators.basis.tri.HexagonOnTri, keyword=hexagonOnTri, atomic=HexagonOnTri, atomic path=game.functions.graph.generators.basis.tri.HexagonOnTri
~~~~ <rectangleOnTri> name=RectangleOnTri type=SubLudeme (game.functions.graph.generators.basis.tri.RectangleOnTri) => <graph>, pack=game.functions.graph.generators.basis.tri, label=rectangleOnTri, cls=game.functions.graph.generators.basis.tri.RectangleOnTri, keyword=rectangleOnTri, atomic=RectangleOnTri, atomic path=game.functions.graph.generators.basis.tri.RectangleOnTri
~~~~ <starOnTri> name=StarOnTri type=SubLudeme (game.functions.graph.generators.basis.tri.StarOnTri) => <graph>, pack=game.functions.graph.generators.basis.tri, label=starOnTri, cls=game.functions.graph.generators.basis.tri.StarOnTri, keyword=starOnTri, atomic=StarOnTri, atomic path=game.functions.graph.generators.basis.tri.StarOnTri
gd~~ <tri> name=Tri type=SuperLudeme (game.functions.graph.generators.basis.tri.Tri) => <graph>, pack=game.functions.graph.generators.basis.tri, label=tri, cls=game.functions.graph.generators.basis.tri.Tri, keyword=tri, atomic=Tri, atomic path=game.functions.graph.generators.basis.tri.Tri
g~~~ <triShapeType> name=TriShapeType type=Structural (game.functions.graph.generators.basis.tri.TriShapeType) => <triShapeType>, pack=game.functions.graph.generators.basis.tri, label=triShapeType, cls=game.functions.graph.generators.basis.tri.TriShapeType, keyword=triShapeType, atomic=TriShapeType, atomic path=game.functions.graph.generators.basis.tri.TriShapeType
~~~~ <triangleOnTri> name=TriangleOnTri type=SubLudeme (game.functions.graph.generators.basis.tri.TriangleOnTri) => <graph>, pack=game.functions.graph.generators.basis.tri, label=triangleOnTri, cls=game.functions.graph.generators.basis.tri.TriangleOnTri, keyword=triangleOnTri, atomic=TriangleOnTri, atomic path=game.functions.graph.generators.basis.tri.TriangleOnTri
gd~~ <rectangle> name=Rectangle type=SuperLudeme (game.functions.graph.generators.shape.Rectangle) => <rectangle>, pack=game.functions.graph.generators.shape, label=rectangle, cls=game.functions.graph.generators.shape.Rectangle, keyword=rectangle, atomic=Rectangle, atomic path=game.functions.graph.generators.shape.Rectangle
gd~~ <regular> name=Regular type=Ludeme (game.functions.graph.generators.shape.Regular) => <graph>, pack=game.functions.graph.generators.shape, label=regular, cls=game.functions.graph.generators.shape.Regular, keyword=regular, atomic=Regular, atomic path=game.functions.graph.generators.shape.Regular
gd~~ <repeat> name=Repeat type=Ludeme (game.functions.graph.generators.shape.Repeat) => <graph>, pack=game.functions.graph.generators.shape, label=repeat, cls=game.functions.graph.generators.shape.Repeat, keyword=repeat, atomic=Repeat, atomic path=game.functions.graph.generators.shape.Repeat
~~~~ <shapeStarType> name=ShapeStarType type=Structural (game.functions.graph.generators.shape.ShapeStarType) => <shapeStarType>, pack=game.functions.graph.generators.shape, label=shapeStarType, cls=game.functions.graph.generators.shape.ShapeStarType, keyword=shapeStarType, atomic=ShapeStarType, atomic path=game.functions.graph.generators.shape.ShapeStarType
gd~~ <spiral> name=Spiral type=Ludeme (game.functions.graph.generators.shape.Spiral) => <graph>, pack=game.functions.graph.generators.shape, label=spiral, cls=game.functions.graph.generators.shape.Spiral, keyword=spiral, atomic=Spiral, atomic path=game.functions.graph.generators.shape.Spiral
gd~~ <wedge> name=Wedge type=Ludeme (game.functions.graph.generators.shape.Wedge) => <graph>, pack=game.functions.graph.generators.shape, label=wedge, cls=game.functions.graph.generators.shape.Wedge, keyword=wedge, atomic=Wedge, atomic path=game.functions.graph.generators.shape.Wedge
gd~~ <concentric> name=Concentric type=SuperLudeme (game.functions.graph.generators.shape.concentric.Concentric) => <graph>, pack=game.functions.graph.generators.shape.concentric, label=concentric, cls=game.functions.graph.generators.shape.concentric.Concentric, keyword=concentric, atomic=Concentric, atomic path=game.functions.graph.generators.shape.concentric.Concentric
~~~~ <concentricCircle> name=ConcentricCircle type=SubLudeme (game.functions.graph.generators.shape.concentric.ConcentricCircle) => <graph>, pack=game.functions.graph.generators.shape.concentric, label=concentricCircle, cls=game.functions.graph.generators.shape.concentric.ConcentricCircle, keyword=concentricCircle, atomic=ConcentricCircle, atomic path=game.functions.graph.generators.shape.concentric.ConcentricCircle
~~~~ <concentricRegular> name=ConcentricRegular type=SubLudeme (game.functions.graph.generators.shape.concentric.ConcentricRegular) => <graph>, pack=game.functions.graph.generators.shape.concentric, label=concentricRegular, cls=game.functions.graph.generators.shape.concentric.ConcentricRegular, keyword=concentricRegular, atomic=ConcentricRegular, atomic path=game.functions.graph.generators.shape.concentric.ConcentricRegular
g~~~ <concentricShapeType> name=ConcentricShapeType type=Structural (game.functions.graph.generators.shape.concentric.ConcentricShapeType) => <concentricShapeType>, pack=game.functions.graph.generators.shape.concentric, label=concentricShapeType, cls=game.functions.graph.generators.shape.concentric.ConcentricShapeType, keyword=concentricShapeType, atomic=ConcentricShapeType, atomic path=game.functions.graph.generators.shape.concentric.ConcentricShapeType
~~~~ <concentricTarget> name=ConcentricTarget type=SubLudeme (game.functions.graph.generators.shape.concentric.ConcentricTarget) => <graph>, pack=game.functions.graph.generators.shape.concentric, label=concentricTarget, cls=game.functions.graph.generators.shape.concentric.ConcentricTarget, keyword=concentricTarget, atomic=ConcentricTarget, atomic path=game.functions.graph.generators.shape.concentric.ConcentricTarget
gd~~ <operators.add> name=Add type=Ludeme (game.functions.graph.operators.Add) => <graph>, pack=game.functions.graph.operators, label=operators.add, cls=game.functions.graph.operators.Add, keyword=add, atomic=Add, atomic path=game.functions.graph.operators.Add
gd~~ <clip> name=Clip type=Ludeme (game.functions.graph.operators.Clip) => <graph>, pack=game.functions.graph.operators, label=clip, cls=game.functions.graph.operators.Clip, keyword=clip, atomic=Clip, atomic path=game.functions.graph.operators.Clip
gd~~ <complete> name=Complete type=Ludeme (game.functions.graph.operators.Complete) => <graph>, pack=game.functions.graph.operators, label=complete, cls=game.functions.graph.operators.Complete, keyword=complete, atomic=Complete, atomic path=game.functions.graph.operators.Complete
gd~~ <dual> name=Dual type=Ludeme (game.functions.graph.operators.Dual) => <graph>, pack=game.functions.graph.operators, label=dual, cls=game.functions.graph.operators.Dual, keyword=dual, atomic=Dual, atomic path=game.functions.graph.operators.Dual
gd~~ <hole> name=Hole type=Ludeme (game.functions.graph.operators.Hole) => <graph>, pack=game.functions.graph.operators, label=hole, cls=game.functions.graph.operators.Hole, keyword=hole, atomic=Hole, atomic path=game.functions.graph.operators.Hole
gd~~ <intersect> name=Intersect type=Ludeme (game.functions.graph.operators.Intersect) => <graph>, pack=game.functions.graph.operators, label=intersect, cls=game.functions.graph.operators.Intersect, keyword=intersect, atomic=Intersect, atomic path=game.functions.graph.operators.Intersect
gd~~ <keep> name=Keep type=Ludeme (game.functions.graph.operators.Keep) => <graph>, pack=game.functions.graph.operators, label=keep, cls=game.functions.graph.operators.Keep, keyword=keep, atomic=Keep, atomic path=game.functions.graph.operators.Keep
gd~~ <layers> name=Layers type=Ludeme (game.functions.graph.operators.Layers) => <graph>, pack=game.functions.graph.operators, label=layers, cls=game.functions.graph.operators.Layers, keyword=layers, atomic=Layers, atomic path=game.functions.graph.operators.Layers
gd~~ <makeFaces> name=MakeFaces type=Ludeme (game.functions.graph.operators.MakeFaces) => <graph>, pack=game.functions.graph.operators, label=makeFaces, cls=game.functions.graph.operators.MakeFaces, keyword=makeFaces, atomic=MakeFaces, atomic path=game.functions.graph.operators.MakeFaces
gd~~ <merge> name=Merge type=Ludeme (game.functions.graph.operators.Merge) => <graph>, pack=game.functions.graph.operators, label=merge, cls=game.functions.graph.operators.Merge, keyword=merge, atomic=Merge, atomic path=game.functions.graph.operators.Merge
gd~~ <recoordinate> name=Recoordinate type=Ludeme (game.functions.graph.operators.Recoordinate) => <graph>, pack=game.functions.graph.operators, label=recoordinate, cls=game.functions.graph.operators.Recoordinate, keyword=recoordinate, atomic=Recoordinate, atomic path=game.functions.graph.operators.Recoordinate
gd~~ <operators.remove> name=Remove type=Ludeme (game.functions.graph.operators.Remove) => <graph>, pack=game.functions.graph.operators, label=operators.remove, cls=game.functions.graph.operators.Remove, keyword=remove, atomic=Remove, atomic path=game.functions.graph.operators.Remove
gd~~ <renumber> name=Renumber type=Ludeme (game.functions.graph.operators.Renumber) => <graph>, pack=game.functions.graph.operators, label=renumber, cls=game.functions.graph.operators.Renumber, keyword=renumber, atomic=Renumber, atomic path=game.functions.graph.operators.Renumber
gd~~ <rotate> name=Rotate type=Ludeme (game.functions.graph.operators.Rotate) => <graph>, pack=game.functions.graph.operators, label=rotate, cls=game.functions.graph.operators.Rotate, keyword=rotate, atomic=Rotate, atomic path=game.functions.graph.operators.Rotate
gd~~ <scale> name=Scale type=Ludeme (game.functions.graph.operators.Scale) => <graph>, pack=game.functions.graph.operators, label=scale, cls=game.functions.graph.operators.Scale, keyword=scale, atomic=Scale, atomic path=game.functions.graph.operators.Scale
gd~~ <shift> name=Shift type=Ludeme (game.functions.graph.operators.Shift) => <graph>, pack=game.functions.graph.operators, label=shift, cls=game.functions.graph.operators.Shift, keyword=shift, atomic=Shift, atomic path=game.functions.graph.operators.Shift
gd~~ <skew> name=Skew type=Ludeme (game.functions.graph.operators.Skew) => <graph>, pack=game.functions.graph.operators, label=skew, cls=game.functions.graph.operators.Skew, keyword=skew, atomic=Skew, atomic path=game.functions.graph.operators.Skew
gd~~ <splitCrossings> name=SplitCrossings type=Ludeme (game.functions.graph.operators.SplitCrossings) => <graph>, pack=game.functions.graph.operators, label=splitCrossings, cls=game.functions.graph.operators.SplitCrossings, keyword=splitCrossings, atomic=SplitCrossings, atomic path=game.functions.graph.operators.SplitCrossings
gd~~ <subdivide> name=Subdivide type=Ludeme (game.functions.graph.operators.Subdivide) => <graph>, pack=game.functions.graph.operators, label=subdivide, cls=game.functions.graph.operators.Subdivide, keyword=subdivide, atomic=Subdivide, atomic path=game.functions.graph.operators.Subdivide
gd~~ <trim> name=Trim type=Ludeme (game.functions.graph.operators.Trim) => <graph>, pack=game.functions.graph.operators, label=trim, cls=game.functions.graph.operators.Trim, keyword=trim, atomic=Trim, atomic path=game.functions.graph.operators.Trim
gd~~ <operators.union> name=Union type=Ludeme (game.functions.graph.operators.Union) => <graph>, pack=game.functions.graph.operators, label=operators.union, cls=game.functions.graph.operators.Union, keyword=union, atomic=Union, atomic path=game.functions.graph.operators.Union
~~~* <baseIntArrayFunction> name=BaseIntArrayFunction type=Ludeme (game.functions.intArray.BaseIntArrayFunction) => <baseIntArrayFunction>, pack=game.functions.intArray, label=baseIntArrayFunction, cls=game.functions.intArray.BaseIntArrayFunction, keyword=baseIntArrayFunction, atomic=BaseIntArrayFunction, atomic path=game.functions.intArray.BaseIntArrayFunction
~~~~ <intArrayConstant> name=IntArrayConstant type=Ludeme (game.functions.intArray.IntArrayConstant) => <int>{<int>}, pack=game.functions.intArray, label=intArrayConstant, cls=game.functions.intArray.IntArrayConstant, keyword=intArrayConstant, atomic=int, atomic path=int
g~~* <ints> name=IntArrayFunction type=Structural (game.functions.intArray.IntArrayFunction) => <int>{<int>}, pack=game.functions.intArray, label=ints, cls=game.functions.intArray.IntArrayFunction, keyword=intArrayFunction, atomic=int, atomic path=int
gd~~ <array> name=Array type=Ludeme (game.functions.intArray.array.Array) => <int>{<int>}, pack=game.functions.intArray.array, label=array, cls=game.functions.intArray.array.Array, keyword=array, atomic=Array, atomic path=game.functions.intArray.array.Array
gd~~ <team> name=Team type=Ludeme (game.functions.intArray.iteraror.Team) => <int>{<int>}, pack=game.functions.intArray.iteraror, label=team, cls=game.functions.intArray.iteraror.Team, keyword=team, atomic=Team, atomic path=game.functions.intArray.iteraror.Team
gd~~ <intArray.math.difference> name=Difference type=Ludeme (game.functions.intArray.math.Difference) => <int>{<int>}, pack=game.functions.intArray.math, label=intArray.math.difference, cls=game.functions.intArray.math.Difference, keyword=difference, atomic=Difference, atomic path=game.functions.intArray.math.Difference
gd~~ <intArray.math.if> name=If type=Ludeme (game.functions.intArray.math.If) => <int>{<int>}, pack=game.functions.intArray.math, label=intArray.math.if, cls=game.functions.intArray.math.If, keyword=if, atomic=If, atomic path=game.functions.intArray.math.If
gd~~ <intArray.math.intersection> name=Intersection type=Ludeme (game.functions.intArray.math.Intersection) => <int>{<int>}, pack=game.functions.intArray.math, label=intArray.math.intersection, cls=game.functions.intArray.math.Intersection, keyword=intersection, atomic=Intersection, atomic path=game.functions.intArray.math.Intersection
gd~~ <results> name=Results type=Ludeme (game.functions.intArray.math.Results) => <int>{<int>}, pack=game.functions.intArray.math, label=results, cls=game.functions.intArray.math.Results, keyword=results, atomic=Results, atomic path=game.functions.intArray.math.Results
gd~~ <intArray.math.union> name=Union type=Ludeme (game.functions.intArray.math.Union) => <int>{<int>}, pack=game.functions.intArray.math, label=intArray.math.union, cls=game.functions.intArray.math.Union, keyword=union, atomic=Union, atomic path=game.functions.intArray.math.Union
gd~~ <intArray.players.players> name=Players type=SuperLudeme (game.functions.intArray.players.Players) => <int>{<int>}, pack=game.functions.intArray.players, label=intArray.players.players, cls=game.functions.intArray.players.Players, keyword=players, atomic=Players, atomic path=game.functions.intArray.players.Players
g~~~ <playersManyType> name=PlayersManyType type=Structural (game.functions.intArray.players.PlayersManyType) => <playersManyType>, pack=game.functions.intArray.players, label=playersManyType, cls=game.functions.intArray.players.PlayersManyType, keyword=playersManyType, atomic=PlayersManyType, atomic path=game.functions.intArray.players.PlayersManyType
g~~~ <playersTeamType> name=PlayersTeamType type=Structural (game.functions.intArray.players.PlayersTeamType) => <playersTeamType>, pack=game.functions.intArray.players, label=playersTeamType, cls=game.functions.intArray.players.PlayersTeamType, keyword=playersTeamType, atomic=PlayersTeamType, atomic path=game.functions.intArray.players.PlayersTeamType
~~~~ <playersMany> name=PlayersMany type=SubLudeme (game.functions.intArray.players.many.PlayersMany) => <int>{<int>}, pack=game.functions.intArray.players.many, label=playersMany, cls=game.functions.intArray.players.many.PlayersMany, keyword=playersMany, atomic=PlayersMany, atomic path=game.functions.intArray.players.many.PlayersMany
~~~~ <playersTeam> name=PlayersTeam type=SubLudeme (game.functions.intArray.players.team.PlayersTeam) => <int>{<int>}, pack=game.functions.intArray.players.team, label=playersTeam, cls=game.functions.intArray.players.team.PlayersTeam, keyword=playersTeam, atomic=PlayersTeam, atomic path=game.functions.intArray.players.team.PlayersTeam
gd~~ <sizes> name=Sizes type=SuperLudeme (game.functions.intArray.sizes.Sizes) => <int>{<int>}, pack=game.functions.intArray.sizes, label=sizes, cls=game.functions.intArray.sizes.Sizes, keyword=sizes, atomic=Sizes, atomic path=game.functions.intArray.sizes.Sizes
~~~~ <sizesGroupType> name=SizesGroupType type=Structural (game.functions.intArray.sizes.SizesGroupType) => <sizesGroupType>, pack=game.functions.intArray.sizes, label=sizesGroupType, cls=game.functions.intArray.sizes.SizesGroupType, keyword=sizesGroupType, atomic=SizesGroupType, atomic path=game.functions.intArray.sizes.SizesGroupType
~~~~ <sizesGroup> name=SizesGroup type=SubLudeme (game.functions.intArray.sizes.group.SizesGroup) => <int>{<int>}, pack=game.functions.intArray.sizes.group, label=sizesGroup, cls=game.functions.intArray.sizes.group.SizesGroup, keyword=sizesGroup, atomic=SizesGroup, atomic path=game.functions.intArray.sizes.group.SizesGroup
gd~~ <rotations> name=Rotations type=Ludeme (game.functions.intArray.state.Rotations) => <int>{<int>}, pack=game.functions.intArray.state, label=rotations, cls=game.functions.intArray.state.Rotations, keyword=rotations, atomic=Rotations, atomic path=game.functions.intArray.state.Rotations
gd~~ <values.values> name=Values type=SuperLudeme (game.functions.intArray.values.Values) => <int>{<int>}, pack=game.functions.intArray.values, label=values.values, cls=game.functions.intArray.values.Values, keyword=values, atomic=Values, atomic path=game.functions.intArray.values.Values
~~~~ <valuesRemembered> name=ValuesRemembered type=SubLudeme (game.functions.intArray.values.ValuesRemembered) => <int>{<int>}, pack=game.functions.intArray.values, label=valuesRemembered, cls=game.functions.intArray.values.ValuesRemembered, keyword=valuesRemembered, atomic=ValuesRemembered, atomic path=game.functions.intArray.values.ValuesRemembered
~~~~ <valuesStringType> name=ValuesStringType type=Structural (game.functions.intArray.values.ValuesStringType) => <valuesStringType>, pack=game.functions.intArray.values, label=valuesStringType, cls=game.functions.intArray.values.ValuesStringType, keyword=valuesStringType, atomic=ValuesStringType, atomic path=game.functions.intArray.values.ValuesStringType
~~~* <baseIntFunction> name=BaseIntFunction type=Ludeme (game.functions.ints.BaseIntFunction) => <baseIntFunction>, pack=game.functions.ints, label=baseIntFunction, cls=game.functions.ints.BaseIntFunction, keyword=baseIntFunction, atomic=BaseIntFunction, atomic path=game.functions.ints.BaseIntFunction
~~~~ <intConstant> name=IntConstant type=Ludeme (game.functions.ints.IntConstant) => <int>, pack=game.functions.ints, label=intConstant, cls=game.functions.ints.IntConstant, keyword=intConstant, atomic=int, atomic path=int
g~m* <int> name=IntFunction type=Structural (game.functions.ints.IntFunction) => <int>, pack=game.functions.ints, label=int, cls=game.functions.ints.IntFunction, keyword=intFunction, atomic=int, atomic path=int
gd~~ <toInt> name=ToInt type=Ludeme (game.functions.ints.ToInt) => <int>, pack=game.functions.ints, label=toInt, cls=game.functions.ints.ToInt, keyword=toInt, atomic=ToInt, atomic path=game.functions.ints.ToInt
gd~~ <ahead> name=Ahead type=Ludeme (game.functions.ints.board.Ahead) => <int>, pack=game.functions.ints.board, label=ahead, cls=game.functions.ints.board.Ahead, keyword=ahead, atomic=Ahead, atomic path=game.functions.ints.board.Ahead
gd~~ <arrayValue> name=ArrayValue type=Ludeme (game.functions.ints.board.ArrayValue) => <int>, pack=game.functions.ints.board, label=arrayValue, cls=game.functions.ints.board.ArrayValue, keyword=arrayValue, atomic=ArrayValue, atomic path=game.functions.ints.board.ArrayValue
gd~~ <centrePoint> name=CentrePoint type=Ludeme (game.functions.ints.board.CentrePoint) => <int>, pack=game.functions.ints.board, label=centrePoint, cls=game.functions.ints.board.CentrePoint, keyword=centrePoint, atomic=CentrePoint, atomic path=game.functions.ints.board.CentrePoint
gd~~ <column> name=Column type=Ludeme (game.functions.ints.board.Column) => <int>, pack=game.functions.ints.board, label=column, cls=game.functions.ints.board.Column, keyword=column, atomic=Column, atomic path=game.functions.ints.board.Column
gd~~ <coord> name=Coord type=Ludeme (game.functions.ints.board.Coord) => <int>, pack=game.functions.ints.board, label=coord, cls=game.functions.ints.board.Coord, keyword=coord, atomic=Coord, atomic path=game.functions.ints.board.Coord
gd~~ <cost> name=Cost type=Ludeme (game.functions.ints.board.Cost) => <int>, pack=game.functions.ints.board, label=cost, cls=game.functions.ints.board.Cost, keyword=cost, atomic=Cost, atomic path=game.functions.ints.board.Cost
gd~~ <handSite> name=HandSite type=Ludeme (game.functions.ints.board.HandSite) => <int>, pack=game.functions.ints.board, label=handSite, cls=game.functions.ints.board.HandSite, keyword=handSite, atomic=HandSite, atomic path=game.functions.ints.board.HandSite
gd~~ <board.id> name=Id type=Ludeme (game.functions.ints.board.Id) => <int>, pack=game.functions.ints.board, label=board.id, cls=game.functions.ints.board.Id, keyword=id, atomic=Id, atomic path=game.functions.ints.board.Id
gd~~ <layer> name=Layer type=Ludeme (game.functions.ints.board.Layer) => <int>, pack=game.functions.ints.board, label=layer, cls=game.functions.ints.board.Layer, keyword=layer, atomic=Layer, atomic path=game.functions.ints.board.Layer
gd~~ <mapEntry> name=MapEntry type=Ludeme (game.functions.ints.board.MapEntry) => <int>, pack=game.functions.ints.board, label=mapEntry, cls=game.functions.ints.board.MapEntry, keyword=mapEntry, atomic=MapEntry, atomic path=game.functions.ints.board.MapEntry
gd~~ <board.phase> name=Phase type=Ludeme (game.functions.ints.board.Phase) => <int>, pack=game.functions.ints.board, label=board.phase, cls=game.functions.ints.board.Phase, keyword=phase, atomic=Phase, atomic path=game.functions.ints.board.Phase
gd~~ <regionSite> name=RegionSite type=Ludeme (game.functions.ints.board.RegionSite) => <int>, pack=game.functions.ints.board, label=regionSite, cls=game.functions.ints.board.RegionSite, keyword=regionSite, atomic=RegionSite, atomic path=game.functions.ints.board.RegionSite
gd~~ <row> name=Row type=Ludeme (game.functions.ints.board.Row) => <int>, pack=game.functions.ints.board, label=row, cls=game.functions.ints.board.Row, keyword=row, atomic=Row, atomic path=game.functions.ints.board.Row
gd~~ <where> name=Where type=SuperLudeme (game.functions.ints.board.where.Where) => <int>, pack=game.functions.ints.board.where, label=where, cls=game.functions.ints.board.where.Where, keyword=where, atomic=Where, atomic path=game.functions.ints.board.where.Where
~~~~ <whereLevel> name=WhereLevel type=SubLudeme (game.functions.ints.board.where.WhereLevel) => <int>, pack=game.functions.ints.board.where, label=whereLevel, cls=game.functions.ints.board.where.WhereLevel, keyword=whereLevel, atomic=WhereLevel, atomic path=game.functions.ints.board.where.WhereLevel
~~~~ <whereLevelType> name=WhereLevelType type=Structural (game.functions.ints.board.where.WhereLevelType) => <whereLevelType>, pack=game.functions.ints.board.where, label=whereLevelType, cls=game.functions.ints.board.where.WhereLevelType, keyword=whereLevelType, atomic=WhereLevelType, atomic path=game.functions.ints.board.where.WhereLevelType
~~~~ <whereSite> name=WhereSite type=SubLudeme (game.functions.ints.board.where.WhereSite) => <int>, pack=game.functions.ints.board.where, label=whereSite, cls=game.functions.ints.board.where.WhereSite, keyword=whereSite, atomic=WhereSite, atomic path=game.functions.ints.board.where.WhereSite
gd~~ <card.card> name=Card type=SuperLudeme (game.functions.ints.card.Card) => <int>, pack=game.functions.ints.card, label=card.card, cls=game.functions.ints.card.Card, keyword=card, atomic=Card, atomic path=game.functions.ints.card.Card
~~~~ <cardSimpleType> name=CardSimpleType type=Structural (game.functions.ints.card.CardSimpleType) => <cardSimpleType>, pack=game.functions.ints.card, label=cardSimpleType, cls=game.functions.ints.card.CardSimpleType, keyword=cardSimpleType, atomic=CardSimpleType, atomic path=game.functions.ints.card.CardSimpleType
g~~~ <cardSiteType> name=CardSiteType type=Structural (game.functions.ints.card.CardSiteType) => <cardSiteType>, pack=game.functions.ints.card, label=cardSiteType, cls=game.functions.ints.card.CardSiteType, keyword=cardSiteType, atomic=CardSiteType, atomic path=game.functions.ints.card.CardSiteType
~~~~ <cardTrumpSuit> name=CardTrumpSuit type=SubLudeme (game.functions.ints.card.simple.CardTrumpSuit) => <int>, pack=game.functions.ints.card.simple, label=cardTrumpSuit, cls=game.functions.ints.card.simple.CardTrumpSuit, keyword=cardTrumpSuit, atomic=CardTrumpSuit, atomic path=game.functions.ints.card.simple.CardTrumpSuit
~~~~ <cardRank> name=CardRank type=SubLudeme (game.functions.ints.card.site.CardRank) => <int>, pack=game.functions.ints.card.site, label=cardRank, cls=game.functions.ints.card.site.CardRank, keyword=cardRank, atomic=CardRank, atomic path=game.functions.ints.card.site.CardRank
~~~~ <cardSuit> name=CardSuit type=SubLudeme (game.functions.ints.card.site.CardSuit) => <int>, pack=game.functions.ints.card.site, label=cardSuit, cls=game.functions.ints.card.site.CardSuit, keyword=cardSuit, atomic=CardSuit, atomic path=game.functions.ints.card.site.CardSuit
~~~~ <cardTrumpRank> name=CardTrumpRank type=SubLudeme (game.functions.ints.card.site.CardTrumpRank) => <int>, pack=game.functions.ints.card.site, label=cardTrumpRank, cls=game.functions.ints.card.site.CardTrumpRank, keyword=cardTrumpRank, atomic=CardTrumpRank, atomic path=game.functions.ints.card.site.CardTrumpRank
~~~~ <cardTrumpValue> name=CardTrumpValue type=SubLudeme (game.functions.ints.card.site.CardTrumpValue) => <int>, pack=game.functions.ints.card.site, label=cardTrumpValue, cls=game.functions.ints.card.site.CardTrumpValue, keyword=cardTrumpValue, atomic=CardTrumpValue, atomic path=game.functions.ints.card.site.CardTrumpValue
gd~~ <count.count> name=Count type=SuperLudeme (game.functions.ints.count.Count) => <int>, pack=game.functions.ints.count, label=count.count, cls=game.functions.ints.count.Count, keyword=count, atomic=Count, atomic path=game.functions.ints.count.Count
g~~~ <countComponentType> name=CountComponentType type=Structural (game.functions.ints.count.CountComponentType) => <countComponentType>, pack=game.functions.ints.count, label=countComponentType, cls=game.functions.ints.count.CountComponentType, keyword=countComponentType, atomic=CountComponentType, atomic path=game.functions.ints.count.CountComponentType
~~~~ <countGroupsType> name=CountGroupsType type=Structural (game.functions.ints.count.CountGroupsType) => <countGroupsType>, pack=game.functions.ints.count, label=countGroupsType, cls=game.functions.ints.count.CountGroupsType, keyword=countGroupsType, atomic=CountGroupsType, atomic path=game.functions.ints.count.CountGroupsType
~~~~ <countLibertiesType> name=CountLibertiesType type=Structural (game.functions.ints.count.CountLibertiesType) => <countLibertiesType>, pack=game.functions.ints.count, label=countLibertiesType, cls=game.functions.ints.count.CountLibertiesType, keyword=countLibertiesType, atomic=CountLibertiesType, atomic path=game.functions.ints.count.CountLibertiesType
g~~~ <countSimpleType> name=CountSimpleType type=Structural (game.functions.ints.count.CountSimpleType) => <countSimpleType>, pack=game.functions.ints.count, label=countSimpleType, cls=game.functions.ints.count.CountSimpleType, keyword=countSimpleType, atomic=CountSimpleType, atomic path=game.functions.ints.count.CountSimpleType
g~~~ <countSiteType> name=CountSiteType type=Structural (game.functions.ints.count.CountSiteType) => <countSiteType>, pack=game.functions.ints.count, label=countSiteType, cls=game.functions.ints.count.CountSiteType, keyword=countSiteType, atomic=CountSiteType, atomic path=game.functions.ints.count.CountSiteType
~~~~ <countStackType> name=CountStackType type=Structural (game.functions.ints.count.CountStackType) => <countStackType>, pack=game.functions.ints.count, label=countStackType, cls=game.functions.ints.count.CountStackType, keyword=countStackType, atomic=CountStackType, atomic path=game.functions.ints.count.CountStackType
~~~~ <countStepsOnTrackType> name=CountStepsOnTrackType type=Structural (game.functions.ints.count.CountStepsOnTrackType) => <countStepsOnTrackType>, pack=game.functions.ints.count, label=countStepsOnTrackType, cls=game.functions.ints.count.CountStepsOnTrackType, keyword=countStepsOnTrackType, atomic=CountStepsOnTrackType, atomic path=game.functions.ints.count.CountStepsOnTrackType
~~~~ <countStepsType> name=CountStepsType type=Structural (game.functions.ints.count.CountStepsType) => <countStepsType>, pack=game.functions.ints.count, label=countStepsType, cls=game.functions.ints.count.CountStepsType, keyword=countStepsType, atomic=CountStepsType, atomic path=game.functions.ints.count.CountStepsType
~~~~ <countValueType> name=CountValueType type=Structural (game.functions.ints.count.CountValueType) => <countValueType>, pack=game.functions.ints.count, label=countValueType, cls=game.functions.ints.count.CountValueType, keyword=countValueType, atomic=CountValueType, atomic path=game.functions.ints.count.CountValueType
~~~~ <countPieces> name=CountPieces type=SubLudeme (game.functions.ints.count.component.CountPieces) => <int>, pack=game.functions.ints.count.component, label=countPieces, cls=game.functions.ints.count.component.CountPieces, keyword=countPieces, atomic=CountPieces, atomic path=game.functions.ints.count.component.CountPieces
~~~~ <countPips> name=CountPips type=SubLudeme (game.functions.ints.count.component.CountPips) => <int>, pack=game.functions.ints.count.component, label=countPips, cls=game.functions.ints.count.component.CountPips, keyword=countPips, atomic=CountPips, atomic path=game.functions.ints.count.component.CountPips
~~~~ <countGroups> name=CountGroups type=SubLudeme (game.functions.ints.count.groups.CountGroups) => <int>, pack=game.functions.ints.count.groups, label=countGroups, cls=game.functions.ints.count.groups.CountGroups, keyword=countGroups, atomic=CountGroups, atomic path=game.functions.ints.count.groups.CountGroups
~~~~ <countLiberties> name=CountLiberties type=SubLudeme (game.functions.ints.count.liberties.CountLiberties) => <int>, pack=game.functions.ints.count.liberties, label=countLiberties, cls=game.functions.ints.count.liberties.CountLiberties, keyword=countLiberties, atomic=CountLiberties, atomic path=game.functions.ints.count.liberties.CountLiberties
~~~~ <countActive> name=CountActive type=SubLudeme (game.functions.ints.count.simple.CountActive) => <int>, pack=game.functions.ints.count.simple, label=countActive, cls=game.functions.ints.count.simple.CountActive, keyword=countActive, atomic=CountActive, atomic path=game.functions.ints.count.simple.CountActive
~~~~ <countCells> name=CountCells type=SubLudeme (game.functions.ints.count.simple.CountCells) => <int>, pack=game.functions.ints.count.simple, label=countCells, cls=game.functions.ints.count.simple.CountCells, keyword=countCells, atomic=CountCells, atomic path=game.functions.ints.count.simple.CountCells
~~~~ <countColumns> name=CountColumns type=SubLudeme (game.functions.ints.count.simple.CountColumns) => <int>, pack=game.functions.ints.count.simple, label=countColumns, cls=game.functions.ints.count.simple.CountColumns, keyword=countColumns, atomic=CountColumns, atomic path=game.functions.ints.count.simple.CountColumns
~~~~ <countEdges> name=CountEdges type=SubLudeme (game.functions.ints.count.simple.CountEdges) => <int>, pack=game.functions.ints.count.simple, label=countEdges, cls=game.functions.ints.count.simple.CountEdges, keyword=countEdges, atomic=CountEdges, atomic path=game.functions.ints.count.simple.CountEdges
~~~~ <countLegalMoves> name=CountLegalMoves type=SubLudeme (game.functions.ints.count.simple.CountLegalMoves) => <int>, pack=game.functions.ints.count.simple, label=countLegalMoves, cls=game.functions.ints.count.simple.CountLegalMoves, keyword=countLegalMoves, atomic=CountLegalMoves, atomic path=game.functions.ints.count.simple.CountLegalMoves
~~~~ <countMoves> name=CountMoves type=SubLudeme (game.functions.ints.count.simple.CountMoves) => <int>, pack=game.functions.ints.count.simple, label=countMoves, cls=game.functions.ints.count.simple.CountMoves, keyword=countMoves, atomic=CountMoves, atomic path=game.functions.ints.count.simple.CountMoves
~~~~ <countMovesThisTurn> name=CountMovesThisTurn type=SubLudeme (game.functions.ints.count.simple.CountMovesThisTurn) => <int>, pack=game.functions.ints.count.simple, label=countMovesThisTurn, cls=game.functions.ints.count.simple.CountMovesThisTurn, keyword=countMovesThisTurn, atomic=CountMovesThisTurn, atomic path=game.functions.ints.count.simple.CountMovesThisTurn
~~~~ <countPhases> name=CountPhases type=SubLudeme (game.functions.ints.count.simple.CountPhases) => <int>, pack=game.functions.ints.count.simple, label=countPhases, cls=game.functions.ints.count.simple.CountPhases, keyword=countPhases, atomic=CountPhases, atomic path=game.functions.ints.count.simple.CountPhases
~~~~ <countPlayers> name=CountPlayers type=SubLudeme (game.functions.ints.count.simple.CountPlayers) => <int>, pack=game.functions.ints.count.simple, label=countPlayers, cls=game.functions.ints.count.simple.CountPlayers, keyword=countPlayers, atomic=CountPlayers, atomic path=game.functions.ints.count.simple.CountPlayers
~~~~ <countRows> name=CountRows type=SubLudeme (game.functions.ints.count.simple.CountRows) => <int>, pack=game.functions.ints.count.simple, label=countRows, cls=game.functions.ints.count.simple.CountRows, keyword=countRows, atomic=CountRows, atomic path=game.functions.ints.count.simple.CountRows
~~~~ <countTrials> name=CountTrials type=SubLudeme (game.functions.ints.count.simple.CountTrials) => <int>, pack=game.functions.ints.count.simple, label=countTrials, cls=game.functions.ints.count.simple.CountTrials, keyword=countTrials, atomic=CountTrials, atomic path=game.functions.ints.count.simple.CountTrials
~~~~ <countTurns> name=CountTurns type=SubLudeme (game.functions.ints.count.simple.CountTurns) => <int>, pack=game.functions.ints.count.simple, label=countTurns, cls=game.functions.ints.count.simple.CountTurns, keyword=countTurns, atomic=CountTurns, atomic path=game.functions.ints.count.simple.CountTurns
~~~~ <countVertices> name=CountVertices type=SubLudeme (game.functions.ints.count.simple.CountVertices) => <int>, pack=game.functions.ints.count.simple, label=countVertices, cls=game.functions.ints.count.simple.CountVertices, keyword=countVertices, atomic=CountVertices, atomic path=game.functions.ints.count.simple.CountVertices
~~~~ <countAdjacent> name=CountAdjacent type=SubLudeme (game.functions.ints.count.site.CountAdjacent) => <int>, pack=game.functions.ints.count.site, label=countAdjacent, cls=game.functions.ints.count.site.CountAdjacent, keyword=countAdjacent, atomic=CountAdjacent, atomic path=game.functions.ints.count.site.CountAdjacent
~~~~ <countDiagonal> name=CountDiagonal type=SubLudeme (game.functions.ints.count.site.CountDiagonal) => <int>, pack=game.functions.ints.count.site, label=countDiagonal, cls=game.functions.ints.count.site.CountDiagonal, keyword=countDiagonal, atomic=CountDiagonal, atomic path=game.functions.ints.count.site.CountDiagonal
~~~~ <countNeighbours> name=CountNeighbours type=SubLudeme (game.functions.ints.count.site.CountNeighbours) => <int>, pack=game.functions.ints.count.site, label=countNeighbours, cls=game.functions.ints.count.site.CountNeighbours, keyword=countNeighbours, atomic=CountNeighbours, atomic path=game.functions.ints.count.site.CountNeighbours
~~~~ <countNumber> name=CountNumber type=SubLudeme (game.functions.ints.count.site.CountNumber) => <int>, pack=game.functions.ints.count.site, label=countNumber, cls=game.functions.ints.count.site.CountNumber, keyword=countNumber, atomic=CountNumber, atomic path=game.functions.ints.count.site.CountNumber
~~~~ <countOff> name=CountOff type=SubLudeme (game.functions.ints.count.site.CountOff) => <int>, pack=game.functions.ints.count.site, label=countOff, cls=game.functions.ints.count.site.CountOff, keyword=countOff, atomic=CountOff, atomic path=game.functions.ints.count.site.CountOff
~~~~ <countOrthogonal> name=CountOrthogonal type=SubLudeme (game.functions.ints.count.site.CountOrthogonal) => <int>, pack=game.functions.ints.count.site, label=countOrthogonal, cls=game.functions.ints.count.site.CountOrthogonal, keyword=countOrthogonal, atomic=CountOrthogonal, atomic path=game.functions.ints.count.site.CountOrthogonal
~~~~ <countSites> name=CountSites type=SubLudeme (game.functions.ints.count.site.CountSites) => <int>, pack=game.functions.ints.count.site, label=countSites, cls=game.functions.ints.count.site.CountSites, keyword=countSites, atomic=CountSites, atomic path=game.functions.ints.count.site.CountSites
~~~~ <countStack> name=CountStack type=SubLudeme (game.functions.ints.count.stack.CountStack) => <int>, pack=game.functions.ints.count.stack, label=countStack, cls=game.functions.ints.count.stack.CountStack, keyword=countStack, atomic=CountStack, atomic path=game.functions.ints.count.stack.CountStack
~~~~ <countStepsOnTrack> name=CountStepsOnTrack type=SubLudeme (game.functions.ints.count.stepsOnTrack.CountStepsOnTrack) => <int>, pack=game.functions.ints.count.stepsOnTrack, label=countStepsOnTrack, cls=game.functions.ints.count.stepsOnTrack.CountStepsOnTrack, keyword=countStepsOnTrack, atomic=CountStepsOnTrack, atomic path=game.functions.ints.count.stepsOnTrack.CountStepsOnTrack
~~~~ <countSteps> name=CountSteps type=SubLudeme (game.functions.ints.count.steps.CountSteps) => <int>, pack=game.functions.ints.count.steps, label=countSteps, cls=game.functions.ints.count.steps.CountSteps, keyword=countSteps, atomic=CountSteps, atomic path=game.functions.ints.count.steps.CountSteps
~~~~ <countValue> name=CountValue type=SubLudeme (game.functions.ints.count.value.CountValue) => <int>, pack=game.functions.ints.count.value, label=countValue, cls=game.functions.ints.count.value.CountValue, keyword=countValue, atomic=CountValue, atomic path=game.functions.ints.count.value.CountValue
gd~~ <dice.face> name=Face type=Ludeme (game.functions.ints.dice.Face) => <int>, pack=game.functions.ints.dice, label=dice.face, cls=game.functions.ints.dice.Face, keyword=face, atomic=Face, atomic path=game.functions.ints.dice.Face
gd~~ <iterator.between> name=Between type=SuperLudeme (game.functions.ints.iterator.Between) => <int>, pack=game.functions.ints.iterator, label=iterator.between, cls=game.functions.ints.iterator.Between, keyword=between, atomic=Between, atomic path=game.functions.ints.iterator.Between
gd~~ <iterator.edge> name=Edge type=Ludeme (game.functions.ints.iterator.Edge) => <int>, pack=game.functions.ints.iterator, label=iterator.edge, cls=game.functions.ints.iterator.Edge, keyword=edge, atomic=Edge, atomic path=game.functions.ints.iterator.Edge
gd~~ <iterator.from> name=From type=Ludeme (game.functions.ints.iterator.From) => <int>, pack=game.functions.ints.iterator, label=iterator.from, cls=game.functions.ints.iterator.From, keyword=from, atomic=From, atomic path=game.functions.ints.iterator.From
gd~~ <iterator.hint> name=Hint type=Ludeme (game.functions.ints.iterator.Hint) => <int>, pack=game.functions.ints.iterator, label=iterator.hint, cls=game.functions.ints.iterator.Hint, keyword=hint, atomic=Hint, atomic path=game.functions.ints.iterator.Hint
gd~~ <level> name=Level type=Ludeme (game.functions.ints.iterator.Level) => <int>, pack=game.functions.ints.iterator, label=level, cls=game.functions.ints.iterator.Level, keyword=level, atomic=Level, atomic path=game.functions.ints.iterator.Level
gd~~ <pips> name=Pips type=SuperLudeme (game.functions.ints.iterator.Pips) => <int>, pack=game.functions.ints.iterator, label=pips, cls=game.functions.ints.iterator.Pips, keyword=pips, atomic=Pips, atomic path=game.functions.ints.iterator.Pips
gd~~ <iterator.player> name=Player type=Ludeme (game.functions.ints.iterator.Player) => <int>, pack=game.functions.ints.iterator, label=iterator.player, cls=game.functions.ints.iterator.Player, keyword=player, atomic=Player, atomic path=game.functions.ints.iterator.Player
gd~~ <site> name=Site type=Ludeme (game.functions.ints.iterator.Site) => <int>, pack=game.functions.ints.iterator, label=site, cls=game.functions.ints.iterator.Site, keyword=site, atomic=Site, atomic path=game.functions.ints.iterator.Site
gd~~ <iterator.to> name=To type=SuperLudeme (game.functions.ints.iterator.To) => <int>, pack=game.functions.ints.iterator, label=iterator.to, cls=game.functions.ints.iterator.To, keyword=to, atomic=To, atomic path=game.functions.ints.iterator.To
gd~~ <iterator.track> name=Track type=Ludeme (game.functions.ints.iterator.Track) => <int>, pack=game.functions.ints.iterator, label=iterator.track, cls=game.functions.ints.iterator.Track, keyword=track, atomic=Track, atomic path=game.functions.ints.iterator.Track
gd~~ <ints.last.last> name=Last type=SuperLudeme (game.functions.ints.last.Last) => <int>, pack=game.functions.ints.last, label=ints.last.last, cls=game.functions.ints.last.Last, keyword=last, atomic=Last, atomic path=game.functions.ints.last.Last
~~~~ <lastFrom> name=LastFrom type=SubLudeme (game.functions.ints.last.LastFrom) => <int>, pack=game.functions.ints.last, label=lastFrom, cls=game.functions.ints.last.LastFrom, keyword=lastFrom, atomic=LastFrom, atomic path=game.functions.ints.last.LastFrom
~~~~ <lastLevelFrom> name=LastLevelFrom type=SubLudeme (game.functions.ints.last.LastLevelFrom) => <int>, pack=game.functions.ints.last, label=lastLevelFrom, cls=game.functions.ints.last.LastLevelFrom, keyword=lastLevelFrom, atomic=LastLevelFrom, atomic path=game.functions.ints.last.LastLevelFrom
~~~~ <lastLevelTo> name=LastLevelTo type=SubLudeme (game.functions.ints.last.LastLevelTo) => <int>, pack=game.functions.ints.last, label=lastLevelTo, cls=game.functions.ints.last.LastLevelTo, keyword=lastLevelTo, atomic=LastLevelTo, atomic path=game.functions.ints.last.LastLevelTo
~~~~ <lastTo> name=LastTo type=SubLudeme (game.functions.ints.last.LastTo) => <int>, pack=game.functions.ints.last, label=lastTo, cls=game.functions.ints.last.LastTo, keyword=lastTo, atomic=LastTo, atomic path=game.functions.ints.last.LastTo
g~~~ <lastType> name=LastType type=Structural (game.functions.ints.last.LastType) => <lastType>, pack=game.functions.ints.last, label=lastType, cls=game.functions.ints.last.LastType, keyword=lastType, atomic=LastType, atomic path=game.functions.ints.last.LastType
gd~~ <matchScore> name=MatchScore type=Ludeme (game.functions.ints.match.MatchScore) => <int>, pack=game.functions.ints.match, label=matchScore, cls=game.functions.ints.match.MatchScore, keyword=matchScore, atomic=MatchScore, atomic path=game.functions.ints.match.MatchScore
gd~~ <ints.math.abs> name=Abs type=Ludeme (game.functions.ints.math.Abs) => <int>, pack=game.functions.ints.math, label=ints.math.abs, cls=game.functions.ints.math.Abs, keyword=abs, atomic=Abs, atomic path=game.functions.ints.math.Abs
gd~~ <ints.math.+> name=Add type=Ludeme (game.functions.ints.math.Add) => <int>, pack=game.functions.ints.math, label=ints.math.+, cls=game.functions.ints.math.Add, keyword=+, atomic=Add, atomic path=game.functions.ints.math.Add
gd~~ <ints.math./> name=Div type=Ludeme (game.functions.ints.math.Div) => <int>, pack=game.functions.ints.math, label=ints.math./, cls=game.functions.ints.math.Div, keyword=/, atomic=Div, atomic path=game.functions.ints.math.Div
gd~~ <ints.math.if> name=If type=Ludeme (game.functions.ints.math.If) => <int>, pack=game.functions.ints.math, label=ints.math.if, cls=game.functions.ints.math.If, keyword=if, atomic=If, atomic path=game.functions.ints.math.If
gd~~ <ints.math.max> name=Max type=Ludeme (game.functions.ints.math.Max) => <int>, pack=game.functions.ints.math, label=ints.math.max, cls=game.functions.ints.math.Max, keyword=max, atomic=Max, atomic path=game.functions.ints.math.Max
gd~~ <ints.math.min> name=Min type=Ludeme (game.functions.ints.math.Min) => <int>, pack=game.functions.ints.math, label=ints.math.min, cls=game.functions.ints.math.Min, keyword=min, atomic=Min, atomic path=game.functions.ints.math.Min
gd~~ <%> name=Mod type=Ludeme (game.functions.ints.math.Mod) => <int>, pack=game.functions.ints.math, label=%, cls=game.functions.ints.math.Mod, keyword=%, atomic=Mod, atomic path=game.functions.ints.math.Mod
gd~~ <ints.math.*> name=Mul type=Ludeme (game.functions.ints.math.Mul) => <int>, pack=game.functions.ints.math, label=ints.math.*, cls=game.functions.ints.math.Mul, keyword=*, atomic=Mul, atomic path=game.functions.ints.math.Mul
gd~~ <ints.math.^> name=Pow type=Ludeme (game.functions.ints.math.Pow) => <int>, pack=game.functions.ints.math, label=ints.math.^, cls=game.functions.ints.math.Pow, keyword=^, atomic=Pow, atomic path=game.functions.ints.math.Pow
gd~~ <ints.math.-> name=Sub type=Ludeme (game.functions.ints.math.Sub) => <int>, pack=game.functions.ints.math, label=ints.math.-, cls=game.functions.ints.math.Sub, keyword=-, atomic=Sub, atomic path=game.functions.ints.math.Sub
gd~~ <size> name=Size type=SuperLudeme (game.functions.ints.size.Size) => <int>, pack=game.functions.ints.size, label=size, cls=game.functions.ints.size.Size, keyword=size, atomic=Size, atomic path=game.functions.ints.size.Size
~~~~ <sizeArrayType> name=SizeArrayType type=Structural (game.functions.ints.size.SizeArrayType) => <sizeArrayType>, pack=game.functions.ints.size, label=sizeArrayType, cls=game.functions.ints.size.SizeArrayType, keyword=sizeArrayType, atomic=SizeArrayType, atomic path=game.functions.ints.size.SizeArrayType
~~~~ <sizeGroupType> name=SizeGroupType type=Structural (game.functions.ints.size.SizeGroupType) => <sizeGroupType>, pack=game.functions.ints.size, label=sizeGroupType, cls=game.functions.ints.size.SizeGroupType, keyword=sizeGroupType, atomic=SizeGroupType, atomic path=game.functions.ints.size.SizeGroupType
~~~~ <sizeLargePieceType> name=SizeLargePieceType type=Structural (game.functions.ints.size.SizeLargePieceType) => <sizeLargePieceType>, pack=game.functions.ints.size, label=sizeLargePieceType, cls=game.functions.ints.size.SizeLargePieceType, keyword=sizeLargePieceType, atomic=SizeLargePieceType, atomic path=game.functions.ints.size.SizeLargePieceType
~~~~ <sizeSiteType> name=SizeSiteType type=Structural (game.functions.ints.size.SizeSiteType) => <sizeSiteType>, pack=game.functions.ints.size, label=sizeSiteType, cls=game.functions.ints.size.SizeSiteType, keyword=sizeSiteType, atomic=SizeSiteType, atomic path=game.functions.ints.size.SizeSiteType
~~~~ <sizeTerritoryType> name=SizeTerritoryType type=Structural (game.functions.ints.size.SizeTerritoryType) => <sizeTerritoryType>, pack=game.functions.ints.size, label=sizeTerritoryType, cls=game.functions.ints.size.SizeTerritoryType, keyword=sizeTerritoryType, atomic=SizeTerritoryType, atomic path=game.functions.ints.size.SizeTerritoryType
~~~~ <sizeArray> name=SizeArray type=SubLudeme (game.functions.ints.size.array.SizeArray) => <int>, pack=game.functions.ints.size.array, label=sizeArray, cls=game.functions.ints.size.array.SizeArray, keyword=sizeArray, atomic=SizeArray, atomic path=game.functions.ints.size.array.SizeArray
~~~~ <sizeGroup> name=SizeGroup type=SubLudeme (game.functions.ints.size.connection.SizeGroup) => <int>, pack=game.functions.ints.size.connection, label=sizeGroup, cls=game.functions.ints.size.connection.SizeGroup, keyword=sizeGroup, atomic=SizeGroup, atomic path=game.functions.ints.size.connection.SizeGroup
~~~~ <sizeTerritory> name=SizeTerritory type=SubLudeme (game.functions.ints.size.connection.SizeTerritory) => <int>, pack=game.functions.ints.size.connection, label=sizeTerritory, cls=game.functions.ints.size.connection.SizeTerritory, keyword=sizeTerritory, atomic=SizeTerritory, atomic path=game.functions.ints.size.connection.SizeTerritory
~~~~ <sizeLargePiece> name=SizeLargePiece type=SubLudeme (game.functions.ints.size.largePiece.SizeLargePiece) => <int>, pack=game.functions.ints.size.largePiece, label=sizeLargePiece, cls=game.functions.ints.size.largePiece.SizeLargePiece, keyword=sizeLargePiece, atomic=SizeLargePiece, atomic path=game.functions.ints.size.largePiece.SizeLargePiece
~~~~ <sizeStack> name=SizeStack type=SubLudeme (game.functions.ints.size.site.SizeStack) => <int>, pack=game.functions.ints.size.site, label=sizeStack, cls=game.functions.ints.size.site.SizeStack, keyword=sizeStack, atomic=SizeStack, atomic path=game.functions.ints.size.site.SizeStack
gd~~ <topLevel> name=TopLevel type=Ludeme (game.functions.ints.stacking.TopLevel) => <int>, pack=game.functions.ints.stacking, label=topLevel, cls=game.functions.ints.stacking.TopLevel, keyword=topLevel, atomic=TopLevel, atomic path=game.functions.ints.stacking.TopLevel
gd~~ <amount> name=Amount type=Ludeme (game.functions.ints.state.Amount) => <int>, pack=game.functions.ints.state, label=amount, cls=game.functions.ints.state.Amount, keyword=amount, atomic=Amount, atomic path=game.functions.ints.state.Amount
gd~~ <counter> name=Counter type=Ludeme (game.functions.ints.state.Counter) => <int>, pack=game.functions.ints.state, label=counter, cls=game.functions.ints.state.Counter, keyword=counter, atomic=Counter, atomic path=game.functions.ints.state.Counter
gd~~ <mover> name=Mover type=Ludeme (game.functions.ints.state.Mover) => <int>, pack=game.functions.ints.state, label=mover, cls=game.functions.ints.state.Mover, keyword=mover, atomic=Mover, atomic path=game.functions.ints.state.Mover
gd~~ <next> name=Next type=SuperLudeme (game.functions.ints.state.Next) => <int>, pack=game.functions.ints.state, label=next, cls=game.functions.ints.state.Next, keyword=next, atomic=Next, atomic path=game.functions.ints.state.Next
gd~~ <pot> name=Pot type=Ludeme (game.functions.ints.state.Pot) => <int>, pack=game.functions.ints.state, label=pot, cls=game.functions.ints.state.Pot, keyword=pot, atomic=Pot, atomic path=game.functions.ints.state.Pot
gd~~ <prev> name=Prev type=Ludeme (game.functions.ints.state.Prev) => <int>, pack=game.functions.ints.state, label=prev, cls=game.functions.ints.state.Prev, keyword=prev, atomic=Prev, atomic path=game.functions.ints.state.Prev
gd~~ <rotation> name=Rotation type=Ludeme (game.functions.ints.state.Rotation) => <int>, pack=game.functions.ints.state, label=rotation, cls=game.functions.ints.state.Rotation, keyword=rotation, atomic=Rotation, atomic path=game.functions.ints.state.Rotation
gd~~ <state.score> name=Score type=Ludeme (game.functions.ints.state.Score) => <int>, pack=game.functions.ints.state, label=state.score, cls=game.functions.ints.state.Score, keyword=score, atomic=Score, atomic path=game.functions.ints.state.Score
gd~~ <state> name=State type=Ludeme (game.functions.ints.state.State) => <int>, pack=game.functions.ints.state, label=state, cls=game.functions.ints.state.State, keyword=state, atomic=State, atomic path=game.functions.ints.state.State
gd~~ <var> name=Var type=Ludeme (game.functions.ints.state.Var) => <int>, pack=game.functions.ints.state, label=var, cls=game.functions.ints.state.Var, keyword=var, atomic=Var, atomic path=game.functions.ints.state.Var
gd~~ <what> name=What type=Ludeme (game.functions.ints.state.What) => <int>, pack=game.functions.ints.state, label=what, cls=game.functions.ints.state.What, keyword=what, atomic=What, atomic path=game.functions.ints.state.What
gd~~ <who> name=Who type=SuperLudeme (game.functions.ints.state.Who) => <int>, pack=game.functions.ints.state, label=who, cls=game.functions.ints.state.Who, keyword=who, atomic=Who, atomic path=game.functions.ints.state.Who
gd~~ <pathExtent> name=PathExtent type=Ludeme (game.functions.ints.tile.PathExtent) => <int>, pack=game.functions.ints.tile, label=pathExtent, cls=game.functions.ints.tile.PathExtent, keyword=pathExtent, atomic=PathExtent, atomic path=game.functions.ints.tile.PathExtent
gd~~ <trackSite> name=TrackSite type=SuperLudeme (game.functions.ints.trackSite.TrackSite) => <int>, pack=game.functions.ints.trackSite, label=trackSite, cls=game.functions.ints.trackSite.TrackSite, keyword=trackSite, atomic=TrackSite, atomic path=game.functions.ints.trackSite.TrackSite
~~~~ <trackSiteFirstType> name=TrackSiteFirstType type=Structural (game.functions.ints.trackSite.TrackSiteFirstType) => <trackSiteFirstType>, pack=game.functions.ints.trackSite, label=trackSiteFirstType, cls=game.functions.ints.trackSite.TrackSiteFirstType, keyword=trackSiteFirstType, atomic=TrackSiteFirstType, atomic path=game.functions.ints.trackSite.TrackSiteFirstType
~~~~ <trackSiteMoveType> name=TrackSiteMoveType type=Structural (game.functions.ints.trackSite.TrackSiteMoveType) => <trackSiteMoveType>, pack=game.functions.ints.trackSite, label=trackSiteMoveType, cls=game.functions.ints.trackSite.TrackSiteMoveType, keyword=trackSiteMoveType, atomic=TrackSiteMoveType, atomic path=game.functions.ints.trackSite.TrackSiteMoveType
~~~~ <trackSiteType> name=TrackSiteType type=Structural (game.functions.ints.trackSite.TrackSiteType) => <trackSiteType>, pack=game.functions.ints.trackSite, label=trackSiteType, cls=game.functions.ints.trackSite.TrackSiteType, keyword=trackSiteType, atomic=TrackSiteType, atomic path=game.functions.ints.trackSite.TrackSiteType
~~~~ <trackSiteFirstTrack> name=TrackSiteFirstTrack type=SubLudeme (game.functions.ints.trackSite.first.TrackSiteFirstTrack) => <int>, pack=game.functions.ints.trackSite.first, label=trackSiteFirstTrack, cls=game.functions.ints.trackSite.first.TrackSiteFirstTrack, keyword=trackSiteFirstTrack, atomic=TrackSiteFirstTrack, atomic path=game.functions.ints.trackSite.first.TrackSiteFirstTrack
~~~~ <trackSiteMove> name=TrackSiteMove type=SubLudeme (game.functions.ints.trackSite.move.TrackSiteMove) => <int>, pack=game.functions.ints.trackSite.move, label=trackSiteMove, cls=game.functions.ints.trackSite.move.TrackSiteMove, keyword=trackSiteMove, atomic=TrackSiteMove, atomic path=game.functions.ints.trackSite.move.TrackSiteMove
~~~~ <trackSiteEndTrack> name=TrackSiteEndTrack type=SubLudeme (game.functions.ints.trackSite.position.TrackSiteEndTrack) => <int>, pack=game.functions.ints.trackSite.position, label=trackSiteEndTrack, cls=game.functions.ints.trackSite.position.TrackSiteEndTrack, keyword=trackSiteEndTrack, atomic=TrackSiteEndTrack, atomic path=game.functions.ints.trackSite.position.TrackSiteEndTrack
gd~~ <value> name=Value type=SuperLudeme (game.functions.ints.value.Value) => <int>, pack=game.functions.ints.value, label=value, cls=game.functions.ints.value.Value, keyword=value, atomic=Value, atomic path=game.functions.ints.value.Value
~~~~ <valueComponentType> name=ValueComponentType type=Structural (game.functions.ints.value.ValueComponentType) => <valueComponentType>, pack=game.functions.ints.value, label=valueComponentType, cls=game.functions.ints.value.ValueComponentType, keyword=valueComponentType, atomic=ValueComponentType, atomic path=game.functions.ints.value.ValueComponentType
~~~~ <valuePlayerType> name=ValuePlayerType type=Structural (game.functions.ints.value.ValuePlayerType) => <valuePlayerType>, pack=game.functions.ints.value, label=valuePlayerType, cls=game.functions.ints.value.ValuePlayerType, keyword=valuePlayerType, atomic=ValuePlayerType, atomic path=game.functions.ints.value.ValuePlayerType
~~~~ <valueRandomType> name=ValueRandomType type=Structural (game.functions.ints.value.ValueRandomType) => <valueRandomType>, pack=game.functions.ints.value, label=valueRandomType, cls=game.functions.ints.value.ValueRandomType, keyword=valueRandomType, atomic=ValueRandomType, atomic path=game.functions.ints.value.ValueRandomType
g~~~ <valueSimpleType> name=ValueSimpleType type=Structural (game.functions.ints.value.ValueSimpleType) => <valueSimpleType>, pack=game.functions.ints.value, label=valueSimpleType, cls=game.functions.ints.value.ValueSimpleType, keyword=valueSimpleType, atomic=ValueSimpleType, atomic path=game.functions.ints.value.ValueSimpleType
~~~~ <valueIterated> name=ValueIterated type=SubLudeme (game.functions.ints.value.iterated.ValueIterated) => <int>, pack=game.functions.ints.value.iterated, label=valueIterated, cls=game.functions.ints.value.iterated.ValueIterated, keyword=valueIterated, atomic=ValueIterated, atomic path=game.functions.ints.value.iterated.ValueIterated
~~~~ <valuePiece> name=ValuePiece type=SubLudeme (game.functions.ints.value.piece.ValuePiece) => <int>, pack=game.functions.ints.value.piece, label=valuePiece, cls=game.functions.ints.value.piece.ValuePiece, keyword=valuePiece, atomic=ValuePiece, atomic path=game.functions.ints.value.piece.ValuePiece
~~~~ <valuePlayer> name=ValuePlayer type=SubLudeme (game.functions.ints.value.player.ValuePlayer) => <int>, pack=game.functions.ints.value.player, label=valuePlayer, cls=game.functions.ints.value.player.ValuePlayer, keyword=valuePlayer, atomic=ValuePlayer, atomic path=game.functions.ints.value.player.ValuePlayer
~~~~ <valueRandom> name=ValueRandom type=SubLudeme (game.functions.ints.value.random.ValueRandom) => <int>, pack=game.functions.ints.value.random, label=valueRandom, cls=game.functions.ints.value.random.ValueRandom, keyword=valueRandom, atomic=ValueRandom, atomic path=game.functions.ints.value.random.ValueRandom
~~~~ <valueMoveLimit> name=ValueMoveLimit type=SubLudeme (game.functions.ints.value.simple.ValueMoveLimit) => <int>, pack=game.functions.ints.value.simple, label=valueMoveLimit, cls=game.functions.ints.value.simple.ValueMoveLimit, keyword=valueMoveLimit, atomic=ValueMoveLimit, atomic path=game.functions.ints.value.simple.ValueMoveLimit
~~~~ <valuePending> name=ValuePending type=SubLudeme (game.functions.ints.value.simple.ValuePending) => <int>, pack=game.functions.ints.value.simple, label=valuePending, cls=game.functions.ints.value.simple.ValuePending, keyword=valuePending, atomic=ValuePending, atomic path=game.functions.ints.value.simple.ValuePending
~~~~ <valueTurnLimit> name=ValueTurnLimit type=SubLudeme (game.functions.ints.value.simple.ValueTurnLimit) => <int>, pack=game.functions.ints.value.simple, label=valueTurnLimit, cls=game.functions.ints.value.simple.ValueTurnLimit, keyword=valueTurnLimit, atomic=ValueTurnLimit, atomic path=game.functions.ints.value.simple.ValueTurnLimit
gd~* <baseRangeFunction> name=BaseRangeFunction type=Ludeme (game.functions.range.BaseRangeFunction) => <range>, pack=game.functions.range, label=baseRangeFunction, cls=game.functions.range.BaseRangeFunction, keyword=baseRangeFunction, atomic=BaseRangeFunction, atomic path=game.functions.range.BaseRangeFunction
gd~~ <range> name=Range type=Ludeme (game.functions.range.Range) => <range>, pack=game.functions.range, label=range, cls=game.functions.range.Range, keyword=range, atomic=Range, atomic path=game.functions.range.Range
g~~* <range> name=RangeFunction type=Structural (game.functions.range.RangeFunction) => <range>, pack=game.functions.range, label=range, cls=game.functions.range.RangeFunction, keyword=rangeFunction, atomic=Range, atomic path=game.functions.range.Range
gd~~ <exact> name=Exact type=Ludeme (game.functions.range.math.Exact) => <range>, pack=game.functions.range.math, label=exact, cls=game.functions.range.math.Exact, keyword=exact, atomic=Exact, atomic path=game.functions.range.math.Exact
gd~~ <range.math.max> name=Max type=Ludeme (game.functions.range.math.Max) => <range>, pack=game.functions.range.math, label=range.math.max, cls=game.functions.range.math.Max, keyword=max, atomic=Max, atomic path=game.functions.range.math.Max
gd~~ <range.math.min> name=Min type=Ludeme (game.functions.range.math.Min) => <range>, pack=game.functions.range.math, label=range.math.min, cls=game.functions.range.math.Min, keyword=min, atomic=Min, atomic path=game.functions.range.math.Min
~~~* <baseRegionFunction> name=BaseRegionFunction type=Ludeme (game.functions.region.BaseRegionFunction) => <baseRegionFunction>, pack=game.functions.region, label=baseRegionFunction, cls=game.functions.region.BaseRegionFunction, keyword=baseRegionFunction, atomic=BaseRegionFunction, atomic path=game.functions.region.BaseRegionFunction
~~~~ <regionConstant> name=RegionConstant type=Ludeme (game.functions.region.RegionConstant) => <equipment.region>, pack=game.functions.region, label=regionConstant, cls=game.functions.region.RegionConstant, keyword=regionConstant, atomic=Region, atomic path=game.util.equipment.Region
g~m* <sites> name=RegionFunction type=Structural (game.functions.region.RegionFunction) => <equipment.region>, pack=game.functions.region, label=sites, cls=game.functions.region.RegionFunction, keyword=regionFunction, atomic=Region, atomic path=game.util.equipment.Region
gd~~ <region.foreach.forEach> name=ForEach type=SuperLudeme (game.functions.region.foreach.ForEach) => <equipment.region>, pack=game.functions.region.foreach, label=region.foreach.forEach, cls=game.functions.region.foreach.ForEach, keyword=forEach, atomic=ForEach, atomic path=game.functions.region.foreach.ForEach
~~~~ <region.foreach.forEachLevelType> name=ForEachLevelType type=Structural (game.functions.region.foreach.ForEachLevelType) => <region.foreach.forEachLevelType>, pack=game.functions.region.foreach, label=region.foreach.forEachLevelType, cls=game.functions.region.foreach.ForEachLevelType, keyword=forEachLevelType, atomic=ForEachLevelType, atomic path=game.functions.region.foreach.ForEachLevelType
~~~~ <region.foreach.level.forEachLevel> name=ForEachLevel type=SubLudeme (game.functions.region.foreach.level.ForEachLevel) => <equipment.region>, pack=game.functions.region.foreach.level, label=region.foreach.level.forEachLevel, cls=game.functions.region.foreach.level.ForEachLevel, keyword=forEachLevel, atomic=ForEachLevel, atomic path=game.functions.region.foreach.level.ForEachLevel
~~~~ <region.foreach.player.forEachPlayer> name=ForEachPlayer type=SubLudeme (game.functions.region.foreach.player.ForEachPlayer) => <equipment.region>, pack=game.functions.region.foreach.player, label=region.foreach.player.forEachPlayer, cls=game.functions.region.foreach.player.ForEachPlayer, keyword=forEachPlayer, atomic=ForEachPlayer, atomic path=game.functions.region.foreach.player.ForEachPlayer
~~~~ <sites.forEachSite> name=ForEachSite type=SubLudeme (game.functions.region.foreach.sites.ForEachSite) => <equipment.region>, pack=game.functions.region.foreach.sites, label=sites.forEachSite, cls=game.functions.region.foreach.sites.ForEachSite, keyword=forEachSite, atomic=ForEachSite, atomic path=game.functions.region.foreach.sites.ForEachSite
~~~~ <forEachSiteInRegion> name=ForEachSiteInRegion type=SubLudeme (game.functions.region.foreach.sites.ForEachSiteInRegion) => <equipment.region>, pack=game.functions.region.foreach.sites, label=forEachSiteInRegion, cls=game.functions.region.foreach.sites.ForEachSiteInRegion, keyword=forEachSiteInRegion, atomic=ForEachSiteInRegion, atomic path=game.functions.region.foreach.sites.ForEachSiteInRegion
~~~~ <region.foreach.team.forEachTeam> name=ForEachTeam type=SubLudeme (game.functions.region.foreach.team.ForEachTeam) => <equipment.region>, pack=game.functions.region.foreach.team, label=region.foreach.team.forEachTeam, cls=game.functions.region.foreach.team.ForEachTeam, keyword=forEachTeam, atomic=ForEachTeam, atomic path=game.functions.region.foreach.team.ForEachTeam
gd~~ <region.last.last> name=Last type=SuperLudeme (game.functions.region.last.Last) => <equipment.region>, pack=game.functions.region.last, label=region.last.last, cls=game.functions.region.last.Last, keyword=last, atomic=Last, atomic path=game.functions.region.last.Last
~~~~ <lastBetween> name=LastBetween type=SubLudeme (game.functions.region.last.LastBetween) => <equipment.region>, pack=game.functions.region.last, label=lastBetween, cls=game.functions.region.last.LastBetween, keyword=lastBetween, atomic=LastBetween, atomic path=game.functions.region.last.LastBetween
~~~~ <lastRegionType> name=LastRegionType type=Structural (game.functions.region.last.LastRegionType) => <lastRegionType>, pack=game.functions.region.last, label=lastRegionType, cls=game.functions.region.last.LastRegionType, keyword=lastRegionType, atomic=LastRegionType, atomic path=game.functions.region.last.LastRegionType
gd~~ <region.math.difference> name=Difference type=Ludeme (game.functions.region.math.Difference) => <equipment.region>, pack=game.functions.region.math, label=region.math.difference, cls=game.functions.region.math.Difference, keyword=difference, atomic=Difference, atomic path=game.functions.region.math.Difference
gd~~ <expand> name=Expand type=Ludeme (game.functions.region.math.Expand) => <equipment.region>, pack=game.functions.region.math, label=expand, cls=game.functions.region.math.Expand, keyword=expand, atomic=Expand, atomic path=game.functions.region.math.Expand
gd~~ <region.math.if> name=If type=Ludeme (game.functions.region.math.If) => <equipment.region>, pack=game.functions.region.math, label=region.math.if, cls=game.functions.region.math.If, keyword=if, atomic=If, atomic path=game.functions.region.math.If
gd~~ <region.math.intersection> name=Intersection type=Ludeme (game.functions.region.math.Intersection) => <equipment.region>, pack=game.functions.region.math, label=region.math.intersection, cls=game.functions.region.math.Intersection, keyword=intersection, atomic=Intersection, atomic path=game.functions.region.math.Intersection
gd~~ <region.math.union> name=Union type=Ludeme (game.functions.region.math.Union) => <equipment.region>, pack=game.functions.region.math, label=region.math.union, cls=game.functions.region.math.Union, keyword=union, atomic=Union, atomic path=game.functions.region.math.Union
g~~~ <lineOfSightType> name=LineOfSightType type=Structural (game.functions.region.sites.LineOfSightType) => <lineOfSightType>, pack=game.functions.region.sites, label=lineOfSightType, cls=game.functions.region.sites.LineOfSightType, keyword=lineOfSightType, atomic=LineOfSightType, atomic path=game.functions.region.sites.LineOfSightType
gd~~ <sites> name=Sites type=SuperLudeme (game.functions.region.sites.Sites) => <equipment.region>, pack=game.functions.region.sites, label=sites, cls=game.functions.region.sites.Sites, keyword=sites, atomic=Sites, atomic path=game.functions.region.sites.Sites
~~~~ <sitesAroundType> name=SitesAroundType type=Structural (game.functions.region.sites.SitesAroundType) => <sitesAroundType>, pack=game.functions.region.sites, label=sitesAroundType, cls=game.functions.region.sites.SitesAroundType, keyword=sitesAroundType, atomic=SitesAroundType, atomic path=game.functions.region.sites.SitesAroundType
~~~~ <sitesBetweenType> name=SitesBetweenType type=Structural (game.functions.region.sites.SitesBetweenType) => <sitesBetweenType>, pack=game.functions.region.sites, label=sitesBetweenType, cls=game.functions.region.sites.SitesBetweenType, keyword=sitesBetweenType, atomic=SitesBetweenType, atomic path=game.functions.region.sites.SitesBetweenType
~~~~ <sitesCrossingType> name=SitesCrossingType type=Structural (game.functions.region.sites.SitesCrossingType) => <sitesCrossingType>, pack=game.functions.region.sites, label=sitesCrossingType, cls=game.functions.region.sites.SitesCrossingType, keyword=sitesCrossingType, atomic=SitesCrossingType, atomic path=game.functions.region.sites.SitesCrossingType
~~~~ <sitesDirectionType> name=SitesDirectionType type=Structural (game.functions.region.sites.SitesDirectionType) => <sitesDirectionType>, pack=game.functions.region.sites, label=sitesDirectionType, cls=game.functions.region.sites.SitesDirectionType, keyword=sitesDirectionType, atomic=SitesDirectionType, atomic path=game.functions.region.sites.SitesDirectionType
~~~~ <sitesDistanceType> name=SitesDistanceType type=Structural (game.functions.region.sites.SitesDistanceType) => <sitesDistanceType>, pack=game.functions.region.sites, label=sitesDistanceType, cls=game.functions.region.sites.SitesDistanceType, keyword=sitesDistanceType, atomic=SitesDistanceType, atomic path=game.functions.region.sites.SitesDistanceType
g~~~ <sitesEdgeType> name=SitesEdgeType type=Structural (game.functions.region.sites.SitesEdgeType) => <sitesEdgeType>, pack=game.functions.region.sites, label=sitesEdgeType, cls=game.functions.region.sites.SitesEdgeType, keyword=sitesEdgeType, atomic=SitesEdgeType, atomic path=game.functions.region.sites.SitesEdgeType
~~~~ <sitesGroupType> name=SitesGroupType type=Structural (game.functions.region.sites.SitesGroupType) => <sitesGroupType>, pack=game.functions.region.sites, label=sitesGroupType, cls=game.functions.region.sites.SitesGroupType, keyword=sitesGroupType, atomic=SitesGroupType, atomic path=game.functions.region.sites.SitesGroupType
~~~~ <sitesHiddenType> name=SitesHiddenType type=Structural (game.functions.region.sites.SitesHiddenType) => <sitesHiddenType>, pack=game.functions.region.sites, label=sitesHiddenType, cls=game.functions.region.sites.SitesHiddenType, keyword=sitesHiddenType, atomic=SitesHiddenType, atomic path=game.functions.region.sites.SitesHiddenType
~~~~ <sitesIncidentType> name=SitesIncidentType type=Structural (game.functions.region.sites.SitesIncidentType) => <sitesIncidentType>, pack=game.functions.region.sites, label=sitesIncidentType, cls=game.functions.region.sites.SitesIncidentType, keyword=sitesIncidentType, atomic=SitesIncidentType, atomic path=game.functions.region.sites.SitesIncidentType
g~~~ <sitesIndexType> name=SitesIndexType type=Structural (game.functions.region.sites.SitesIndexType) => <sitesIndexType>, pack=game.functions.region.sites, label=sitesIndexType, cls=game.functions.region.sites.SitesIndexType, keyword=sitesIndexType, atomic=SitesIndexType, atomic path=game.functions.region.sites.SitesIndexType
~~~~ <sitesLargePieceType> name=SitesLargePieceType type=Structural (game.functions.region.sites.SitesLargePieceType) => <sitesLargePieceType>, pack=game.functions.region.sites, label=sitesLargePieceType, cls=game.functions.region.sites.SitesLargePieceType, keyword=sitesLargePieceType, atomic=SitesLargePieceType, atomic path=game.functions.region.sites.SitesLargePieceType
~~~~ <sitesLineOfSightType> name=SitesLineOfSightType type=Structural (game.functions.region.sites.SitesLineOfSightType) => <sitesLineOfSightType>, pack=game.functions.region.sites, label=sitesLineOfSightType, cls=game.functions.region.sites.SitesLineOfSightType, keyword=sitesLineOfSightType, atomic=SitesLineOfSightType, atomic path=game.functions.region.sites.SitesLineOfSightType
~~~~ <sitesLoopType> name=SitesLoopType type=Structural (game.functions.region.sites.SitesLoopType) => <sitesLoopType>, pack=game.functions.region.sites, label=sitesLoopType, cls=game.functions.region.sites.SitesLoopType, keyword=sitesLoopType, atomic=SitesLoopType, atomic path=game.functions.region.sites.SitesLoopType
g~~~ <sitesMoveType> name=SitesMoveType type=Structural (game.functions.region.sites.SitesMoveType) => <sitesMoveType>, pack=game.functions.region.sites, label=sitesMoveType, cls=game.functions.region.sites.SitesMoveType, keyword=sitesMoveType, atomic=SitesMoveType, atomic path=game.functions.region.sites.SitesMoveType
~~~~ <sitesOccupiedType> name=SitesOccupiedType type=Structural (game.functions.region.sites.SitesOccupiedType) => <sitesOccupiedType>, pack=game.functions.region.sites, label=sitesOccupiedType, cls=game.functions.region.sites.SitesOccupiedType, keyword=sitesOccupiedType, atomic=SitesOccupiedType, atomic path=game.functions.region.sites.SitesOccupiedType
~~~~ <sitesPatternType> name=SitesPatternType type=Structural (game.functions.region.sites.SitesPatternType) => <sitesPatternType>, pack=game.functions.region.sites, label=sitesPatternType, cls=game.functions.region.sites.SitesPatternType, keyword=sitesPatternType, atomic=SitesPatternType, atomic path=game.functions.region.sites.SitesPatternType
~~~~ <sitesPieceType> name=SitesPieceType type=Structural (game.functions.region.sites.SitesPieceType) => <sitesPieceType>, pack=game.functions.region.sites, label=sitesPieceType, cls=game.functions.region.sites.SitesPieceType, keyword=sitesPieceType, atomic=SitesPieceType, atomic path=game.functions.region.sites.SitesPieceType
g~~~ <sitesPlayerType> name=SitesPlayerType type=Structural (game.functions.region.sites.SitesPlayerType) => <sitesPlayerType>, pack=game.functions.region.sites, label=sitesPlayerType, cls=game.functions.region.sites.SitesPlayerType, keyword=sitesPlayerType, atomic=SitesPlayerType, atomic path=game.functions.region.sites.SitesPlayerType
~~~~ <sitesRandomType> name=SitesRandomType type=Structural (game.functions.region.sites.SitesRandomType) => <sitesRandomType>, pack=game.functions.region.sites, label=sitesRandomType, cls=game.functions.region.sites.SitesRandomType, keyword=sitesRandomType, atomic=SitesRandomType, atomic path=game.functions.region.sites.SitesRandomType
~~~~ <sitesSideType> name=SitesSideType type=Structural (game.functions.region.sites.SitesSideType) => <sitesSideType>, pack=game.functions.region.sites, label=sitesSideType, cls=game.functions.region.sites.SitesSideType, keyword=sitesSideType, atomic=SitesSideType, atomic path=game.functions.region.sites.SitesSideType
g~~~ <sitesSimpleType> name=SitesSimpleType type=Structural (game.functions.region.sites.SitesSimpleType) => <sitesSimpleType>, pack=game.functions.region.sites, label=sitesSimpleType, cls=game.functions.region.sites.SitesSimpleType, keyword=sitesSimpleType, atomic=SitesSimpleType, atomic path=game.functions.region.sites.SitesSimpleType
~~~~ <sitesTrackType> name=SitesTrackType type=Structural (game.functions.region.sites.SitesTrackType) => <sitesTrackType>, pack=game.functions.region.sites, label=sitesTrackType, cls=game.functions.region.sites.SitesTrackType, keyword=sitesTrackType, atomic=SitesTrackType, atomic path=game.functions.region.sites.SitesTrackType
~~~~ <sitesAround> name=SitesAround type=SubLudeme (game.functions.region.sites.around.SitesAround) => <equipment.region>, pack=game.functions.region.sites.around, label=sitesAround, cls=game.functions.region.sites.around.SitesAround, keyword=sitesAround, atomic=SitesAround, atomic path=game.functions.region.sites.around.SitesAround
~~~~ <between.sitesBetween> name=SitesBetween type=SubLudeme (game.functions.region.sites.between.SitesBetween) => <equipment.region>, pack=game.functions.region.sites.between, label=between.sitesBetween, cls=game.functions.region.sites.between.SitesBetween, keyword=sitesBetween, atomic=SitesBetween, atomic path=game.functions.region.sites.between.SitesBetween
~~~~ <sitesContext> name=SitesContext type=SubLudeme (game.functions.region.sites.context.SitesContext) => <equipment.region>, pack=game.functions.region.sites.context, label=sitesContext, cls=game.functions.region.sites.context.SitesContext, keyword=sitesContext, atomic=SitesContext, atomic path=game.functions.region.sites.context.SitesContext
~~~~ <sitesCoords> name=SitesCoords type=SubLudeme (game.functions.region.sites.coords.SitesCoords) => <equipment.region>, pack=game.functions.region.sites.coords, label=sitesCoords, cls=game.functions.region.sites.coords.SitesCoords, keyword=sitesCoords, atomic=SitesCoords, atomic path=game.functions.region.sites.coords.SitesCoords
~~~~ <sitesCrossing> name=SitesCrossing type=SubLudeme (game.functions.region.sites.crossing.SitesCrossing) => <equipment.region>, pack=game.functions.region.sites.crossing, label=sitesCrossing, cls=game.functions.region.sites.crossing.SitesCrossing, keyword=sitesCrossing, atomic=SitesCrossing, atomic path=game.functions.region.sites.crossing.SitesCrossing
~~~~ <sitesCustom> name=SitesCustom type=SubLudeme (game.functions.region.sites.custom.SitesCustom) => <equipment.region>, pack=game.functions.region.sites.custom, label=sitesCustom, cls=game.functions.region.sites.custom.SitesCustom, keyword=sitesCustom, atomic=SitesCustom, atomic path=game.functions.region.sites.custom.SitesCustom
~~~~ <sitesDirection> name=SitesDirection type=SubLudeme (game.functions.region.sites.direction.SitesDirection) => <equipment.region>, pack=game.functions.region.sites.direction, label=sitesDirection, cls=game.functions.region.sites.direction.SitesDirection, keyword=sitesDirection, atomic=SitesDirection, atomic path=game.functions.region.sites.direction.SitesDirection
~~~~ <sitesDistance> name=SitesDistance type=SubLudeme (game.functions.region.sites.distance.SitesDistance) => <equipment.region>, pack=game.functions.region.sites.distance, label=sitesDistance, cls=game.functions.region.sites.distance.SitesDistance, keyword=sitesDistance, atomic=SitesDistance, atomic path=game.functions.region.sites.distance.SitesDistance
~~~~ <sitesAngled> name=SitesAngled type=SubLudeme (game.functions.region.sites.edges.SitesAngled) => <equipment.region>, pack=game.functions.region.sites.edges, label=sitesAngled, cls=game.functions.region.sites.edges.SitesAngled, keyword=sitesAngled, atomic=SitesAngled, atomic path=game.functions.region.sites.edges.SitesAngled
~~~~ <sitesAxial> name=SitesAxial type=SubLudeme (game.functions.region.sites.edges.SitesAxial) => <equipment.region>, pack=game.functions.region.sites.edges, label=sitesAxial, cls=game.functions.region.sites.edges.SitesAxial, keyword=sitesAxial, atomic=SitesAxial, atomic path=game.functions.region.sites.edges.SitesAxial
~~~~ <sitesHorizontal> name=SitesHorizontal type=SubLudeme (game.functions.region.sites.edges.SitesHorizontal) => <equipment.region>, pack=game.functions.region.sites.edges, label=sitesHorizontal, cls=game.functions.region.sites.edges.SitesHorizontal, keyword=sitesHorizontal, atomic=SitesHorizontal, atomic path=game.functions.region.sites.edges.SitesHorizontal
~~~~ <sitesSlash> name=SitesSlash type=SubLudeme (game.functions.region.sites.edges.SitesSlash) => <equipment.region>, pack=game.functions.region.sites.edges, label=sitesSlash, cls=game.functions.region.sites.edges.SitesSlash, keyword=sitesSlash, atomic=SitesSlash, atomic path=game.functions.region.sites.edges.SitesSlash
~~~~ <sitesSlosh> name=SitesSlosh type=SubLudeme (game.functions.region.sites.edges.SitesSlosh) => <equipment.region>, pack=game.functions.region.sites.edges, label=sitesSlosh, cls=game.functions.region.sites.edges.SitesSlosh, keyword=sitesSlosh, atomic=SitesSlosh, atomic path=game.functions.region.sites.edges.SitesSlosh
~~~~ <sitesVertical> name=SitesVertical type=SubLudeme (game.functions.region.sites.edges.SitesVertical) => <equipment.region>, pack=game.functions.region.sites.edges, label=sitesVertical, cls=game.functions.region.sites.edges.SitesVertical, keyword=sitesVertical, atomic=SitesVertical, atomic path=game.functions.region.sites.edges.SitesVertical
~~~~ <sitesGroup> name=SitesGroup type=SubLudeme (game.functions.region.sites.group.SitesGroup) => <equipment.region>, pack=game.functions.region.sites.group, label=sitesGroup, cls=game.functions.region.sites.group.SitesGroup, keyword=sitesGroup, atomic=SitesGroup, atomic path=game.functions.region.sites.group.SitesGroup
~~~~ <sitesHidden> name=SitesHidden type=SubLudeme (game.functions.region.sites.hidden.SitesHidden) => <equipment.region>, pack=game.functions.region.sites.hidden, label=sitesHidden, cls=game.functions.region.sites.hidden.SitesHidden, keyword=sitesHidden, atomic=SitesHidden, atomic path=game.functions.region.sites.hidden.SitesHidden
~~~~ <sitesHiddenCount> name=SitesHiddenCount type=SubLudeme (game.functions.region.sites.hidden.SitesHiddenCount) => <equipment.region>, pack=game.functions.region.sites.hidden, label=sitesHiddenCount, cls=game.functions.region.sites.hidden.SitesHiddenCount, keyword=sitesHiddenCount, atomic=SitesHiddenCount, atomic path=game.functions.region.sites.hidden.SitesHiddenCount
~~~~ <sitesHiddenRotation> name=SitesHiddenRotation type=SubLudeme (game.functions.region.sites.hidden.SitesHiddenRotation) => <equipment.region>, pack=game.functions.region.sites.hidden, label=sitesHiddenRotation, cls=game.functions.region.sites.hidden.SitesHiddenRotation, keyword=sitesHiddenRotation, atomic=SitesHiddenRotation, atomic path=game.functions.region.sites.hidden.SitesHiddenRotation
~~~~ <sitesHiddenState> name=SitesHiddenState type=SubLudeme (game.functions.region.sites.hidden.SitesHiddenState) => <equipment.region>, pack=game.functions.region.sites.hidden, label=sitesHiddenState, cls=game.functions.region.sites.hidden.SitesHiddenState, keyword=sitesHiddenState, atomic=SitesHiddenState, atomic path=game.functions.region.sites.hidden.SitesHiddenState
~~~~ <sitesHiddenValue> name=SitesHiddenValue type=SubLudeme (game.functions.region.sites.hidden.SitesHiddenValue) => <equipment.region>, pack=game.functions.region.sites.hidden, label=sitesHiddenValue, cls=game.functions.region.sites.hidden.SitesHiddenValue, keyword=sitesHiddenValue, atomic=SitesHiddenValue, atomic path=game.functions.region.sites.hidden.SitesHiddenValue
~~~~ <sitesHiddenWhat> name=SitesHiddenWhat type=SubLudeme (game.functions.region.sites.hidden.SitesHiddenWhat) => <equipment.region>, pack=game.functions.region.sites.hidden, label=sitesHiddenWhat, cls=game.functions.region.sites.hidden.SitesHiddenWhat, keyword=sitesHiddenWhat, atomic=SitesHiddenWhat, atomic path=game.functions.region.sites.hidden.SitesHiddenWhat
~~~~ <sitesHiddenWho> name=SitesHiddenWho type=SubLudeme (game.functions.region.sites.hidden.SitesHiddenWho) => <equipment.region>, pack=game.functions.region.sites.hidden, label=sitesHiddenWho, cls=game.functions.region.sites.hidden.SitesHiddenWho, keyword=sitesHiddenWho, atomic=SitesHiddenWho, atomic path=game.functions.region.sites.hidden.SitesHiddenWho
~~~~ <sitesIncident> name=SitesIncident type=SubLudeme (game.functions.region.sites.incidents.SitesIncident) => <equipment.region>, pack=game.functions.region.sites.incidents, label=sitesIncident, cls=game.functions.region.sites.incidents.SitesIncident, keyword=sitesIncident, atomic=SitesIncident, atomic path=game.functions.region.sites.incidents.SitesIncident
~~~~ <sitesCell> name=SitesCell type=SubLudeme (game.functions.region.sites.index.SitesCell) => <equipment.region>, pack=game.functions.region.sites.index, label=sitesCell, cls=game.functions.region.sites.index.SitesCell, keyword=sitesCell, atomic=SitesCell, atomic path=game.functions.region.sites.index.SitesCell
~~~~ <sitesColumn> name=SitesColumn type=SubLudeme (game.functions.region.sites.index.SitesColumn) => <equipment.region>, pack=game.functions.region.sites.index, label=sitesColumn, cls=game.functions.region.sites.index.SitesColumn, keyword=sitesColumn, atomic=SitesColumn, atomic path=game.functions.region.sites.index.SitesColumn
~~~~ <sitesEdge> name=SitesEdge type=SubLudeme (game.functions.region.sites.index.SitesEdge) => <equipment.region>, pack=game.functions.region.sites.index, label=sitesEdge, cls=game.functions.region.sites.index.SitesEdge, keyword=sitesEdge, atomic=SitesEdge, atomic path=game.functions.region.sites.index.SitesEdge
~~~~ <sitesEmpty> name=SitesEmpty type=SuperLudeme (game.functions.region.sites.index.SitesEmpty) => <equipment.region>, pack=game.functions.region.sites.index, label=sitesEmpty, cls=game.functions.region.sites.index.SitesEmpty, keyword=sitesEmpty, atomic=SitesEmpty, atomic path=game.functions.region.sites.index.SitesEmpty
~~~~ <sitesLayer> name=SitesLayer type=SubLudeme (game.functions.region.sites.index.SitesLayer) => <equipment.region>, pack=game.functions.region.sites.index, label=sitesLayer, cls=game.functions.region.sites.index.SitesLayer, keyword=sitesLayer, atomic=SitesLayer, atomic path=game.functions.region.sites.index.SitesLayer
~~~~ <sitesPhase> name=SitesPhase type=SubLudeme (game.functions.region.sites.index.SitesPhase) => <equipment.region>, pack=game.functions.region.sites.index, label=sitesPhase, cls=game.functions.region.sites.index.SitesPhase, keyword=sitesPhase, atomic=SitesPhase, atomic path=game.functions.region.sites.index.SitesPhase
~~~~ <sitesRow> name=SitesRow type=SubLudeme (game.functions.region.sites.index.SitesRow) => <equipment.region>, pack=game.functions.region.sites.index, label=sitesRow, cls=game.functions.region.sites.index.SitesRow, keyword=sitesRow, atomic=SitesRow, atomic path=game.functions.region.sites.index.SitesRow
~~~~ <sitesState> name=SitesState type=SubLudeme (game.functions.region.sites.index.SitesState) => <equipment.region>, pack=game.functions.region.sites.index, label=sitesState, cls=game.functions.region.sites.index.SitesState, keyword=sitesState, atomic=SitesState, atomic path=game.functions.region.sites.index.SitesState
~~~~ <sitesLargePiece> name=SitesLargePiece type=SubLudeme (game.functions.region.sites.largePiece.SitesLargePiece) => <equipment.region>, pack=game.functions.region.sites.largePiece, label=sitesLargePiece, cls=game.functions.region.sites.largePiece.SitesLargePiece, keyword=sitesLargePiece, atomic=SitesLargePiece, atomic path=game.functions.region.sites.largePiece.SitesLargePiece
~~~~ <sitesLineOfSight> name=SitesLineOfSight type=SubLudeme (game.functions.region.sites.lineOfSight.SitesLineOfSight) => <equipment.region>, pack=game.functions.region.sites.lineOfSight, label=sitesLineOfSight, cls=game.functions.region.sites.lineOfSight.SitesLineOfSight, keyword=sitesLineOfSight, atomic=SitesLineOfSight, atomic path=game.functions.region.sites.lineOfSight.SitesLineOfSight
~~~~ <sitesLoop> name=SitesLoop type=SubLudeme (game.functions.region.sites.loop.SitesLoop) => <equipment.region>, pack=game.functions.region.sites.loop, label=sitesLoop, cls=game.functions.region.sites.loop.SitesLoop, keyword=sitesLoop, atomic=SitesLoop, atomic path=game.functions.region.sites.loop.SitesLoop
~~~~ <moves.sitesBetween> name=SitesBetween type=SubLudeme (game.functions.region.sites.moves.SitesBetween) => <equipment.region>, pack=game.functions.region.sites.moves, label=moves.sitesBetween, cls=game.functions.region.sites.moves.SitesBetween, keyword=sitesBetween, atomic=SitesBetween, atomic path=game.functions.region.sites.moves.SitesBetween
~~~~ <sitesFrom> name=SitesFrom type=SubLudeme (game.functions.region.sites.moves.SitesFrom) => <equipment.region>, pack=game.functions.region.sites.moves, label=sitesFrom, cls=game.functions.region.sites.moves.SitesFrom, keyword=sitesFrom, atomic=SitesFrom, atomic path=game.functions.region.sites.moves.SitesFrom
~~~~ <sitesTo> name=SitesTo type=SubLudeme (game.functions.region.sites.moves.SitesTo) => <equipment.region>, pack=game.functions.region.sites.moves, label=sitesTo, cls=game.functions.region.sites.moves.SitesTo, keyword=sitesTo, atomic=SitesTo, atomic path=game.functions.region.sites.moves.SitesTo
~~~~ <sitesOccupied> name=SitesOccupied type=SubLudeme (game.functions.region.sites.occupied.SitesOccupied) => <equipment.region>, pack=game.functions.region.sites.occupied, label=sitesOccupied, cls=game.functions.region.sites.occupied.SitesOccupied, keyword=sitesOccupied, atomic=SitesOccupied, atomic path=game.functions.region.sites.occupied.SitesOccupied
~~~~ <sitesPattern> name=SitesPattern type=SubLudeme (game.functions.region.sites.pattern.SitesPattern) => <equipment.region>, pack=game.functions.region.sites.pattern, label=sitesPattern, cls=game.functions.region.sites.pattern.SitesPattern, keyword=sitesPattern, atomic=SitesPattern, atomic path=game.functions.region.sites.pattern.SitesPattern
~~~~ <sitesStart> name=SitesStart type=SubLudeme (game.functions.region.sites.piece.SitesStart) => <equipment.region>, pack=game.functions.region.sites.piece, label=sitesStart, cls=game.functions.region.sites.piece.SitesStart, keyword=sitesStart, atomic=SitesStart, atomic path=game.functions.region.sites.piece.SitesStart
~~~~ <sitesEquipmentRegion> name=SitesEquipmentRegion type=SubLudeme (game.functions.region.sites.player.SitesEquipmentRegion) => <equipment.region>, pack=game.functions.region.sites.player, label=sitesEquipmentRegion, cls=game.functions.region.sites.player.SitesEquipmentRegion, keyword=sitesEquipmentRegion, atomic=SitesEquipmentRegion, atomic path=game.functions.region.sites.player.SitesEquipmentRegion
~~~~ <sitesHand> name=SitesHand type=SubLudeme (game.functions.region.sites.player.SitesHand) => <equipment.region>, pack=game.functions.region.sites.player, label=sitesHand, cls=game.functions.region.sites.player.SitesHand, keyword=sitesHand, atomic=SitesHand, atomic path=game.functions.region.sites.player.SitesHand
~~~~ <sitesWinning> name=SitesWinning type=SubLudeme (game.functions.region.sites.player.SitesWinning) => <equipment.region>, pack=game.functions.region.sites.player, label=sitesWinning, cls=game.functions.region.sites.player.SitesWinning, keyword=sitesWinning, atomic=SitesWinning, atomic path=game.functions.region.sites.player.SitesWinning
~~~~ <sitesRandom> name=SitesRandom type=SubLudeme (game.functions.region.sites.random.SitesRandom) => <equipment.region>, pack=game.functions.region.sites.random, label=sitesRandom, cls=game.functions.region.sites.random.SitesRandom, keyword=sitesRandom, atomic=SitesRandom, atomic path=game.functions.region.sites.random.SitesRandom
~~~~ <sitesSide> name=SitesSide type=SubLudeme (game.functions.region.sites.side.SitesSide) => <equipment.region>, pack=game.functions.region.sites.side, label=sitesSide, cls=game.functions.region.sites.side.SitesSide, keyword=sitesSide, atomic=SitesSide, atomic path=game.functions.region.sites.side.SitesSide
~~~~ <sitesBoard> name=SitesBoard type=SubLudeme (game.functions.region.sites.simple.SitesBoard) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesBoard, cls=game.functions.region.sites.simple.SitesBoard, keyword=sitesBoard, atomic=SitesBoard, atomic path=game.functions.region.sites.simple.SitesBoard
~~~~ <sitesBottom> name=SitesBottom type=SubLudeme (game.functions.region.sites.simple.SitesBottom) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesBottom, cls=game.functions.region.sites.simple.SitesBottom, keyword=sitesBottom, atomic=SitesBottom, atomic path=game.functions.region.sites.simple.SitesBottom
~~~~ <sitesCentre> name=SitesCentre type=SubLudeme (game.functions.region.sites.simple.SitesCentre) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesCentre, cls=game.functions.region.sites.simple.SitesCentre, keyword=sitesCentre, atomic=SitesCentre, atomic path=game.functions.region.sites.simple.SitesCentre
~~~~ <sitesConcaveCorners> name=SitesConcaveCorners type=SubLudeme (game.functions.region.sites.simple.SitesConcaveCorners) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesConcaveCorners, cls=game.functions.region.sites.simple.SitesConcaveCorners, keyword=sitesConcaveCorners, atomic=SitesConcaveCorners, atomic path=game.functions.region.sites.simple.SitesConcaveCorners
~~~~ <sitesConvexCorners> name=SitesConvexCorners type=SubLudeme (game.functions.region.sites.simple.SitesConvexCorners) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesConvexCorners, cls=game.functions.region.sites.simple.SitesConvexCorners, keyword=sitesConvexCorners, atomic=SitesConvexCorners, atomic path=game.functions.region.sites.simple.SitesConvexCorners
~~~~ <sitesCorners> name=SitesCorners type=SubLudeme (game.functions.region.sites.simple.SitesCorners) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesCorners, cls=game.functions.region.sites.simple.SitesCorners, keyword=sitesCorners, atomic=SitesCorners, atomic path=game.functions.region.sites.simple.SitesCorners
~~~~ <sitesHint> name=SitesHint type=SubLudeme (game.functions.region.sites.simple.SitesHint) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesHint, cls=game.functions.region.sites.simple.SitesHint, keyword=sitesHint, atomic=SitesHint, atomic path=game.functions.region.sites.simple.SitesHint
~~~~ <sitesInner> name=SitesInner type=SubLudeme (game.functions.region.sites.simple.SitesInner) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesInner, cls=game.functions.region.sites.simple.SitesInner, keyword=sitesInner, atomic=SitesInner, atomic path=game.functions.region.sites.simple.SitesInner
~~~~ <sitesLastFrom> name=SitesLastFrom type=SubLudeme (game.functions.region.sites.simple.SitesLastFrom) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesLastFrom, cls=game.functions.region.sites.simple.SitesLastFrom, keyword=sitesLastFrom, atomic=SitesLastFrom, atomic path=game.functions.region.sites.simple.SitesLastFrom
~~~~ <sitesLastTo> name=SitesLastTo type=SubLudeme (game.functions.region.sites.simple.SitesLastTo) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesLastTo, cls=game.functions.region.sites.simple.SitesLastTo, keyword=sitesLastTo, atomic=SitesLastTo, atomic path=game.functions.region.sites.simple.SitesLastTo
~~~~ <sitesLeft> name=SitesLeft type=SubLudeme (game.functions.region.sites.simple.SitesLeft) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesLeft, cls=game.functions.region.sites.simple.SitesLeft, keyword=sitesLeft, atomic=SitesLeft, atomic path=game.functions.region.sites.simple.SitesLeft
~~~~ <sitesLineOfPlay> name=SitesLineOfPlay type=SubLudeme (game.functions.region.sites.simple.SitesLineOfPlay) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesLineOfPlay, cls=game.functions.region.sites.simple.SitesLineOfPlay, keyword=sitesLineOfPlay, atomic=SitesLineOfPlay, atomic path=game.functions.region.sites.simple.SitesLineOfPlay
~~~~ <sitesMajor> name=SitesMajor type=SubLudeme (game.functions.region.sites.simple.SitesMajor) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesMajor, cls=game.functions.region.sites.simple.SitesMajor, keyword=sitesMajor, atomic=SitesMajor, atomic path=game.functions.region.sites.simple.SitesMajor
~~~~ <sitesMinor> name=SitesMinor type=SubLudeme (game.functions.region.sites.simple.SitesMinor) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesMinor, cls=game.functions.region.sites.simple.SitesMinor, keyword=sitesMinor, atomic=SitesMinor, atomic path=game.functions.region.sites.simple.SitesMinor
~~~~ <sitesOuter> name=SitesOuter type=SubLudeme (game.functions.region.sites.simple.SitesOuter) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesOuter, cls=game.functions.region.sites.simple.SitesOuter, keyword=sitesOuter, atomic=SitesOuter, atomic path=game.functions.region.sites.simple.SitesOuter
~~~~ <sitesPending> name=SitesPending type=SubLudeme (game.functions.region.sites.simple.SitesPending) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesPending, cls=game.functions.region.sites.simple.SitesPending, keyword=sitesPending, atomic=SitesPending, atomic path=game.functions.region.sites.simple.SitesPending
~~~~ <sitesPerimeter> name=SitesPerimeter type=SubLudeme (game.functions.region.sites.simple.SitesPerimeter) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesPerimeter, cls=game.functions.region.sites.simple.SitesPerimeter, keyword=sitesPerimeter, atomic=SitesPerimeter, atomic path=game.functions.region.sites.simple.SitesPerimeter
~~~~ <sitesPlayable> name=SitesPlayable type=SubLudeme (game.functions.region.sites.simple.SitesPlayable) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesPlayable, cls=game.functions.region.sites.simple.SitesPlayable, keyword=sitesPlayable, atomic=SitesPlayable, atomic path=game.functions.region.sites.simple.SitesPlayable
~~~~ <sitesRight> name=SitesRight type=SubLudeme (game.functions.region.sites.simple.SitesRight) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesRight, cls=game.functions.region.sites.simple.SitesRight, keyword=sitesRight, atomic=SitesRight, atomic path=game.functions.region.sites.simple.SitesRight
~~~~ <sitesToClear> name=SitesToClear type=SubLudeme (game.functions.region.sites.simple.SitesToClear) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesToClear, cls=game.functions.region.sites.simple.SitesToClear, keyword=sitesToClear, atomic=SitesToClear, atomic path=game.functions.region.sites.simple.SitesToClear
~~~~ <sitesTop> name=SitesTop type=SubLudeme (game.functions.region.sites.simple.SitesTop) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesTop, cls=game.functions.region.sites.simple.SitesTop, keyword=sitesTop, atomic=SitesTop, atomic path=game.functions.region.sites.simple.SitesTop
~~~~ <sitesTrack> name=SitesTrack type=SubLudeme (game.functions.region.sites.track.SitesTrack) => <equipment.region>, pack=game.functions.region.sites.track, label=sitesTrack, cls=game.functions.region.sites.track.SitesTrack, keyword=sitesTrack, atomic=SitesTrack, atomic path=game.functions.region.sites.track.SitesTrack
~~~~ <sitesWalk> name=SitesWalk type=SubLudeme (game.functions.region.sites.walk.SitesWalk) => <equipment.region>, pack=game.functions.region.sites.walk, label=sitesWalk, cls=game.functions.region.sites.walk.SitesWalk, keyword=sitesWalk, atomic=SitesWalk, atomic path=game.functions.region.sites.walk.SitesWalk
~~~* <baseTrackStepFunction> name=BaseTrackStepFunction type=Ludeme (game.functions.trackStep.BaseTrackStepFunction) => <trackStep.trackStep>, pack=game.functions.trackStep, label=baseTrackStepFunction, cls=game.functions.trackStep.BaseTrackStepFunction, keyword=baseTrackStepFunction, atomic=BaseTrackStepFunction, atomic path=game.functions.trackStep.BaseTrackStepFunction
~~~~ <trackStep.trackStep> name=TrackStep type=Ludeme (game.functions.trackStep.TrackStep) => <trackStep.trackStep>, pack=game.functions.trackStep, label=trackStep.trackStep, cls=game.functions.trackStep.TrackStep, keyword=trackStep, atomic=TrackStep, atomic path=game.functions.trackStep.TrackStep
~~~* <trackStepFunction> name=TrackStepFunction type=Structural (game.functions.trackStep.TrackStepFunction) => <trackStep.trackStep>, pack=game.functions.trackStep, label=trackStepFunction, cls=game.functions.trackStep.TrackStepFunction, keyword=trackStepFunction, atomic=TrackStepFunction, atomic path=game.functions.trackStep.TrackStepFunction
gd~~ <games> name=Games type=Ludeme (game.match.Games) => <games>, pack=game.match, label=games, cls=game.match.Games, keyword=games, atomic=Games, atomic path=game.match.Games
gd~~ <match> name=Match type=Ludeme (game.match.Match) => <match>, pack=game.match, label=match, cls=game.match.Match, keyword=match, atomic=Match, atomic path=game.match.Match
gd~~ <subgame> name=Subgame type=Ludeme (game.match.Subgame) => <subgame>, pack=game.match, label=subgame, cls=game.match.Subgame, keyword=subgame, atomic=Subgame, atomic path=game.match.Subgame
gd~~ <mode> name=Mode type=Ludeme (game.mode.Mode) => <mode>, pack=game.mode, label=mode, cls=game.mode.Mode, keyword=mode, atomic=Mode, atomic path=game.mode.Mode
gd~~ <players.player> name=Player type=Ludeme (game.players.Player) => <players.player>, pack=game.players, label=players.player, cls=game.players.Player, keyword=player, atomic=Player, atomic path=game.players.Player
gd~~ <players> name=Players type=Ludeme (game.players.Players) => <players>, pack=game.players, label=players, cls=game.players.Players, keyword=players, atomic=Players, atomic path=game.players.Players
~~~* <rule> name=Rule type=Structural (game.rules.Rule) => <rule>, pack=game.rules, label=rule, cls=game.rules.Rule, keyword=rule, atomic=Rule, atomic path=game.rules.Rule
gd~~ <rules.rules> name=Rules type=Ludeme (game.rules.Rules) => <rules.rules>, pack=game.rules, label=rules.rules, cls=game.rules.Rules, keyword=rules, atomic=Rules, atomic path=game.rules.Rules
~~~~ <baseEndRule> name=BaseEndRule type=Ludeme (game.rules.end.BaseEndRule) => <endRule>, pack=game.rules.end, label=baseEndRule, cls=game.rules.end.BaseEndRule, keyword=baseEndRule, atomic=BaseEndRule, atomic path=game.rules.end.BaseEndRule
gd~~ <byScore> name=ByScore type=Ludeme (game.rules.end.ByScore) => <byScore>, pack=game.rules.end, label=byScore, cls=game.rules.end.ByScore, keyword=byScore, atomic=ByScore, atomic path=game.rules.end.ByScore
gd~~ <end> name=End type=Ludeme (game.rules.end.End) => <end>, pack=game.rules.end, label=end, cls=game.rules.end.End, keyword=end, atomic=End, atomic path=game.rules.end.End
g~~* <endRule> name=EndRule type=Structural (game.rules.end.EndRule) => <endRule>, pack=game.rules.end, label=endRule, cls=game.rules.end.EndRule, keyword=endRule, atomic=EndRule, atomic path=game.rules.end.EndRule
gd~~ <end.forEach> name=ForEach type=Ludeme (game.rules.end.ForEach) => <endRule>, pack=game.rules.end, label=end.forEach, cls=game.rules.end.ForEach, keyword=forEach, atomic=ForEach, atomic path=game.rules.end.ForEach
gd~~ <end.if> name=If type=Ludeme (game.rules.end.If) => <endRule>, pack=game.rules.end, label=end.if, cls=game.rules.end.If, keyword=if, atomic=If, atomic path=game.rules.end.If
gd~~ <payoffs> name=Payoffs type=Ludeme (game.rules.end.Payoffs) => <payoffs>, pack=game.rules.end, label=payoffs, cls=game.rules.end.Payoffs, keyword=payoffs, atomic=Payoffs, atomic path=game.rules.end.Payoffs
gd~~ <result> name=Result type=Ludeme (game.rules.end.Result) => <result>, pack=game.rules.end, label=result, cls=game.rules.end.Result, keyword=result, atomic=Result, atomic path=game.rules.end.Result
gd~~ <automove> name=Automove type=Ludeme (game.rules.meta.Automove) => <automove>, pack=game.rules.meta, label=automove, cls=game.rules.meta.Automove, keyword=automove, atomic=Automove, atomic path=game.rules.meta.Automove
gd~~ <gravity> name=Gravity type=Ludeme (game.rules.meta.Gravity) => <gravity>, pack=game.rules.meta, label=gravity, cls=game.rules.meta.Gravity, keyword=gravity, atomic=Gravity, atomic path=game.rules.meta.Gravity
gd~~ <meta> name=Meta type=Ludeme (game.rules.meta.Meta) => <meta>, pack=game.rules.meta, label=meta, cls=game.rules.meta.Meta, keyword=meta, atomic=Meta, atomic path=game.rules.meta.Meta
g~~* <metaRule> name=MetaRule type=Structural (game.rules.meta.MetaRule) => <metaRule>, pack=game.rules.meta, label=metaRule, cls=game.rules.meta.MetaRule, keyword=metaRule, atomic=MetaRule, atomic path=game.rules.meta.MetaRule
gd~~ <passEnd> name=PassEnd type=Ludeme (game.rules.meta.PassEnd) => <passEnd>, pack=game.rules.meta, label=passEnd, cls=game.rules.meta.PassEnd, keyword=passEnd, atomic=PassEnd, atomic path=game.rules.meta.PassEnd
gd~~ <pin> name=Pin type=Ludeme (game.rules.meta.Pin) => <pin>, pack=game.rules.meta, label=pin, cls=game.rules.meta.Pin, keyword=pin, atomic=Pin, atomic path=game.rules.meta.Pin
gd~~ <meta.swap> name=Swap type=Ludeme (game.rules.meta.Swap) => <meta.swap>, pack=game.rules.meta, label=meta.swap, cls=game.rules.meta.Swap, keyword=swap, atomic=Swap, atomic path=game.rules.meta.Swap
gd~~ <meta.no.no> name=No type=SuperLudeme (game.rules.meta.no.No) => <meta.no.no>, pack=game.rules.meta.no, label=meta.no.no, cls=game.rules.meta.no.No, keyword=no, atomic=No, atomic path=game.rules.meta.no.No
~~~~ <noRepeatType> name=NoRepeatType type=Structural (game.rules.meta.no.NoRepeatType) => <noRepeatType>, pack=game.rules.meta.no, label=noRepeatType, cls=game.rules.meta.no.NoRepeatType, keyword=noRepeatType, atomic=NoRepeatType, atomic path=game.rules.meta.no.NoRepeatType
~~~~ <noSimpleType> name=NoSimpleType type=Structural (game.rules.meta.no.NoSimpleType) => <noSimpleType>, pack=game.rules.meta.no, label=noSimpleType, cls=game.rules.meta.no.NoSimpleType, keyword=noSimpleType, atomic=NoSimpleType, atomic path=game.rules.meta.no.NoSimpleType
~~~~ <noRepeat> name=NoRepeat type=SubLudeme (game.rules.meta.no.repeat.NoRepeat) => <noRepeat>, pack=game.rules.meta.no.repeat, label=noRepeat, cls=game.rules.meta.no.repeat.NoRepeat, keyword=noRepeat, atomic=NoRepeat, atomic path=game.rules.meta.no.repeat.NoRepeat
~~~~ <noSuicide> name=NoSuicide type=SubLudeme (game.rules.meta.no.simple.NoSuicide) => <noSuicide>, pack=game.rules.meta.no.simple, label=noSuicide, cls=game.rules.meta.no.simple.NoSuicide, keyword=noSuicide, atomic=NoSuicide, atomic path=game.rules.meta.no.simple.NoSuicide
gd~~ <nextPhase> name=NextPhase type=Ludeme (game.rules.phase.NextPhase) => <int>, pack=game.rules.phase, label=nextPhase, cls=game.rules.phase.NextPhase, keyword=nextPhase, atomic=NextPhase, atomic path=game.rules.phase.NextPhase
gd~~ <phase.phase> name=Phase type=Ludeme (game.rules.phase.Phase) => <phase.phase>, pack=game.rules.phase, label=phase.phase, cls=game.rules.phase.Phase, keyword=phase, atomic=Phase, atomic path=game.rules.phase.Phase
gd~~ <play> name=Play type=Ludeme (game.rules.play.Play) => <play>, pack=game.rules.play, label=play, cls=game.rules.play.Play, keyword=play, atomic=Play, atomic path=game.rules.play.Play
~~~~ <baseMoves> name=BaseMoves type=Ludeme (game.rules.play.moves.BaseMoves) => <moves>, pack=game.rules.play.moves, label=baseMoves, cls=game.rules.play.moves.BaseMoves, keyword=baseMoves, atomic=BaseMoves, atomic path=game.rules.play.moves.BaseMoves
g~~* <moves> name=Moves type=Structural (game.rules.play.moves.Moves) => <moves>, pack=game.rules.play.moves, label=moves, cls=game.rules.play.moves.Moves, keyword=moves, atomic=Moves, atomic path=game.rules.play.moves.Moves
g~~* <decision> name=Decision type=Structural (game.rules.play.moves.decision.Decision) => <moves>, pack=game.rules.play.moves.decision, label=decision, cls=game.rules.play.moves.decision.Decision, keyword=decision, atomic=Decision, atomic path=game.rules.play.moves.decision.Decision
gd~~ <move> name=Move type=SuperLudeme (game.rules.play.moves.decision.Move) => <moves>, pack=game.rules.play.moves.decision, label=move, cls=game.rules.play.moves.decision.Move, keyword=move, atomic=Move, atomic path=game.rules.play.moves.decision.Move
~~~~ <moveBetType> name=MoveBetType type=Structural (game.rules.play.moves.decision.MoveBetType) => <moveBetType>, pack=game.rules.play.moves.decision, label=moveBetType, cls=game.rules.play.moves.decision.MoveBetType, keyword=moveBetType, atomic=MoveBetType, atomic path=game.rules.play.moves.decision.MoveBetType
~~~~ <moveFromToType> name=MoveFromToType type=Structural (game.rules.play.moves.decision.MoveFromToType) => <moveFromToType>, pack=game.rules.play.moves.decision, label=moveFromToType, cls=game.rules.play.moves.decision.MoveFromToType, keyword=moveFromToType, atomic=MoveFromToType, atomic path=game.rules.play.moves.decision.MoveFromToType
~~~~ <moveHopType> name=MoveHopType type=Structural (game.rules.play.moves.decision.MoveHopType) => <moveHopType>, pack=game.rules.play.moves.decision, label=moveHopType, cls=game.rules.play.moves.decision.MoveHopType, keyword=moveHopType, atomic=MoveHopType, atomic path=game.rules.play.moves.decision.MoveHopType
~~~~ <moveLeapType> name=MoveLeapType type=Structural (game.rules.play.moves.decision.MoveLeapType) => <moveLeapType>, pack=game.rules.play.moves.decision, label=moveLeapType, cls=game.rules.play.moves.decision.MoveLeapType, keyword=moveLeapType, atomic=MoveLeapType, atomic path=game.rules.play.moves.decision.MoveLeapType
g~~~ <moveMessageType> name=MoveMessageType type=Structural (game.rules.play.moves.decision.MoveMessageType) => <moveMessageType>, pack=game.rules.play.moves.decision, label=moveMessageType, cls=game.rules.play.moves.decision.MoveMessageType, keyword=moveMessageType, atomic=MoveMessageType, atomic path=game.rules.play.moves.decision.MoveMessageType
~~~~ <movePromoteType> name=MovePromoteType type=Structural (game.rules.play.moves.decision.MovePromoteType) => <movePromoteType>, pack=game.rules.play.moves.decision, label=movePromoteType, cls=game.rules.play.moves.decision.MovePromoteType, keyword=movePromoteType, atomic=MovePromoteType, atomic path=game.rules.play.moves.decision.MovePromoteType
~~~~ <moveRemoveType> name=MoveRemoveType type=Structural (game.rules.play.moves.decision.MoveRemoveType) => <moveRemoveType>, pack=game.rules.play.moves.decision, label=moveRemoveType, cls=game.rules.play.moves.decision.MoveRemoveType, keyword=moveRemoveType, atomic=MoveRemoveType, atomic path=game.rules.play.moves.decision.MoveRemoveType
~~~~ <moveSelectType> name=MoveSelectType type=Structural (game.rules.play.moves.decision.MoveSelectType) => <moveSelectType>, pack=game.rules.play.moves.decision, label=moveSelectType, cls=game.rules.play.moves.decision.MoveSelectType, keyword=moveSelectType, atomic=MoveSelectType, atomic path=game.rules.play.moves.decision.MoveSelectType
~~~~ <moveSetType> name=MoveSetType type=Structural (game.rules.play.moves.decision.MoveSetType) => <moveSetType>, pack=game.rules.play.moves.decision, label=moveSetType, cls=game.rules.play.moves.decision.MoveSetType, keyword=moveSetType, atomic=MoveSetType, atomic path=game.rules.play.moves.decision.MoveSetType
~~~~ <moveShootType> name=MoveShootType type=Structural (game.rules.play.moves.decision.MoveShootType) => <moveShootType>, pack=game.rules.play.moves.decision, label=moveShootType, cls=game.rules.play.moves.decision.MoveShootType, keyword=moveShootType, atomic=MoveShootType, atomic path=game.rules.play.moves.decision.MoveShootType
g~~~ <moveSimpleType> name=MoveSimpleType type=Structural (game.rules.play.moves.decision.MoveSimpleType) => <moveSimpleType>, pack=game.rules.play.moves.decision, label=moveSimpleType, cls=game.rules.play.moves.decision.MoveSimpleType, keyword=moveSimpleType, atomic=MoveSimpleType, atomic path=game.rules.play.moves.decision.MoveSimpleType
g~~~ <moveSiteType> name=MoveSiteType type=Structural (game.rules.play.moves.decision.MoveSiteType) => <moveSiteType>, pack=game.rules.play.moves.decision, label=moveSiteType, cls=game.rules.play.moves.decision.MoveSiteType, keyword=moveSiteType, atomic=MoveSiteType, atomic path=game.rules.play.moves.decision.MoveSiteType
~~~~ <moveSlideType> name=MoveSlideType type=Structural (game.rules.play.moves.decision.MoveSlideType) => <moveSlideType>, pack=game.rules.play.moves.decision, label=moveSlideType, cls=game.rules.play.moves.decision.MoveSlideType, keyword=moveSlideType, atomic=MoveSlideType, atomic path=game.rules.play.moves.decision.MoveSlideType
~~~~ <moveStepType> name=MoveStepType type=Structural (game.rules.play.moves.decision.MoveStepType) => <moveStepType>, pack=game.rules.play.moves.decision, label=moveStepType, cls=game.rules.play.moves.decision.MoveStepType, keyword=moveStepType, atomic=MoveStepType, atomic path=game.rules.play.moves.decision.MoveStepType
~~~~ <moveSwapType> name=MoveSwapType type=Structural (game.rules.play.moves.decision.MoveSwapType) => <moveSwapType>, pack=game.rules.play.moves.decision, label=moveSwapType, cls=game.rules.play.moves.decision.MoveSwapType, keyword=moveSwapType, atomic=MoveSwapType, atomic path=game.rules.play.moves.decision.MoveSwapType
g~~* <nonDecision> name=NonDecision type=Structural (game.rules.play.moves.nonDecision.NonDecision) => <moves>, pack=game.rules.play.moves.nonDecision, label=nonDecision, cls=game.rules.play.moves.nonDecision.NonDecision, keyword=nonDecision, atomic=NonDecision, atomic path=game.rules.play.moves.nonDecision.NonDecision
gd~~ <effect.add> name=Add type=Ludeme (game.rules.play.moves.nonDecision.effect.Add) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=effect.add, cls=game.rules.play.moves.nonDecision.effect.Add, keyword=add, atomic=Add, atomic path=game.rules.play.moves.nonDecision.effect.Add
gd~~ <apply> name=Apply type=Ludeme (game.rules.play.moves.nonDecision.effect.Apply) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=apply, cls=game.rules.play.moves.nonDecision.effect.Apply, keyword=apply, atomic=Apply, atomic path=game.rules.play.moves.nonDecision.effect.Apply
gd~~ <attract> name=Attract type=Ludeme (game.rules.play.moves.nonDecision.effect.Attract) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=attract, cls=game.rules.play.moves.nonDecision.effect.Attract, keyword=attract, atomic=Attract, atomic path=game.rules.play.moves.nonDecision.effect.Attract
gd~~ <bet> name=Bet type=Ludeme (game.rules.play.moves.nonDecision.effect.Bet) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=bet, cls=game.rules.play.moves.nonDecision.effect.Bet, keyword=bet, atomic=Bet, atomic path=game.rules.play.moves.nonDecision.effect.Bet
gd~~ <claim> name=Claim type=Ludeme (game.rules.play.moves.nonDecision.effect.Claim) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=claim, cls=game.rules.play.moves.nonDecision.effect.Claim, keyword=claim, atomic=Claim, atomic path=game.rules.play.moves.nonDecision.effect.Claim
gd~~ <custodial> name=Custodial type=Ludeme (game.rules.play.moves.nonDecision.effect.Custodial) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=custodial, cls=game.rules.play.moves.nonDecision.effect.Custodial, keyword=custodial, atomic=Custodial, atomic path=game.rules.play.moves.nonDecision.effect.Custodial
gd~~ <effect.deal> name=Deal type=Ludeme (game.rules.play.moves.nonDecision.effect.Deal) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=effect.deal, cls=game.rules.play.moves.nonDecision.effect.Deal, keyword=deal, atomic=Deal, atomic path=game.rules.play.moves.nonDecision.effect.Deal
gd~~ <directional> name=Directional type=Ludeme (game.rules.play.moves.nonDecision.effect.Directional) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=directional, cls=game.rules.play.moves.nonDecision.effect.Directional, keyword=directional, atomic=Directional, atomic path=game.rules.play.moves.nonDecision.effect.Directional
g~~* <effect> name=Effect type=Structural (game.rules.play.moves.nonDecision.effect.Effect) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=effect, cls=game.rules.play.moves.nonDecision.effect.Effect, keyword=effect, atomic=Effect, atomic path=game.rules.play.moves.nonDecision.effect.Effect
gd~~ <enclose> name=Enclose type=Ludeme (game.rules.play.moves.nonDecision.effect.Enclose) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=enclose, cls=game.rules.play.moves.nonDecision.effect.Enclose, keyword=enclose, atomic=Enclose, atomic path=game.rules.play.moves.nonDecision.effect.Enclose
gd~~ <flip> name=Flip type=Ludeme (game.rules.play.moves.nonDecision.effect.Flip) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=flip, cls=game.rules.play.moves.nonDecision.effect.Flip, keyword=flip, atomic=Flip, atomic path=game.rules.play.moves.nonDecision.effect.Flip
gd~~ <fromTo> name=FromTo type=Ludeme (game.rules.play.moves.nonDecision.effect.FromTo) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=fromTo, cls=game.rules.play.moves.nonDecision.effect.FromTo, keyword=fromTo, atomic=FromTo, atomic path=game.rules.play.moves.nonDecision.effect.FromTo
gd~~ <hop> name=Hop type=Ludeme (game.rules.play.moves.nonDecision.effect.Hop) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=hop, cls=game.rules.play.moves.nonDecision.effect.Hop, keyword=hop, atomic=Hop, atomic path=game.rules.play.moves.nonDecision.effect.Hop
gd~~ <intervene> name=Intervene type=Ludeme (game.rules.play.moves.nonDecision.effect.Intervene) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=intervene, cls=game.rules.play.moves.nonDecision.effect.Intervene, keyword=intervene, atomic=Intervene, atomic path=game.rules.play.moves.nonDecision.effect.Intervene
gd~~ <leap> name=Leap type=Ludeme (game.rules.play.moves.nonDecision.effect.Leap) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=leap, cls=game.rules.play.moves.nonDecision.effect.Leap, keyword=leap, atomic=Leap, atomic path=game.rules.play.moves.nonDecision.effect.Leap
gd~~ <note> name=Note type=Ludeme (game.rules.play.moves.nonDecision.effect.Note) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=note, cls=game.rules.play.moves.nonDecision.effect.Note, keyword=note, atomic=Note, atomic path=game.rules.play.moves.nonDecision.effect.Note
gd~~ <pass> name=Pass type=Ludeme (game.rules.play.moves.nonDecision.effect.Pass) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=pass, cls=game.rules.play.moves.nonDecision.effect.Pass, keyword=pass, atomic=Pass, atomic path=game.rules.play.moves.nonDecision.effect.Pass
gd~~ <playCard> name=PlayCard type=Ludeme (game.rules.play.moves.nonDecision.effect.PlayCard) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=playCard, cls=game.rules.play.moves.nonDecision.effect.PlayCard, keyword=playCard, atomic=PlayCard, atomic path=game.rules.play.moves.nonDecision.effect.PlayCard
gd~~ <promote> name=Promote type=Ludeme (game.rules.play.moves.nonDecision.effect.Promote) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=promote, cls=game.rules.play.moves.nonDecision.effect.Promote, keyword=promote, atomic=Promote, atomic path=game.rules.play.moves.nonDecision.effect.Promote
gd~~ <propose> name=Propose type=Ludeme (game.rules.play.moves.nonDecision.effect.Propose) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=propose, cls=game.rules.play.moves.nonDecision.effect.Propose, keyword=propose, atomic=Propose, atomic path=game.rules.play.moves.nonDecision.effect.Propose
gd~~ <push> name=Push type=Ludeme (game.rules.play.moves.nonDecision.effect.Push) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=push, cls=game.rules.play.moves.nonDecision.effect.Push, keyword=push, atomic=Push, atomic path=game.rules.play.moves.nonDecision.effect.Push
gd~~ <random> name=Random type=Ludeme (game.rules.play.moves.nonDecision.effect.Random) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=random, cls=game.rules.play.moves.nonDecision.effect.Random, keyword=random, atomic=Random, atomic path=game.rules.play.moves.nonDecision.effect.Random
gd~~ <effect.remove> name=Remove type=Ludeme (game.rules.play.moves.nonDecision.effect.Remove) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=effect.remove, cls=game.rules.play.moves.nonDecision.effect.Remove, keyword=remove, atomic=Remove, atomic path=game.rules.play.moves.nonDecision.effect.Remove
gd~~ <roll> name=Roll type=Ludeme (game.rules.play.moves.nonDecision.effect.Roll) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=roll, cls=game.rules.play.moves.nonDecision.effect.Roll, keyword=roll, atomic=Roll, atomic path=game.rules.play.moves.nonDecision.effect.Roll
gd~~ <satisfy> name=Satisfy type=Ludeme (game.rules.play.moves.nonDecision.effect.Satisfy) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=satisfy, cls=game.rules.play.moves.nonDecision.effect.Satisfy, keyword=satisfy, atomic=Satisfy, atomic path=game.rules.play.moves.nonDecision.effect.Satisfy
gd~~ <select> name=Select type=Ludeme (game.rules.play.moves.nonDecision.effect.Select) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=select, cls=game.rules.play.moves.nonDecision.effect.Select, keyword=select, atomic=Select, atomic path=game.rules.play.moves.nonDecision.effect.Select
gd~~ <shoot> name=Shoot type=Ludeme (game.rules.play.moves.nonDecision.effect.Shoot) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=shoot, cls=game.rules.play.moves.nonDecision.effect.Shoot, keyword=shoot, atomic=Shoot, atomic path=game.rules.play.moves.nonDecision.effect.Shoot
gd~~ <slide> name=Slide type=Ludeme (game.rules.play.moves.nonDecision.effect.Slide) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=slide, cls=game.rules.play.moves.nonDecision.effect.Slide, keyword=slide, atomic=Slide, atomic path=game.rules.play.moves.nonDecision.effect.Slide
gd~~ <sow> name=Sow type=Ludeme (game.rules.play.moves.nonDecision.effect.Sow) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=sow, cls=game.rules.play.moves.nonDecision.effect.Sow, keyword=sow, atomic=Sow, atomic path=game.rules.play.moves.nonDecision.effect.Sow
gd~~ <effect.step> name=Step type=Ludeme (game.rules.play.moves.nonDecision.effect.Step) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=effect.step, cls=game.rules.play.moves.nonDecision.effect.Step, keyword=step, atomic=Step, atomic path=game.rules.play.moves.nonDecision.effect.Step
gd~~ <surround> name=Surround type=Ludeme (game.rules.play.moves.nonDecision.effect.Surround) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=surround, cls=game.rules.play.moves.nonDecision.effect.Surround, keyword=surround, atomic=Surround, atomic path=game.rules.play.moves.nonDecision.effect.Surround
gd~~ <then> name=Then type=Ludeme (game.rules.play.moves.nonDecision.effect.Then) => <then>, pack=game.rules.play.moves.nonDecision.effect, label=then, cls=game.rules.play.moves.nonDecision.effect.Then, keyword=then, atomic=Then, atomic path=game.rules.play.moves.nonDecision.effect.Then
gd~~ <trigger> name=Trigger type=Ludeme (game.rules.play.moves.nonDecision.effect.Trigger) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=trigger, cls=game.rules.play.moves.nonDecision.effect.Trigger, keyword=trigger, atomic=Trigger, atomic path=game.rules.play.moves.nonDecision.effect.Trigger
gd~~ <vote> name=Vote type=Ludeme (game.rules.play.moves.nonDecision.effect.Vote) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=vote, cls=game.rules.play.moves.nonDecision.effect.Vote, keyword=vote, atomic=Vote, atomic path=game.rules.play.moves.nonDecision.effect.Vote
gd~~ <avoidStoredState> name=AvoidStoredState type=Ludeme (game.rules.play.moves.nonDecision.effect.requirement.AvoidStoredState) => <moves>, pack=game.rules.play.moves.nonDecision.effect.requirement, label=avoidStoredState, cls=game.rules.play.moves.nonDecision.effect.requirement.AvoidStoredState, keyword=avoidStoredState, atomic=AvoidStoredState, atomic path=game.rules.play.moves.nonDecision.effect.requirement.AvoidStoredState
gd~~ <do> name=Do type=Ludeme (game.rules.play.moves.nonDecision.effect.requirement.Do) => <moves>, pack=game.rules.play.moves.nonDecision.effect.requirement, label=do, cls=game.rules.play.moves.nonDecision.effect.requirement.Do, keyword=do, atomic=Do, atomic path=game.rules.play.moves.nonDecision.effect.requirement.Do
gd~~ <firstMoveOnTrack> name=FirstMoveOnTrack type=Ludeme (game.rules.play.moves.nonDecision.effect.requirement.FirstMoveOnTrack) => <moves>, pack=game.rules.play.moves.nonDecision.effect.requirement, label=firstMoveOnTrack, cls=game.rules.play.moves.nonDecision.effect.requirement.FirstMoveOnTrack, keyword=firstMoveOnTrack, atomic=FirstMoveOnTrack, atomic path=game.rules.play.moves.nonDecision.effect.requirement.FirstMoveOnTrack
gd~~ <priority> name=Priority type=Ludeme (game.rules.play.moves.nonDecision.effect.requirement.Priority) => <moves>, pack=game.rules.play.moves.nonDecision.effect.requirement, label=priority, cls=game.rules.play.moves.nonDecision.effect.requirement.Priority, keyword=priority, atomic=Priority, atomic path=game.rules.play.moves.nonDecision.effect.requirement.Priority
gd~~ <while> name=While type=Ludeme (game.rules.play.moves.nonDecision.effect.requirement.While) => <moves>, pack=game.rules.play.moves.nonDecision.effect.requirement, label=while, cls=game.rules.play.moves.nonDecision.effect.requirement.While, keyword=while, atomic=While, atomic path=game.rules.play.moves.nonDecision.effect.requirement.While
gd~~ <max.max> name=Max type=SuperLudeme (game.rules.play.moves.nonDecision.effect.requirement.max.Max) => <moves>, pack=game.rules.play.moves.nonDecision.effect.requirement.max, label=max.max, cls=game.rules.play.moves.nonDecision.effect.requirement.max.Max, keyword=max, atomic=Max, atomic path=game.rules.play.moves.nonDecision.effect.requirement.max.Max
~~~~ <maxDistanceType> name=MaxDistanceType type=Structural (game.rules.play.moves.nonDecision.effect.requirement.max.MaxDistanceType) => <maxDistanceType>, pack=game.rules.play.moves.nonDecision.effect.requirement.max, label=maxDistanceType, cls=game.rules.play.moves.nonDecision.effect.requirement.max.MaxDistanceType, keyword=maxDistanceType, atomic=MaxDistanceType, atomic path=game.rules.play.moves.nonDecision.effect.requirement.max.MaxDistanceType
g~~~ <maxMovesType> name=MaxMovesType type=Structural (game.rules.play.moves.nonDecision.effect.requirement.max.MaxMovesType) => <maxMovesType>, pack=game.rules.play.moves.nonDecision.effect.requirement.max, label=maxMovesType, cls=game.rules.play.moves.nonDecision.effect.requirement.max.MaxMovesType, keyword=maxMovesType, atomic=MaxMovesType, atomic path=game.rules.play.moves.nonDecision.effect.requirement.max.MaxMovesType
~~~~ <maxDistance> name=MaxDistance type=SubLudeme (game.rules.play.moves.nonDecision.effect.requirement.max.distance.MaxDistance) => <moves>, pack=game.rules.play.moves.nonDecision.effect.requirement.max.distance, label=maxDistance, cls=game.rules.play.moves.nonDecision.effect.requirement.max.distance.MaxDistance, keyword=maxDistance, atomic=MaxDistance, atomic path=game.rules.play.moves.nonDecision.effect.requirement.max.distance.MaxDistance
~~~~ <maxCaptures> name=MaxCaptures type=SubLudeme (game.rules.play.moves.nonDecision.effect.requirement.max.moves.MaxCaptures) => <moves>, pack=game.rules.play.moves.nonDecision.effect.requirement.max.moves, label=maxCaptures, cls=game.rules.play.moves.nonDecision.effect.requirement.max.moves.MaxCaptures, keyword=maxCaptures, atomic=MaxCaptures, atomic path=game.rules.play.moves.nonDecision.effect.requirement.max.moves.MaxCaptures
~~~~ <maxMoves> name=MaxMoves type=SubLudeme (game.rules.play.moves.nonDecision.effect.requirement.max.moves.MaxMoves) => <moves>, pack=game.rules.play.moves.nonDecision.effect.requirement.max.moves, label=maxMoves, cls=game.rules.play.moves.nonDecision.effect.requirement.max.moves.MaxMoves, keyword=maxMoves, atomic=MaxMoves, atomic path=game.rules.play.moves.nonDecision.effect.requirement.max.moves.MaxMoves
gd~~ <effect.set.set> name=Set type=SuperLudeme (game.rules.play.moves.nonDecision.effect.set.Set) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set, label=effect.set.set, cls=game.rules.play.moves.nonDecision.effect.set.Set, keyword=set, atomic=Set, atomic path=game.rules.play.moves.nonDecision.effect.set.Set
~~~~ <setHiddenType> name=SetHiddenType type=Structural (game.rules.play.moves.nonDecision.effect.set.SetHiddenType) => <setHiddenType>, pack=game.rules.play.moves.nonDecision.effect.set, label=setHiddenType, cls=game.rules.play.moves.nonDecision.effect.set.SetHiddenType, keyword=setHiddenType, atomic=SetHiddenType, atomic path=game.rules.play.moves.nonDecision.effect.set.SetHiddenType
~~~~ <setNextPlayerType> name=SetNextPlayerType type=Structural (game.rules.play.moves.nonDecision.effect.set.SetNextPlayerType) => <setNextPlayerType>, pack=game.rules.play.moves.nonDecision.effect.set, label=setNextPlayerType, cls=game.rules.play.moves.nonDecision.effect.set.SetNextPlayerType, keyword=setNextPlayerType, atomic=SetNextPlayerType, atomic path=game.rules.play.moves.nonDecision.effect.set.SetNextPlayerType
~~~~ <setPendingType> name=SetPendingType type=Structural (game.rules.play.moves.nonDecision.effect.set.SetPendingType) => <setPendingType>, pack=game.rules.play.moves.nonDecision.effect.set, label=setPendingType, cls=game.rules.play.moves.nonDecision.effect.set.SetPendingType, keyword=setPendingType, atomic=SetPendingType, atomic path=game.rules.play.moves.nonDecision.effect.set.SetPendingType
g~~~ <setPlayerType> name=SetPlayerType type=Structural (game.rules.play.moves.nonDecision.effect.set.SetPlayerType) => <setPlayerType>, pack=game.rules.play.moves.nonDecision.effect.set, label=setPlayerType, cls=game.rules.play.moves.nonDecision.effect.set.SetPlayerType, keyword=setPlayerType, atomic=SetPlayerType, atomic path=game.rules.play.moves.nonDecision.effect.set.SetPlayerType
~~~~ <setRotationType> name=SetRotationType type=Structural (game.rules.play.moves.nonDecision.effect.set.SetRotationType) => <setRotationType>, pack=game.rules.play.moves.nonDecision.effect.set, label=setRotationType, cls=game.rules.play.moves.nonDecision.effect.set.SetRotationType, keyword=setRotationType, atomic=SetRotationType, atomic path=game.rules.play.moves.nonDecision.effect.set.SetRotationType
g~~~ <setSiteType> name=SetSiteType type=Structural (game.rules.play.moves.nonDecision.effect.set.SetSiteType) => <setSiteType>, pack=game.rules.play.moves.nonDecision.effect.set, label=setSiteType, cls=game.rules.play.moves.nonDecision.effect.set.SetSiteType, keyword=setSiteType, atomic=SetSiteType, atomic path=game.rules.play.moves.nonDecision.effect.set.SetSiteType
~~~~ <setTeamType> name=SetTeamType type=Structural (game.rules.play.moves.nonDecision.effect.set.SetTeamType) => <setTeamType>, pack=game.rules.play.moves.nonDecision.effect.set, label=setTeamType, cls=game.rules.play.moves.nonDecision.effect.set.SetTeamType, keyword=setTeamType, atomic=SetTeamType, atomic path=game.rules.play.moves.nonDecision.effect.set.SetTeamType
~~~~ <setTrumpType> name=SetTrumpType type=Structural (game.rules.play.moves.nonDecision.effect.set.SetTrumpType) => <setTrumpType>, pack=game.rules.play.moves.nonDecision.effect.set, label=setTrumpType, cls=game.rules.play.moves.nonDecision.effect.set.SetTrumpType, keyword=setTrumpType, atomic=SetTrumpType, atomic path=game.rules.play.moves.nonDecision.effect.set.SetTrumpType
g~~~ <setValueType> name=SetValueType type=Structural (game.rules.play.moves.nonDecision.effect.set.SetValueType) => <setValueType>, pack=game.rules.play.moves.nonDecision.effect.set, label=setValueType, cls=game.rules.play.moves.nonDecision.effect.set.SetValueType, keyword=setValueType, atomic=SetValueType, atomic path=game.rules.play.moves.nonDecision.effect.set.SetValueType
~~~~ <setVarType> name=SetVarType type=Structural (game.rules.play.moves.nonDecision.effect.set.SetVarType) => <setVarType>, pack=game.rules.play.moves.nonDecision.effect.set, label=setVarType, cls=game.rules.play.moves.nonDecision.effect.set.SetVarType, keyword=setVarType, atomic=SetVarType, atomic path=game.rules.play.moves.nonDecision.effect.set.SetVarType
~~~~ <setRotation> name=SetRotation type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.direction.SetRotation) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.direction, label=setRotation, cls=game.rules.play.moves.nonDecision.effect.set.direction.SetRotation, keyword=setRotation, atomic=SetRotation, atomic path=game.rules.play.moves.nonDecision.effect.set.direction.SetRotation
~~~~ <effect.set.hidden.setHidden> name=SetHidden type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.hidden.SetHidden) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.hidden, label=effect.set.hidden.setHidden, cls=game.rules.play.moves.nonDecision.effect.set.hidden.SetHidden, keyword=setHidden, atomic=SetHidden, atomic path=game.rules.play.moves.nonDecision.effect.set.hidden.SetHidden
~~~~ <setNextPlayer> name=SetNextPlayer type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.nextPlayer.SetNextPlayer) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.nextPlayer, label=setNextPlayer, cls=game.rules.play.moves.nonDecision.effect.set.nextPlayer.SetNextPlayer, keyword=setNextPlayer, atomic=SetNextPlayer, atomic path=game.rules.play.moves.nonDecision.effect.set.nextPlayer.SetNextPlayer
~~~~ <setPending> name=SetPending type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.pending.SetPending) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.pending, label=setPending, cls=game.rules.play.moves.nonDecision.effect.set.pending.SetPending, keyword=setPending, atomic=SetPending, atomic path=game.rules.play.moves.nonDecision.effect.set.pending.SetPending
~~~~ <effect.set.player.setScore> name=SetScore type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.player.SetScore) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.player, label=effect.set.player.setScore, cls=game.rules.play.moves.nonDecision.effect.set.player.SetScore, keyword=setScore, atomic=SetScore, atomic path=game.rules.play.moves.nonDecision.effect.set.player.SetScore
~~~~ <setValuePlayer> name=SetValuePlayer type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.player.SetValuePlayer) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.player, label=setValuePlayer, cls=game.rules.play.moves.nonDecision.effect.set.player.SetValuePlayer, keyword=setValuePlayer, atomic=SetValuePlayer, atomic path=game.rules.play.moves.nonDecision.effect.set.player.SetValuePlayer
~~~~ <site.setCount> name=SetCount type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.site.SetCount) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.site, label=site.setCount, cls=game.rules.play.moves.nonDecision.effect.set.site.SetCount, keyword=setCount, atomic=SetCount, atomic path=game.rules.play.moves.nonDecision.effect.set.site.SetCount
~~~~ <setState> name=SetState type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.site.SetState) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.site, label=setState, cls=game.rules.play.moves.nonDecision.effect.set.site.SetState, keyword=setState, atomic=SetState, atomic path=game.rules.play.moves.nonDecision.effect.set.site.SetState
~~~~ <setValue> name=SetValue type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.site.SetValue) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.site, label=setValue, cls=game.rules.play.moves.nonDecision.effect.set.site.SetValue, keyword=setValue, atomic=SetValue, atomic path=game.rules.play.moves.nonDecision.effect.set.site.SetValue
~~~~ <setTrumpSuit> name=SetTrumpSuit type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.suit.SetTrumpSuit) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.suit, label=setTrumpSuit, cls=game.rules.play.moves.nonDecision.effect.set.suit.SetTrumpSuit, keyword=setTrumpSuit, atomic=SetTrumpSuit, atomic path=game.rules.play.moves.nonDecision.effect.set.suit.SetTrumpSuit
~~~~ <team.setTeam> name=SetTeam type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.team.SetTeam) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.team, label=team.setTeam, cls=game.rules.play.moves.nonDecision.effect.set.team.SetTeam, keyword=setTeam, atomic=SetTeam, atomic path=game.rules.play.moves.nonDecision.effect.set.team.SetTeam
~~~~ <setCounter> name=SetCounter type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.value.SetCounter) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.value, label=setCounter, cls=game.rules.play.moves.nonDecision.effect.set.value.SetCounter, keyword=setCounter, atomic=SetCounter, atomic path=game.rules.play.moves.nonDecision.effect.set.value.SetCounter
~~~~ <setPot> name=SetPot type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.value.SetPot) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.value, label=setPot, cls=game.rules.play.moves.nonDecision.effect.set.value.SetPot, keyword=setPot, atomic=SetPot, atomic path=game.rules.play.moves.nonDecision.effect.set.value.SetPot
~~~~ <setVar> name=SetVar type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.var.SetVar) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.var, label=setVar, cls=game.rules.play.moves.nonDecision.effect.set.var.SetVar, keyword=setVar, atomic=SetVar, atomic path=game.rules.play.moves.nonDecision.effect.set.var.SetVar
gd~~ <addScore> name=AddScore type=Ludeme (game.rules.play.moves.nonDecision.effect.state.AddScore) => <moves>, pack=game.rules.play.moves.nonDecision.effect.state, label=addScore, cls=game.rules.play.moves.nonDecision.effect.state.AddScore, keyword=addScore, atomic=AddScore, atomic path=game.rules.play.moves.nonDecision.effect.state.AddScore
gd~~ <moveAgain> name=MoveAgain type=Ludeme (game.rules.play.moves.nonDecision.effect.state.MoveAgain) => <moves>, pack=game.rules.play.moves.nonDecision.effect.state, label=moveAgain, cls=game.rules.play.moves.nonDecision.effect.state.MoveAgain, keyword=moveAgain, atomic=MoveAgain, atomic path=game.rules.play.moves.nonDecision.effect.state.MoveAgain
gd~~ <forget> name=Forget type=SuperLudeme (game.rules.play.moves.nonDecision.effect.state.forget.Forget) => <moves>, pack=game.rules.play.moves.nonDecision.effect.state.forget, label=forget, cls=game.rules.play.moves.nonDecision.effect.state.forget.Forget, keyword=forget, atomic=Forget, atomic path=game.rules.play.moves.nonDecision.effect.state.forget.Forget
~~~~ <forgetValueAllType> name=ForgetValueAllType type=Structural (game.rules.play.moves.nonDecision.effect.state.forget.ForgetValueAllType) => <forgetValueAllType>, pack=game.rules.play.moves.nonDecision.effect.state.forget, label=forgetValueAllType, cls=game.rules.play.moves.nonDecision.effect.state.forget.ForgetValueAllType, keyword=forgetValueAllType, atomic=ForgetValueAllType, atomic path=game.rules.play.moves.nonDecision.effect.state.forget.ForgetValueAllType
~~~~ <forgetValueType> name=ForgetValueType type=Structural (game.rules.play.moves.nonDecision.effect.state.forget.ForgetValueType) => <forgetValueType>, pack=game.rules.play.moves.nonDecision.effect.state.forget, label=forgetValueType, cls=game.rules.play.moves.nonDecision.effect.state.forget.ForgetValueType, keyword=forgetValueType, atomic=ForgetValueType, atomic path=game.rules.play.moves.nonDecision.effect.state.forget.ForgetValueType
~~~~ <forgetValue> name=ForgetValue type=SubLudeme (game.rules.play.moves.nonDecision.effect.state.forget.value.ForgetValue) => <moves>, pack=game.rules.play.moves.nonDecision.effect.state.forget.value, label=forgetValue, cls=game.rules.play.moves.nonDecision.effect.state.forget.value.ForgetValue, keyword=forgetValue, atomic=ForgetValue, atomic path=game.rules.play.moves.nonDecision.effect.state.forget.value.ForgetValue
~~~~ <forgetValueAll> name=ForgetValueAll type=SubLudeme (game.rules.play.moves.nonDecision.effect.state.forget.value.ForgetValueAll) => <moves>, pack=game.rules.play.moves.nonDecision.effect.state.forget.value, label=forgetValueAll, cls=game.rules.play.moves.nonDecision.effect.state.forget.value.ForgetValueAll, keyword=forgetValueAll, atomic=ForgetValueAll, atomic path=game.rules.play.moves.nonDecision.effect.state.forget.value.ForgetValueAll
gd~~ <remember> name=Remember type=SuperLudeme (game.rules.play.moves.nonDecision.effect.state.remember.Remember) => <moves>, pack=game.rules.play.moves.nonDecision.effect.state.remember, label=remember, cls=game.rules.play.moves.nonDecision.effect.state.remember.Remember, keyword=remember, atomic=Remember, atomic path=game.rules.play.moves.nonDecision.effect.state.remember.Remember
~~~~ <rememberStateType> name=RememberStateType type=Structural (game.rules.play.moves.nonDecision.effect.state.remember.RememberStateType) => <rememberStateType>, pack=game.rules.play.moves.nonDecision.effect.state.remember, label=rememberStateType, cls=game.rules.play.moves.nonDecision.effect.state.remember.RememberStateType, keyword=rememberStateType, atomic=RememberStateType, atomic path=game.rules.play.moves.nonDecision.effect.state.remember.RememberStateType
~~~~ <rememberValueType> name=RememberValueType type=Structural (game.rules.play.moves.nonDecision.effect.state.remember.RememberValueType) => <rememberValueType>, pack=game.rules.play.moves.nonDecision.effect.state.remember, label=rememberValueType, cls=game.rules.play.moves.nonDecision.effect.state.remember.RememberValueType, keyword=rememberValueType, atomic=RememberValueType, atomic path=game.rules.play.moves.nonDecision.effect.state.remember.RememberValueType
~~~~ <rememberState> name=RememberState type=SubLudeme (game.rules.play.moves.nonDecision.effect.state.remember.state.RememberState) => <moves>, pack=game.rules.play.moves.nonDecision.effect.state.remember.state, label=rememberState, cls=game.rules.play.moves.nonDecision.effect.state.remember.state.RememberState, keyword=rememberState, atomic=RememberState, atomic path=game.rules.play.moves.nonDecision.effect.state.remember.state.RememberState
~~~~ <rememberValue> name=RememberValue type=SubLudeme (game.rules.play.moves.nonDecision.effect.state.remember.value.RememberValue) => <moves>, pack=game.rules.play.moves.nonDecision.effect.state.remember.value, label=rememberValue, cls=game.rules.play.moves.nonDecision.effect.state.remember.value.RememberValue, keyword=rememberValue, atomic=RememberValue, atomic path=game.rules.play.moves.nonDecision.effect.state.remember.value.RememberValue
gd~~ <swap.swap> name=Swap type=SuperLudeme (game.rules.play.moves.nonDecision.effect.state.swap.Swap) => <moves>, pack=game.rules.play.moves.nonDecision.effect.state.swap, label=swap.swap, cls=game.rules.play.moves.nonDecision.effect.state.swap.Swap, keyword=swap, atomic=Swap, atomic path=game.rules.play.moves.nonDecision.effect.state.swap.Swap
~~~~ <swapPlayersType> name=SwapPlayersType type=Structural (game.rules.play.moves.nonDecision.effect.state.swap.SwapPlayersType) => <swapPlayersType>, pack=game.rules.play.moves.nonDecision.effect.state.swap, label=swapPlayersType, cls=game.rules.play.moves.nonDecision.effect.state.swap.SwapPlayersType, keyword=swapPlayersType, atomic=SwapPlayersType, atomic path=game.rules.play.moves.nonDecision.effect.state.swap.SwapPlayersType
~~~~ <swapSitesType> name=SwapSitesType type=Structural (game.rules.play.moves.nonDecision.effect.state.swap.SwapSitesType) => <swapSitesType>, pack=game.rules.play.moves.nonDecision.effect.state.swap, label=swapSitesType, cls=game.rules.play.moves.nonDecision.effect.state.swap.SwapSitesType, keyword=swapSitesType, atomic=SwapSitesType, atomic path=game.rules.play.moves.nonDecision.effect.state.swap.SwapSitesType
~~~~ <swapPlayers> name=SwapPlayers type=SubLudeme (game.rules.play.moves.nonDecision.effect.state.swap.players.SwapPlayers) => <moves>, pack=game.rules.play.moves.nonDecision.effect.state.swap.players, label=swapPlayers, cls=game.rules.play.moves.nonDecision.effect.state.swap.players.SwapPlayers, keyword=swapPlayers, atomic=SwapPlayers, atomic path=game.rules.play.moves.nonDecision.effect.state.swap.players.SwapPlayers
~~~~ <swapPieces> name=SwapPieces type=SubLudeme (game.rules.play.moves.nonDecision.effect.state.swap.sites.SwapPieces) => <moves>, pack=game.rules.play.moves.nonDecision.effect.state.swap.sites, label=swapPieces, cls=game.rules.play.moves.nonDecision.effect.state.swap.sites.SwapPieces, keyword=swapPieces, atomic=SwapPieces, atomic path=game.rules.play.moves.nonDecision.effect.state.swap.sites.SwapPieces
gd~~ <take> name=Take type=SuperLudeme (game.rules.play.moves.nonDecision.effect.take.Take) => <moves>, pack=game.rules.play.moves.nonDecision.effect.take, label=take, cls=game.rules.play.moves.nonDecision.effect.take.Take, keyword=take, atomic=Take, atomic path=game.rules.play.moves.nonDecision.effect.take.Take
~~~~ <takeControlType> name=TakeControlType type=Structural (game.rules.play.moves.nonDecision.effect.take.TakeControlType) => <takeControlType>, pack=game.rules.play.moves.nonDecision.effect.take, label=takeControlType, cls=game.rules.play.moves.nonDecision.effect.take.TakeControlType, keyword=takeControlType, atomic=TakeControlType, atomic path=game.rules.play.moves.nonDecision.effect.take.TakeControlType
~~~~ <takeSimpleType> name=TakeSimpleType type=Structural (game.rules.play.moves.nonDecision.effect.take.TakeSimpleType) => <takeSimpleType>, pack=game.rules.play.moves.nonDecision.effect.take, label=takeSimpleType, cls=game.rules.play.moves.nonDecision.effect.take.TakeSimpleType, keyword=takeSimpleType, atomic=TakeSimpleType, atomic path=game.rules.play.moves.nonDecision.effect.take.TakeSimpleType
~~~~ <takeControl> name=TakeControl type=SubLudeme (game.rules.play.moves.nonDecision.effect.take.control.TakeControl) => <moves>, pack=game.rules.play.moves.nonDecision.effect.take.control, label=takeControl, cls=game.rules.play.moves.nonDecision.effect.take.control.TakeControl, keyword=takeControl, atomic=TakeControl, atomic path=game.rules.play.moves.nonDecision.effect.take.control.TakeControl
~~~~ <takeDomino> name=TakeDomino type=SubLudeme (game.rules.play.moves.nonDecision.effect.take.simple.TakeDomino) => <moves>, pack=game.rules.play.moves.nonDecision.effect.take.simple, label=takeDomino, cls=game.rules.play.moves.nonDecision.effect.take.simple.TakeDomino, keyword=takeDomino, atomic=TakeDomino, atomic path=game.rules.play.moves.nonDecision.effect.take.simple.TakeDomino
g~~* <operator> name=Operator type=Structural (game.rules.play.moves.nonDecision.operator.Operator) => <moves>, pack=game.rules.play.moves.nonDecision.operator, label=operator, cls=game.rules.play.moves.nonDecision.operator.Operator, keyword=operator, atomic=Operator, atomic path=game.rules.play.moves.nonDecision.operator.Operator
gd~~ <operators.foreach.forEach> name=ForEach type=SuperLudeme (game.rules.play.moves.nonDecision.operators.foreach.ForEach) => <moves>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=operators.foreach.forEach, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEach, keyword=forEach, atomic=ForEach, atomic path=game.rules.play.moves.nonDecision.operators.foreach.ForEach
~~~~ <forEachDieType> name=ForEachDieType type=Structural (game.rules.play.moves.nonDecision.operators.foreach.ForEachDieType) => <forEachDieType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=forEachDieType, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachDieType, keyword=forEachDieType, atomic=ForEachDieType, atomic path=game.rules.play.moves.nonDecision.operators.foreach.ForEachDieType
~~~~ <forEachDirectionType> name=ForEachDirectionType type=Structural (game.rules.play.moves.nonDecision.operators.foreach.ForEachDirectionType) => <forEachDirectionType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=forEachDirectionType, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachDirectionType, keyword=forEachDirectionType, atomic=ForEachDirectionType, atomic path=game.rules.play.moves.nonDecision.operators.foreach.ForEachDirectionType
~~~~ <forEachGroupType> name=ForEachGroupType type=Structural (game.rules.play.moves.nonDecision.operators.foreach.ForEachGroupType) => <forEachGroupType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=forEachGroupType, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachGroupType, keyword=forEachGroupType, atomic=ForEachGroupType, atomic path=game.rules.play.moves.nonDecision.operators.foreach.ForEachGroupType
~~~~ <operators.foreach.forEachLevelType> name=ForEachLevelType type=Structural (game.rules.play.moves.nonDecision.operators.foreach.ForEachLevelType) => <operators.foreach.forEachLevelType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=operators.foreach.forEachLevelType, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachLevelType, keyword=forEachLevelType, atomic=ForEachLevelType, atomic path=game.rules.play.moves.nonDecision.operators.foreach.ForEachLevelType
~~~~ <forEachPieceType> name=ForEachPieceType type=Structural (game.rules.play.moves.nonDecision.operators.foreach.ForEachPieceType) => <forEachPieceType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=forEachPieceType, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachPieceType, keyword=forEachPieceType, atomic=ForEachPieceType, atomic path=game.rules.play.moves.nonDecision.operators.foreach.ForEachPieceType
~~~~ <forEachPlayerType> name=ForEachPlayerType type=Structural (game.rules.play.moves.nonDecision.operators.foreach.ForEachPlayerType) => <forEachPlayerType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=forEachPlayerType, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachPlayerType, keyword=forEachPlayerType, atomic=ForEachPlayerType, atomic path=game.rules.play.moves.nonDecision.operators.foreach.ForEachPlayerType
~~~~ <forEachSiteType> name=ForEachSiteType type=Structural (game.rules.play.moves.nonDecision.operators.foreach.ForEachSiteType) => <forEachSiteType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=forEachSiteType, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachSiteType, keyword=forEachSiteType, atomic=ForEachSiteType, atomic path=game.rules.play.moves.nonDecision.operators.foreach.ForEachSiteType
~~~~ <forEachValueType> name=ForEachValueType type=Structural (game.rules.play.moves.nonDecision.operators.foreach.ForEachValueType) => <forEachValueType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=forEachValueType, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachValueType, keyword=forEachValueType, atomic=ForEachValueType, atomic path=game.rules.play.moves.nonDecision.operators.foreach.ForEachValueType
~~~~ <forEachDie> name=ForEachDie type=SubLudeme (game.rules.play.moves.nonDecision.operators.foreach.die.ForEachDie) => <moves>, pack=game.rules.play.moves.nonDecision.operators.foreach.die, label=forEachDie, cls=game.rules.play.moves.nonDecision.operators.foreach.die.ForEachDie, keyword=forEachDie, atomic=ForEachDie, atomic path=game.rules.play.moves.nonDecision.operators.foreach.die.ForEachDie
~~~~ <forEachDirection> name=ForEachDirection type=SubLudeme (game.rules.play.moves.nonDecision.operators.foreach.direction.ForEachDirection) => <moves>, pack=game.rules.play.moves.nonDecision.operators.foreach.direction, label=forEachDirection, cls=game.rules.play.moves.nonDecision.operators.foreach.direction.ForEachDirection, keyword=forEachDirection, atomic=ForEachDirection, atomic path=game.rules.play.moves.nonDecision.operators.foreach.direction.ForEachDirection
~~~~ <forEachGroup> name=ForEachGroup type=SubLudeme (game.rules.play.moves.nonDecision.operators.foreach.group.ForEachGroup) => <moves>, pack=game.rules.play.moves.nonDecision.operators.foreach.group, label=forEachGroup, cls=game.rules.play.moves.nonDecision.operators.foreach.group.ForEachGroup, keyword=forEachGroup, atomic=ForEachGroup, atomic path=game.rules.play.moves.nonDecision.operators.foreach.group.ForEachGroup
~~~~ <operators.foreach.level.forEachLevel> name=ForEachLevel type=SubLudeme (game.rules.play.moves.nonDecision.operators.foreach.level.ForEachLevel) => <moves>, pack=game.rules.play.moves.nonDecision.operators.foreach.level, label=operators.foreach.level.forEachLevel, cls=game.rules.play.moves.nonDecision.operators.foreach.level.ForEachLevel, keyword=forEachLevel, atomic=ForEachLevel, atomic path=game.rules.play.moves.nonDecision.operators.foreach.level.ForEachLevel
~~~~ <forEachPiece> name=ForEachPiece type=SubLudeme (game.rules.play.moves.nonDecision.operators.foreach.piece.ForEachPiece) => <moves>, pack=game.rules.play.moves.nonDecision.operators.foreach.piece, label=forEachPiece, cls=game.rules.play.moves.nonDecision.operators.foreach.piece.ForEachPiece, keyword=forEachPiece, atomic=ForEachPiece, atomic path=game.rules.play.moves.nonDecision.operators.foreach.piece.ForEachPiece
~~~~ <operators.foreach.player.forEachPlayer> name=ForEachPlayer type=SubLudeme (game.rules.play.moves.nonDecision.operators.foreach.player.ForEachPlayer) => <moves>, pack=game.rules.play.moves.nonDecision.operators.foreach.player, label=operators.foreach.player.forEachPlayer, cls=game.rules.play.moves.nonDecision.operators.foreach.player.ForEachPlayer, keyword=forEachPlayer, atomic=ForEachPlayer, atomic path=game.rules.play.moves.nonDecision.operators.foreach.player.ForEachPlayer
~~~~ <foreach.site.forEachSite> name=ForEachSite type=SubLudeme (game.rules.play.moves.nonDecision.operators.foreach.site.ForEachSite) => <moves>, pack=game.rules.play.moves.nonDecision.operators.foreach.site, label=foreach.site.forEachSite, cls=game.rules.play.moves.nonDecision.operators.foreach.site.ForEachSite, keyword=forEachSite, atomic=ForEachSite, atomic path=game.rules.play.moves.nonDecision.operators.foreach.site.ForEachSite
~~~~ <operators.foreach.team.forEachTeam> name=ForEachTeam type=SubLudeme (game.rules.play.moves.nonDecision.operators.foreach.team.ForEachTeam) => <moves>, pack=game.rules.play.moves.nonDecision.operators.foreach.team, label=operators.foreach.team.forEachTeam, cls=game.rules.play.moves.nonDecision.operators.foreach.team.ForEachTeam, keyword=forEachTeam, atomic=ForEachTeam, atomic path=game.rules.play.moves.nonDecision.operators.foreach.team.ForEachTeam
~~~~ <foreach.value.forEachValue> name=ForEachValue type=SubLudeme (game.rules.play.moves.nonDecision.operators.foreach.value.ForEachValue) => <moves>, pack=game.rules.play.moves.nonDecision.operators.foreach.value, label=foreach.value.forEachValue, cls=game.rules.play.moves.nonDecision.operators.foreach.value.ForEachValue, keyword=forEachValue, atomic=ForEachValue, atomic path=game.rules.play.moves.nonDecision.operators.foreach.value.ForEachValue
gd~~ <allCombinations> name=AllCombinations type=Ludeme (game.rules.play.moves.nonDecision.operators.logical.AllCombinations) => <moves>, pack=game.rules.play.moves.nonDecision.operators.logical, label=allCombinations, cls=game.rules.play.moves.nonDecision.operators.logical.AllCombinations, keyword=allCombinations, atomic=AllCombinations, atomic path=game.rules.play.moves.nonDecision.operators.logical.AllCombinations
gd~~ <logical.and> name=And type=Ludeme (game.rules.play.moves.nonDecision.operators.logical.And) => <moves>, pack=game.rules.play.moves.nonDecision.operators.logical, label=logical.and, cls=game.rules.play.moves.nonDecision.operators.logical.And, keyword=and, atomic=And, atomic path=game.rules.play.moves.nonDecision.operators.logical.And
gd~~ <append> name=Append type=Ludeme (game.rules.play.moves.nonDecision.operators.logical.Append) => <moves>, pack=game.rules.play.moves.nonDecision.operators.logical, label=append, cls=game.rules.play.moves.nonDecision.operators.logical.Append, keyword=append, atomic=Append, atomic path=game.rules.play.moves.nonDecision.operators.logical.Append
gd~~ <logical.if> name=If type=Ludeme (game.rules.play.moves.nonDecision.operators.logical.If) => <moves>, pack=game.rules.play.moves.nonDecision.operators.logical, label=logical.if, cls=game.rules.play.moves.nonDecision.operators.logical.If, keyword=if, atomic=If, atomic path=game.rules.play.moves.nonDecision.operators.logical.If
gd~~ <logical.or> name=Or type=Ludeme (game.rules.play.moves.nonDecision.operators.logical.Or) => <moves>, pack=game.rules.play.moves.nonDecision.operators.logical, label=logical.or, cls=game.rules.play.moves.nonDecision.operators.logical.Or, keyword=or, atomic=Or, atomic path=game.rules.play.moves.nonDecision.operators.logical.Or
gd~~ <seq> name=Seq type=Ludeme (game.rules.play.moves.nonDecision.operators.logical.Seq) => <moves>, pack=game.rules.play.moves.nonDecision.operators.logical, label=seq, cls=game.rules.play.moves.nonDecision.operators.logical.Seq, keyword=seq, atomic=Seq, atomic path=game.rules.play.moves.nonDecision.operators.logical.Seq
gd~~ <start.deal> name=Deal type=Ludeme (game.rules.start.Deal) => <start.deal>, pack=game.rules.start, label=start.deal, cls=game.rules.start.Deal, keyword=deal, atomic=Deal, atomic path=game.rules.start.Deal
gd~~ <start> name=Start type=Ludeme (game.rules.start.Start) => <start>, pack=game.rules.start, label=start, cls=game.rules.start.Start, keyword=start, atomic=Start, atomic path=game.rules.start.Start
g~~* <startRule> name=StartRule type=Structural (game.rules.start.StartRule) => <startRule>, pack=game.rules.start, label=startRule, cls=game.rules.start.StartRule, keyword=startRule, atomic=StartRule, atomic path=game.rules.start.StartRule
gd~~ <deductionPuzzle.set> name=Set type=Ludeme (game.rules.start.deductionPuzzle.Set) => <deductionPuzzle.set>, pack=game.rules.start.deductionPuzzle, label=deductionPuzzle.set, cls=game.rules.start.deductionPuzzle.Set, keyword=set, atomic=Set, atomic path=game.rules.start.deductionPuzzle.Set
gd~~ <forEach.forEach> name=ForEach type=SuperLudeme (game.rules.start.forEach.ForEach) => <forEach.forEach>, pack=game.rules.start.forEach, label=forEach.forEach, cls=game.rules.start.forEach.ForEach, keyword=forEach, atomic=ForEach, atomic path=game.rules.start.forEach.ForEach
~~~~ <forEachStartValueType> name=ForEachStartValueType type=Structural (game.rules.start.forEach.ForEachStartValueType) => <forEachStartValueType>, pack=game.rules.start.forEach, label=forEachStartValueType, cls=game.rules.start.forEach.ForEachStartValueType, keyword=forEachStartValueType, atomic=ForEachStartValueType, atomic path=game.rules.start.forEach.ForEachStartValueType
~~~~ <forEachTeamType> name=ForEachTeamType type=Structural (game.rules.start.forEach.ForEachTeamType) => <forEachTeamType>, pack=game.rules.start.forEach, label=forEachTeamType, cls=game.rules.start.forEach.ForEachTeamType, keyword=forEachTeamType, atomic=ForEachTeamType, atomic path=game.rules.start.forEach.ForEachTeamType
~~~~ <forEach.player.forEachPlayer> name=ForEachPlayer type=SubLudeme (game.rules.start.forEach.player.ForEachPlayer) => <forEach.player.forEachPlayer>, pack=game.rules.start.forEach.player, label=forEach.player.forEachPlayer, cls=game.rules.start.forEach.player.ForEachPlayer, keyword=forEachPlayer, atomic=ForEachPlayer, atomic path=game.rules.start.forEach.player.ForEachPlayer
~~~~ <forEach.site.forEachSite> name=ForEachSite type=SubLudeme (game.rules.start.forEach.site.ForEachSite) => <forEach.site.forEachSite>, pack=game.rules.start.forEach.site, label=forEach.site.forEachSite, cls=game.rules.start.forEach.site.ForEachSite, keyword=forEachSite, atomic=ForEachSite, atomic path=game.rules.start.forEach.site.ForEachSite
~~~~ <forEach.team.forEachTeam> name=ForEachTeam type=SubLudeme (game.rules.start.forEach.team.ForEachTeam) => <forEach.team.forEachTeam>, pack=game.rules.start.forEach.team, label=forEach.team.forEachTeam, cls=game.rules.start.forEach.team.ForEachTeam, keyword=forEachTeam, atomic=ForEachTeam, atomic path=game.rules.start.forEach.team.ForEachTeam
~~~~ <forEach.value.forEachValue> name=ForEachValue type=SubLudeme (game.rules.start.forEach.value.ForEachValue) => <forEach.value.forEachValue>, pack=game.rules.start.forEach.value, label=forEach.value.forEachValue, cls=game.rules.start.forEach.value.ForEachValue, keyword=forEachValue, atomic=ForEachValue, atomic path=game.rules.start.forEach.value.ForEachValue
gd~~ <place> name=Place type=SuperLudeme (game.rules.start.place.Place) => <place>, pack=game.rules.start.place, label=place, cls=game.rules.start.place.Place, keyword=place, atomic=Place, atomic path=game.rules.start.place.Place
~~~~ <placeRandomType> name=PlaceRandomType type=Structural (game.rules.start.place.PlaceRandomType) => <placeRandomType>, pack=game.rules.start.place, label=placeRandomType, cls=game.rules.start.place.PlaceRandomType, keyword=placeRandomType, atomic=PlaceRandomType, atomic path=game.rules.start.place.PlaceRandomType
~~~~ <placeStackType> name=PlaceStackType type=Structural (game.rules.start.place.PlaceStackType) => <placeStackType>, pack=game.rules.start.place, label=placeStackType, cls=game.rules.start.place.PlaceStackType, keyword=placeStackType, atomic=PlaceStackType, atomic path=game.rules.start.place.PlaceStackType
~~~~ <placeItem> name=PlaceItem type=SubLudeme (game.rules.start.place.item.PlaceItem) => <placeItem>, pack=game.rules.start.place.item, label=placeItem, cls=game.rules.start.place.item.PlaceItem, keyword=placeItem, atomic=PlaceItem, atomic path=game.rules.start.place.item.PlaceItem
~~~~ <placeRandom> name=PlaceRandom type=SubLudeme (game.rules.start.place.random.PlaceRandom) => <placeRandom>, pack=game.rules.start.place.random, label=placeRandom, cls=game.rules.start.place.random.PlaceRandom, keyword=placeRandom, atomic=PlaceRandom, atomic path=game.rules.start.place.random.PlaceRandom
~~~~ <placeCustomStack> name=PlaceCustomStack type=SubLudeme (game.rules.start.place.stack.PlaceCustomStack) => <placeCustomStack>, pack=game.rules.start.place.stack, label=placeCustomStack, cls=game.rules.start.place.stack.PlaceCustomStack, keyword=placeCustomStack, atomic=PlaceCustomStack, atomic path=game.rules.start.place.stack.PlaceCustomStack
~~~~ <placeMonotonousStack> name=PlaceMonotonousStack type=SubLudeme (game.rules.start.place.stack.PlaceMonotonousStack) => <placeMonotonousStack>, pack=game.rules.start.place.stack, label=placeMonotonousStack, cls=game.rules.start.place.stack.PlaceMonotonousStack, keyword=placeMonotonousStack, atomic=PlaceMonotonousStack, atomic path=game.rules.start.place.stack.PlaceMonotonousStack
gd~~ <start.set.set> name=Set type=SuperLudeme (game.rules.start.set.Set) => <start.set.set>, pack=game.rules.start.set, label=start.set.set, cls=game.rules.start.set.Set, keyword=set, atomic=Set, atomic path=game.rules.start.set.Set
~~~~ <setRememberValueType> name=SetRememberValueType type=Structural (game.rules.start.set.SetRememberValueType) => <setRememberValueType>, pack=game.rules.start.set, label=setRememberValueType, cls=game.rules.start.set.SetRememberValueType, keyword=setRememberValueType, atomic=SetRememberValueType, atomic path=game.rules.start.set.SetRememberValueType
~~~~ <setStartGraphType> name=SetStartGraphType type=Structural (game.rules.start.set.SetStartGraphType) => <setStartGraphType>, pack=game.rules.start.set, label=setStartGraphType, cls=game.rules.start.set.SetStartGraphType, keyword=setStartGraphType, atomic=SetStartGraphType, atomic path=game.rules.start.set.SetStartGraphType
~~~~ <setStartHiddenType> name=SetStartHiddenType type=Structural (game.rules.start.set.SetStartHiddenType) => <setStartHiddenType>, pack=game.rules.start.set, label=setStartHiddenType, cls=game.rules.start.set.SetStartHiddenType, keyword=setStartHiddenType, atomic=SetStartHiddenType, atomic path=game.rules.start.set.SetStartHiddenType
g~~~ <setStartPlayerType> name=SetStartPlayerType type=Structural (game.rules.start.set.SetStartPlayerType) => <setStartPlayerType>, pack=game.rules.start.set, label=setStartPlayerType, cls=game.rules.start.set.SetStartPlayerType, keyword=setStartPlayerType, atomic=SetStartPlayerType, atomic path=game.rules.start.set.SetStartPlayerType
~~~~ <setStartPlayersType> name=SetStartPlayersType type=Structural (game.rules.start.set.SetStartPlayersType) => <setStartPlayersType>, pack=game.rules.start.set, label=setStartPlayersType, cls=game.rules.start.set.SetStartPlayersType, keyword=setStartPlayersType, atomic=SetStartPlayersType, atomic path=game.rules.start.set.SetStartPlayersType
g~~~ <setStartSitesType> name=SetStartSitesType type=Structural (game.rules.start.set.SetStartSitesType) => <setStartSitesType>, pack=game.rules.start.set, label=setStartSitesType, cls=game.rules.start.set.SetStartSitesType, keyword=setStartSitesType, atomic=SetStartSitesType, atomic path=game.rules.start.set.SetStartSitesType
~~~~ <start.set.hidden.setHidden> name=SetHidden type=SubLudeme (game.rules.start.set.hidden.SetHidden) => <start.set.hidden.setHidden>, pack=game.rules.start.set.hidden, label=start.set.hidden.setHidden, cls=game.rules.start.set.hidden.SetHidden, keyword=setHidden, atomic=SetHidden, atomic path=game.rules.start.set.hidden.SetHidden
~~~~ <setAmount> name=SetAmount type=SubLudeme (game.rules.start.set.player.SetAmount) => <setAmount>, pack=game.rules.start.set.player, label=setAmount, cls=game.rules.start.set.player.SetAmount, keyword=setAmount, atomic=SetAmount, atomic path=game.rules.start.set.player.SetAmount
~~~~ <start.set.player.setScore> name=SetScore type=SubLudeme (game.rules.start.set.player.SetScore) => <start.set.player.setScore>, pack=game.rules.start.set.player, label=start.set.player.setScore, cls=game.rules.start.set.player.SetScore, keyword=setScore, atomic=SetScore, atomic path=game.rules.start.set.player.SetScore
~~~~ <players.setTeam> name=SetTeam type=SubLudeme (game.rules.start.set.players.SetTeam) => <players.setTeam>, pack=game.rules.start.set.players, label=players.setTeam, cls=game.rules.start.set.players.SetTeam, keyword=setTeam, atomic=SetTeam, atomic path=game.rules.start.set.players.SetTeam
~~~~ <setRememberValue> name=SetRememberValue type=SubLudeme (game.rules.start.set.remember.SetRememberValue) => <setRememberValue>, pack=game.rules.start.set.remember, label=setRememberValue, cls=game.rules.start.set.remember.SetRememberValue, keyword=setRememberValue, atomic=SetRememberValue, atomic path=game.rules.start.set.remember.SetRememberValue
~~~~ <setCost> name=SetCost type=SubLudeme (game.rules.start.set.sites.SetCost) => <setCost>, pack=game.rules.start.set.sites, label=setCost, cls=game.rules.start.set.sites.SetCost, keyword=setCost, atomic=SetCost, atomic path=game.rules.start.set.sites.SetCost
~~~~ <sites.setCount> name=SetCount type=SubLudeme (game.rules.start.set.sites.SetCount) => <sites.setCount>, pack=game.rules.start.set.sites, label=sites.setCount, cls=game.rules.start.set.sites.SetCount, keyword=setCount, atomic=SetCount, atomic path=game.rules.start.set.sites.SetCount
~~~~ <setPhase> name=SetPhase type=SubLudeme (game.rules.start.set.sites.SetPhase) => <setPhase>, pack=game.rules.start.set.sites, label=setPhase, cls=game.rules.start.set.sites.SetPhase, keyword=setPhase, atomic=SetPhase, atomic path=game.rules.start.set.sites.SetPhase
~~~~ <setSite> name=SetSite type=SubLudeme (game.rules.start.set.sites.SetSite) => <setSite>, pack=game.rules.start.set.sites, label=setSite, cls=game.rules.start.set.sites.SetSite, keyword=setSite, atomic=SetSite, atomic path=game.rules.start.set.sites.SetSite
gd~~ <split> name=Split type=Ludeme (game.rules.start.split.Split) => <split>, pack=game.rules.start.split, label=split, cls=game.rules.start.split.Split, keyword=split, atomic=Split, atomic path=game.rules.start.split.Split
~~~~ <splitType> name=SplitType type=Structural (game.rules.start.split.SplitType) => <splitType>, pack=game.rules.start.split, label=splitType, cls=game.rules.start.split.SplitType, keyword=splitType, atomic=SplitType, atomic path=game.rules.start.split.SplitType
g~~~ <basisType> name=BasisType type=Structural (game.types.board.BasisType) => <basisType>, pack=game.types.board, label=basisType, cls=game.types.board.BasisType, keyword=basisType, atomic=BasisType, atomic path=game.types.board.BasisType
g~~~ <hiddenData> name=HiddenData type=Structural (game.types.board.HiddenData) => <hiddenData>, pack=game.types.board, label=hiddenData, cls=game.types.board.HiddenData, keyword=hiddenData, atomic=HiddenData, atomic path=game.types.board.HiddenData
g~~~ <landmarkType> name=LandmarkType type=Structural (game.types.board.LandmarkType) => <landmarkType>, pack=game.types.board, label=landmarkType, cls=game.types.board.LandmarkType, keyword=landmarkType, atomic=LandmarkType, atomic path=game.types.board.LandmarkType
g~~~ <puzzleElementType> name=PuzzleElementType type=Structural (game.types.board.PuzzleElementType) => <puzzleElementType>, pack=game.types.board, label=puzzleElementType, cls=game.types.board.PuzzleElementType, keyword=puzzleElementType, atomic=PuzzleElementType, atomic path=game.types.board.PuzzleElementType
g~~~ <regionTypeDynamic> name=RegionTypeDynamic type=Structural (game.types.board.RegionTypeDynamic) => <regionTypeDynamic>, pack=game.types.board, label=regionTypeDynamic, cls=game.types.board.RegionTypeDynamic, keyword=regionTypeDynamic, atomic=RegionTypeDynamic, atomic path=game.types.board.RegionTypeDynamic
g~~~ <regionTypeStatic> name=RegionTypeStatic type=Structural (game.types.board.RegionTypeStatic) => <regionTypeStatic>, pack=game.types.board, label=regionTypeStatic, cls=game.types.board.RegionTypeStatic, keyword=regionTypeStatic, atomic=RegionTypeStatic, atomic path=game.types.board.RegionTypeStatic
g~m~ <relationType> name=RelationType type=Structural (game.types.board.RelationType) => <relationType>, pack=game.types.board, label=relationType, cls=game.types.board.RelationType, keyword=relationType, atomic=RelationType, atomic path=game.types.board.RelationType
g~~~ <shapeType> name=ShapeType type=Structural (game.types.board.ShapeType) => <shapeType>, pack=game.types.board, label=shapeType, cls=game.types.board.ShapeType, keyword=shapeType, atomic=ShapeType, atomic path=game.types.board.ShapeType
g~m~ <siteType> name=SiteType type=Structural (game.types.board.SiteType) => <siteType>, pack=game.types.board, label=siteType, cls=game.types.board.SiteType, keyword=siteType, atomic=SiteType, atomic path=game.types.board.SiteType
g~~~ <stepType> name=StepType type=Structural (game.types.board.StepType) => <stepType>, pack=game.types.board, label=stepType, cls=game.types.board.StepType, keyword=stepType, atomic=StepType, atomic path=game.types.board.StepType
g~~~ <storeType> name=StoreType type=Structural (game.types.board.StoreType) => <storeType>, pack=game.types.board, label=storeType, cls=game.types.board.StoreType, keyword=storeType, atomic=StoreType, atomic path=game.types.board.StoreType
g~~~ <tilingBoardlessType> name=TilingBoardlessType type=Structural (game.types.board.TilingBoardlessType) => <tilingBoardlessType>, pack=game.types.board, label=tilingBoardlessType, cls=game.types.board.TilingBoardlessType, keyword=tilingBoardlessType, atomic=TilingBoardlessType, atomic path=game.types.board.TilingBoardlessType
~~~~ <trackStepType> name=TrackStepType type=Structural (game.types.board.TrackStepType) => <trackStepType>, pack=game.types.board, label=trackStepType, cls=game.types.board.TrackStepType, keyword=trackStepType, atomic=TrackStepType, atomic path=game.types.board.TrackStepType
~~~~ <trackType> name=TrackType type=Structural (game.types.board.TrackType) => <trackType>, pack=game.types.board, label=trackType, cls=game.types.board.TrackType, keyword=trackType, atomic=TrackType, atomic path=game.types.board.TrackType
g~~~ <cardType> name=CardType type=Structural (game.types.component.CardType) => <cardType>, pack=game.types.component, label=cardType, cls=game.types.component.CardType, keyword=cardType, atomic=CardType, atomic path=game.types.component.CardType
g~~~ <dealableType> name=DealableType type=Structural (game.types.component.DealableType) => <dealableType>, pack=game.types.component, label=dealableType, cls=game.types.component.DealableType, keyword=dealableType, atomic=DealableType, atomic path=game.types.component.DealableType
~~m~ <suitType> name=SuitType type=Structural (game.types.component.SuitType) => <suitType>, pack=game.types.component, label=suitType, cls=game.types.component.SuitType, keyword=suitType, atomic=SuitType, atomic path=game.types.component.SuitType
~~~* <types.dummy> name=dummy type=Ludeme (game.types.dummy) => <types.dummy>, pack=game.types, label=types.dummy, cls=game.types.dummy, keyword=dummy, atomic=dummy, atomic path=game.types.dummy
~~~~ <gravityType> name=GravityType type=Structural (game.types.play.GravityType) => <gravityType>, pack=game.types.play, label=gravityType, cls=game.types.play.GravityType, keyword=gravityType, atomic=GravityType, atomic path=game.types.play.GravityType
g~~~ <modeType> name=ModeType type=Structural (game.types.play.ModeType) => <modeType>, pack=game.types.play, label=modeType, cls=game.types.play.ModeType, keyword=modeType, atomic=ModeType, atomic path=game.types.play.ModeType
g~~~ <passEndType> name=PassEndType type=Structural (game.types.play.PassEndType) => <passEndType>, pack=game.types.play, label=passEndType, cls=game.types.play.PassEndType, keyword=passEndType, atomic=PassEndType, atomic path=game.types.play.PassEndType
~~~~ <pinType> name=PinType type=Structural (game.types.play.PinType) => <pinType>, pack=game.types.play, label=pinType, cls=game.types.play.PinType, keyword=pinType, atomic=PinType, atomic path=game.types.play.PinType
g~~~ <prevType> name=PrevType type=Structural (game.types.play.PrevType) => <prevType>, pack=game.types.play, label=prevType, cls=game.types.play.PrevType, keyword=prevType, atomic=PrevType, atomic path=game.types.play.PrevType
g~~~ <repetitionType> name=RepetitionType type=Structural (game.types.play.RepetitionType) => <repetitionType>, pack=game.types.play, label=repetitionType, cls=game.types.play.RepetitionType, keyword=repetitionType, atomic=RepetitionType, atomic path=game.types.play.RepetitionType
g~~~ <resultType> name=ResultType type=Structural (game.types.play.ResultType) => <resultType>, pack=game.types.play, label=resultType, cls=game.types.play.ResultType, keyword=resultType, atomic=ResultType, atomic path=game.types.play.ResultType
g~m~ <roleType> name=RoleType type=Structural (game.types.play.RoleType) => <roleType>, pack=game.types.play, label=roleType, cls=game.types.play.RoleType, keyword=roleType, atomic=RoleType, atomic path=game.types.play.RoleType
g~~~ <whenType> name=WhenType type=Structural (game.types.play.WhenType) => <whenType>, pack=game.types.play, label=whenType, cls=game.types.play.WhenType, keyword=whenType, atomic=WhenType, atomic path=game.types.play.WhenType
~~~* <gameType> name=GameType type=Structural (game.types.state.GameType) => <gameType>, pack=game.types.state, label=gameType, cls=game.types.state.GameType, keyword=gameType, atomic=GameType, atomic path=game.types.state.GameType
g~~* <absoluteDirection> name=AbsoluteDirection type=Structural (game.util.directions.AbsoluteDirection) => <absoluteDirection>, pack=game.util.directions, label=absoluteDirection, cls=game.util.directions.AbsoluteDirection, keyword=absoluteDirection, atomic=AbsoluteDirection, atomic path=game.util.directions.AbsoluteDirection
g~~* <compassDirection> name=CompassDirection type=Structural (game.util.directions.CompassDirection) => <compassDirection>, pack=game.util.directions, label=compassDirection, cls=game.util.directions.CompassDirection, keyword=compassDirection, atomic=CompassDirection, atomic path=game.util.directions.CompassDirection
g~~* <direction> name=Direction type=Structural (game.util.directions.Direction) => <direction>, pack=game.util.directions, label=direction, cls=game.util.directions.Direction, keyword=direction, atomic=Direction, atomic path=game.util.directions.Direction
g~~* <directionFacing> name=DirectionFacing type=Structural (game.util.directions.DirectionFacing) => <directionFacing>, pack=game.util.directions, label=directionFacing, cls=game.util.directions.DirectionFacing, keyword=directionFacing, atomic=DirectionFacing, atomic path=game.util.directions.DirectionFacing
~~~~ <directionType> name=DirectionType type=Structural (game.util.directions.DirectionType) => <directionType>, pack=game.util.directions, label=directionType, cls=game.util.directions.DirectionType, keyword=directionType, atomic=DirectionType, atomic path=game.util.directions.DirectionType
~~~~ <directionUniqueName> name=DirectionUniqueName type=Ludeme (game.util.directions.DirectionUniqueName) => <directionUniqueName>, pack=game.util.directions, label=directionUniqueName, cls=game.util.directions.DirectionUniqueName, keyword=directionUniqueName, atomic=DirectionUniqueName, atomic path=game.util.directions.DirectionUniqueName
g~~* <relativeDirection> name=RelativeDirection type=Structural (game.util.directions.RelativeDirection) => <relativeDirection>, pack=game.util.directions, label=relativeDirection, cls=game.util.directions.RelativeDirection, keyword=relativeDirection, atomic=RelativeDirection, atomic path=game.util.directions.RelativeDirection
g~~* <rotationalDirection> name=RotationalDirection type=Structural (game.util.directions.RotationalDirection) => <rotationalDirection>, pack=game.util.directions, label=rotationalDirection, cls=game.util.directions.RotationalDirection, keyword=rotationalDirection, atomic=RotationalDirection, atomic path=game.util.directions.RotationalDirection
g~~* <spatialDirection> name=SpatialDirection type=Structural (game.util.directions.SpatialDirection) => <spatialDirection>, pack=game.util.directions, label=spatialDirection, cls=game.util.directions.SpatialDirection, keyword=spatialDirection, atomic=SpatialDirection, atomic path=game.util.directions.SpatialDirection
g~~~ <stackDirection> name=StackDirection type=Structural (game.util.directions.StackDirection) => <stackDirection>, pack=game.util.directions, label=stackDirection, cls=game.util.directions.StackDirection, keyword=stackDirection, atomic=StackDirection, atomic path=game.util.directions.StackDirection
~~~* <util.dummy> name=dummy type=Ludeme (game.util.dummy) => <util.dummy>, pack=game.util, label=util.dummy, cls=game.util.dummy, keyword=dummy, atomic=dummy, atomic path=game.util.dummy
gd~~ <payoff> name=Payoff type=Ludeme (game.util.end.Payoff) => <payoff>, pack=game.util.end, label=payoff, cls=game.util.end.Payoff, keyword=payoff, atomic=Payoff, atomic path=game.util.end.Payoff
gd~~ <end.score> name=Score type=Ludeme (game.util.end.Score) => <end.score>, pack=game.util.end, label=end.score, cls=game.util.end.Score, keyword=score, atomic=Score, atomic path=game.util.end.Score
gd~~ <equipment.card> name=Card type=Ludeme (game.util.equipment.Card) => <equipment.card>, pack=game.util.equipment, label=equipment.card, cls=game.util.equipment.Card, keyword=card, atomic=Card, atomic path=game.util.equipment.Card
gd~~ <equipment.hint> name=Hint type=Ludeme (game.util.equipment.Hint) => <equipment.hint>, pack=game.util.equipment, label=equipment.hint, cls=game.util.equipment.Hint, keyword=hint, atomic=Hint, atomic path=game.util.equipment.Hint
gd~~ <equipment.region> name=Region type=Ludeme (game.util.equipment.Region) => <equipment.region>, pack=game.util.equipment, label=equipment.region, cls=game.util.equipment.Region, keyword=region, atomic=Region, atomic path=game.util.equipment.Region
g~~~ <equipment.trackStep> name=TrackStep type=Ludeme (game.util.equipment.TrackStep) => <equipment.trackStep>, pack=game.util.equipment, label=equipment.trackStep, cls=game.util.equipment.TrackStep, keyword=trackStep, atomic=TrackStep, atomic path=game.util.equipment.TrackStep
gd~~ <equipment.values> name=Values type=Ludeme (game.util.equipment.Values) => <equipment.values>, pack=game.util.equipment, label=equipment.values, cls=game.util.equipment.Values, keyword=values, atomic=Values, atomic path=game.util.equipment.Values
~~~~ <bucket> name=Bucket type=Ludeme (game.util.graph.Bucket) => <bucket>, pack=game.util.graph, label=bucket, cls=game.util.graph.Bucket, keyword=bucket, atomic=Bucket, atomic path=game.util.graph.Bucket
~~~~ <graph.edge> name=Edge type=Ludeme (game.util.graph.Edge) => <graph.edge>, pack=game.util.graph, label=graph.edge, cls=game.util.graph.Edge, keyword=edge, atomic=Edge, atomic path=game.util.graph.Edge
~~~~ <graph.face> name=Face type=Ludeme (game.util.graph.Face) => <graph.face>, pack=game.util.graph, label=graph.face, cls=game.util.graph.Face, keyword=face, atomic=Face, atomic path=game.util.graph.Face
gd~~ <graph> name=Graph type=Ludeme (game.util.graph.Graph) => <graph>, pack=game.util.graph, label=graph, cls=game.util.graph.Graph, keyword=graph, atomic=Graph, atomic path=game.util.graph.Graph
~~~* <graphElement> name=GraphElement type=Ludeme (game.util.graph.GraphElement) => <graphElement>, pack=game.util.graph, label=graphElement, cls=game.util.graph.GraphElement, keyword=graphElement, atomic=GraphElement, atomic path=game.util.graph.GraphElement
~~~~ <itemScore> name=ItemScore type=Ludeme (game.util.graph.ItemScore) => <itemScore>, pack=game.util.graph, label=itemScore, cls=game.util.graph.ItemScore, keyword=itemScore, atomic=ItemScore, atomic path=game.util.graph.ItemScore
~~~* <measureGraph> name=MeasureGraph type=Ludeme (game.util.graph.MeasureGraph) => <measureGraph>, pack=game.util.graph, label=measureGraph, cls=game.util.graph.MeasureGraph, keyword=measureGraph, atomic=MeasureGraph, atomic path=game.util.graph.MeasureGraph
~~~~ <perimeter> name=Perimeter type=Ludeme (game.util.graph.Perimeter) => <perimeter>, pack=game.util.graph, label=perimeter, cls=game.util.graph.Perimeter, keyword=perimeter, atomic=Perimeter, atomic path=game.util.graph.Perimeter
gd~~ <poly> name=Poly type=Ludeme (game.util.graph.Poly) => <poly>, pack=game.util.graph, label=poly, cls=game.util.graph.Poly, keyword=poly, atomic=Poly, atomic path=game.util.graph.Poly
~~~~ <properties> name=Properties type=Ludeme (game.util.graph.Properties) => <properties>, pack=game.util.graph, label=properties, cls=game.util.graph.Properties, keyword=properties, atomic=Properties, atomic path=game.util.graph.Properties
~~~~ <radial> name=Radial type=Ludeme (game.util.graph.Radial) => <radial>, pack=game.util.graph, label=radial, cls=game.util.graph.Radial, keyword=radial, atomic=Radial, atomic path=game.util.graph.Radial
~~~~ <radials> name=Radials type=Ludeme (game.util.graph.Radials) => <radials>, pack=game.util.graph, label=radials, cls=game.util.graph.Radials, keyword=radials, atomic=Radials, atomic path=game.util.graph.Radials
~~~~ <situation> name=Situation type=Ludeme (game.util.graph.Situation) => <situation>, pack=game.util.graph, label=situation, cls=game.util.graph.Situation, keyword=situation, atomic=Situation, atomic path=game.util.graph.Situation
~~~~ <graph.step> name=Step type=Ludeme (game.util.graph.Step) => <graph.step>, pack=game.util.graph, label=graph.step, cls=game.util.graph.Step, keyword=step, atomic=Step, atomic path=game.util.graph.Step
~~~~ <steps> name=Steps type=Ludeme (game.util.graph.Steps) => <steps>, pack=game.util.graph, label=steps, cls=game.util.graph.Steps, keyword=steps, atomic=Steps, atomic path=game.util.graph.Steps
~~~~ <trajectories> name=Trajectories type=Ludeme (game.util.graph.Trajectories) => <trajectories>, pack=game.util.graph, label=trajectories, cls=game.util.graph.Trajectories, keyword=trajectories, atomic=Trajectories, atomic path=game.util.graph.Trajectories
~~~~ <vertex> name=Vertex type=Ludeme (game.util.graph.Vertex) => <vertex>, pack=game.util.graph, label=vertex, cls=game.util.graph.Vertex, keyword=vertex, atomic=Vertex, atomic path=game.util.graph.Vertex
gd~~ <math.count> name=Count type=Ludeme (game.util.math.Count) => <math.count>, pack=game.util.math, label=math.count, cls=game.util.math.Count, keyword=count, atomic=Count, atomic path=game.util.math.Count
gd~~ <math.pair> name=Pair type=Ludeme (game.util.math.Pair) => <math.pair>, pack=game.util.math, label=math.pair, cls=game.util.math.Pair, keyword=pair, atomic=Pair, atomic path=game.util.math.Pair
gd~~ <moves.between> name=Between type=Ludeme (game.util.moves.Between) => <moves.between>, pack=game.util.moves, label=moves.between, cls=game.util.moves.Between, keyword=between, atomic=Between, atomic path=game.util.moves.Between
gd~~ <flips> name=Flips type=Ludeme (game.util.moves.Flips) => <flips>, pack=game.util.moves, label=flips, cls=game.util.moves.Flips, keyword=flips, atomic=Flips, atomic path=game.util.moves.Flips
gd~~ <moves.from> name=From type=Ludeme (game.util.moves.From) => <moves.from>, pack=game.util.moves, label=moves.from, cls=game.util.moves.From, keyword=from, atomic=From, atomic path=game.util.moves.From
gd~~ <moves.piece> name=Piece type=Ludeme (game.util.moves.Piece) => <moves.piece>, pack=game.util.moves, label=moves.piece, cls=game.util.moves.Piece, keyword=piece, atomic=Piece, atomic path=game.util.moves.Piece
gd~~ <moves.player> name=Player type=Ludeme (game.util.moves.Player) => <moves.player>, pack=game.util.moves, label=moves.player, cls=game.util.moves.Player, keyword=player, atomic=Player, atomic path=game.util.moves.Player
gd~~ <moves.to> name=To type=Ludeme (game.util.moves.To) => <moves.to>, pack=game.util.moves, label=moves.to, cls=game.util.moves.To, keyword=to, atomic=To, atomic path=game.util.moves.To
~~~~ <optimiser> name=Optimiser type=Ludeme (game.util.optimiser.Optimiser) => <optimiser>, pack=game.util.optimiser, label=optimiser, cls=game.util.optimiser.Optimiser, keyword=optimiser, atomic=Optimiser, atomic path=game.util.optimiser.Optimiser
~~~~ <compareAllDistanceMetrics> name=CompareAllDistanceMetrics type=Ludeme (gameDistance.CompareAllDistanceMetrics) => <compareAllDistanceMetrics>, pack=gameDistance, label=compareAllDistanceMetrics, cls=gameDistance.CompareAllDistanceMetrics, keyword=compareAllDistanceMetrics, atomic=CompareAllDistanceMetrics, atomic path=gameDistance.CompareAllDistanceMetrics
~~~* <dataset> name=Dataset type=Structural (gameDistance.datasets.Dataset) => <dataset>, pack=gameDistance.datasets, label=dataset, cls=gameDistance.datasets.Dataset, keyword=dataset, atomic=Dataset, atomic path=gameDistance.datasets.Dataset
~~~~ <datasetUtils> name=DatasetUtils type=Ludeme (gameDistance.datasets.DatasetUtils) => <datasetUtils>, pack=gameDistance.datasets, label=datasetUtils, cls=gameDistance.datasets.DatasetUtils, keyword=datasetUtils, atomic=DatasetUtils, atomic path=gameDistance.datasets.DatasetUtils
~~~~ <aIResultDataset> name=AIResultDataset type=Ludeme (gameDistance.datasets.bagOfWords.AIResultDataset) => <aIResultDataset>, pack=gameDistance.datasets.bagOfWords, label=aIResultDataset, cls=gameDistance.datasets.bagOfWords.AIResultDataset, keyword=aIResultDataset, atomic=AIResultDataset, atomic path=gameDistance.datasets.bagOfWords.AIResultDataset
~~~~ <compilationConceptDataset> name=CompilationConceptDataset type=Ludeme (gameDistance.datasets.bagOfWords.CompilationConceptDataset) => <compilationConceptDataset>, pack=gameDistance.datasets.bagOfWords, label=compilationConceptDataset, cls=gameDistance.datasets.bagOfWords.CompilationConceptDataset, keyword=compilationConceptDataset, atomic=CompilationConceptDataset, atomic path=gameDistance.datasets.bagOfWords.CompilationConceptDataset
~~~~ <importConceptDataset> name=ImportConceptDataset type=Ludeme (gameDistance.datasets.bagOfWords.ImportConceptDataset) => <importConceptDataset>, pack=gameDistance.datasets.bagOfWords, label=importConceptDataset, cls=gameDistance.datasets.bagOfWords.ImportConceptDataset, keyword=importConceptDataset, atomic=ImportConceptDataset, atomic path=gameDistance.datasets.bagOfWords.ImportConceptDataset
~~~~ <nGramDataset> name=NGramDataset type=Ludeme (gameDistance.datasets.bagOfWords.NGramDataset) => <nGramDataset>, pack=gameDistance.datasets.bagOfWords, label=nGramDataset, cls=gameDistance.datasets.bagOfWords.NGramDataset, keyword=nGramDataset, atomic=NGramDataset, atomic path=gameDistance.datasets.bagOfWords.NGramDataset
~~~~ <moveConceptDataset> name=MoveConceptDataset type=Ludeme (gameDistance.datasets.sequence.MoveConceptDataset) => <moveConceptDataset>, pack=gameDistance.datasets.sequence, label=moveConceptDataset, cls=gameDistance.datasets.sequence.MoveConceptDataset, keyword=moveConceptDataset, atomic=MoveConceptDataset, atomic path=gameDistance.datasets.sequence.MoveConceptDataset
~~~~ <stateConceptDataset> name=StateConceptDataset type=Ludeme (gameDistance.datasets.sequence.StateConceptDataset) => <stateConceptDataset>, pack=gameDistance.datasets.sequence, label=stateConceptDataset, cls=gameDistance.datasets.sequence.StateConceptDataset, keyword=stateConceptDataset, atomic=StateConceptDataset, atomic path=gameDistance.datasets.sequence.StateConceptDataset
~~~~ <ludemeDataset> name=LudemeDataset type=Ludeme (gameDistance.datasets.treeEdit.LudemeDataset) => <ludemeDataset>, pack=gameDistance.datasets.treeEdit, label=ludemeDataset, cls=gameDistance.datasets.treeEdit.LudemeDataset, keyword=ludemeDataset, atomic=LudemeDataset, atomic path=gameDistance.datasets.treeEdit.LudemeDataset
~~~* <distanceMetric> name=DistanceMetric type=Structural (gameDistance.metrics.DistanceMetric) => <distanceMetric>, pack=gameDistance.metrics, label=distanceMetric, cls=gameDistance.metrics.DistanceMetric, keyword=distanceMetric, atomic=DistanceMetric, atomic path=gameDistance.metrics.DistanceMetric
~~~~ <cosine> name=Cosine type=Ludeme (gameDistance.metrics.bagOfWords.Cosine) => <cosine>, pack=gameDistance.metrics.bagOfWords, label=cosine, cls=gameDistance.metrics.bagOfWords.Cosine, keyword=cosine, atomic=Cosine, atomic path=gameDistance.metrics.bagOfWords.Cosine
~~~~ <jaccard> name=Jaccard type=Ludeme (gameDistance.metrics.bagOfWords.Jaccard) => <jaccard>, pack=gameDistance.metrics.bagOfWords, label=jaccard, cls=gameDistance.metrics.bagOfWords.Jaccard, keyword=jaccard, atomic=Jaccard, atomic path=gameDistance.metrics.bagOfWords.Jaccard
~~~~ <jensenShannonDivergence> name=JensenShannonDivergence type=Ludeme (gameDistance.metrics.bagOfWords.JensenShannonDivergence) => <jensenShannonDivergence>, pack=gameDistance.metrics.bagOfWords, label=jensenShannonDivergence, cls=gameDistance.metrics.bagOfWords.JensenShannonDivergence, keyword=jensenShannonDivergence, atomic=JensenShannonDivergence, atomic path=gameDistance.metrics.bagOfWords.JensenShannonDivergence
~~~~ <overlap> name=Overlap type=Ludeme (gameDistance.metrics.bagOfWords.Overlap) => <overlap>, pack=gameDistance.metrics.bagOfWords, label=overlap, cls=gameDistance.metrics.bagOfWords.Overlap, keyword=overlap, atomic=Overlap, atomic path=gameDistance.metrics.bagOfWords.Overlap
~~~~ <globalAlignment> name=GlobalAlignment type=Ludeme (gameDistance.metrics.sequence.GlobalAlignment) => <globalAlignment>, pack=gameDistance.metrics.sequence, label=globalAlignment, cls=gameDistance.metrics.sequence.GlobalAlignment, keyword=globalAlignment, atomic=GlobalAlignment, atomic path=gameDistance.metrics.sequence.GlobalAlignment
~~~~ <levenshtein> name=Levenshtein type=Ludeme (gameDistance.metrics.sequence.Levenshtein) => <levenshtein>, pack=gameDistance.metrics.sequence, label=levenshtein, cls=gameDistance.metrics.sequence.Levenshtein, keyword=levenshtein, atomic=Levenshtein, atomic path=gameDistance.metrics.sequence.Levenshtein
~~~~ <localAlignment> name=LocalAlignment type=Ludeme (gameDistance.metrics.sequence.LocalAlignment) => <localAlignment>, pack=gameDistance.metrics.sequence, label=localAlignment, cls=gameDistance.metrics.sequence.LocalAlignment, keyword=localAlignment, atomic=LocalAlignment, atomic path=gameDistance.metrics.sequence.LocalAlignment
~~~~ <repeatedLocalAlignment> name=RepeatedLocalAlignment type=Ludeme (gameDistance.metrics.sequence.RepeatedLocalAlignment) => <repeatedLocalAlignment>, pack=gameDistance.metrics.sequence, label=repeatedLocalAlignment, cls=gameDistance.metrics.sequence.RepeatedLocalAlignment, keyword=repeatedLocalAlignment, atomic=RepeatedLocalAlignment, atomic path=gameDistance.metrics.sequence.RepeatedLocalAlignment
~~~~ <apted> name=Apted type=Ludeme (gameDistance.metrics.treeEdit.Apted) => <apted>, pack=gameDistance.metrics.treeEdit, label=apted, cls=gameDistance.metrics.treeEdit.Apted, keyword=apted, atomic=Apted, atomic path=gameDistance.metrics.treeEdit.Apted
~~~~ <zhangShasha> name=ZhangShasha type=Ludeme (gameDistance.metrics.treeEdit.ZhangShasha) => <zhangShasha>, pack=gameDistance.metrics.treeEdit, label=zhangShasha, cls=gameDistance.metrics.treeEdit.ZhangShasha, keyword=zhangShasha, atomic=ZhangShasha, atomic path=gameDistance.metrics.treeEdit.ZhangShasha
~~~~ <distanceUtils> name=DistanceUtils type=Ludeme (gameDistance.utils.DistanceUtils) => <distanceUtils>, pack=gameDistance.utils, label=distanceUtils, cls=gameDistance.utils.DistanceUtils, keyword=distanceUtils, atomic=DistanceUtils, atomic path=gameDistance.utils.DistanceUtils
~~~* <costModel> name=CostModel type=Structural (gameDistance.utils.apted.costmodel.CostModel) => <costModel>, pack=gameDistance.utils.apted.costmodel, label=costModel, cls=gameDistance.utils.apted.costmodel.CostModel, keyword=costModel, atomic=CostModel, atomic path=gameDistance.utils.apted.costmodel.CostModel
~~~~ <perEditOperationStringNodeDataCostModel> name=PerEditOperationStringNodeDataCostModel type=Ludeme (gameDistance.utils.apted.costmodel.PerEditOperationStringNodeDataCostModel) => <perEditOperationStringNodeDataCostModel>, pack=gameDistance.utils.apted.costmodel, label=perEditOperationStringNodeDataCostModel, cls=gameDistance.utils.apted.costmodel.PerEditOperationStringNodeDataCostModel, keyword=perEditOperationStringNodeDataCostModel, atomic=PerEditOperationStringNodeDataCostModel, atomic path=gameDistance.utils.apted.costmodel.PerEditOperationStringNodeDataCostModel
~~~~ <stringUnitCostModel> name=StringUnitCostModel type=Ludeme (gameDistance.utils.apted.costmodel.StringUnitCostModel) => <stringUnitCostModel>, pack=gameDistance.utils.apted.costmodel, label=stringUnitCostModel, cls=gameDistance.utils.apted.costmodel.StringUnitCostModel, keyword=stringUnitCostModel, atomic=StringUnitCostModel, atomic path=gameDistance.utils.apted.costmodel.StringUnitCostModel
~~~~ <aPTED> name=APTED type=Ludeme (gameDistance.utils.apted.distance.APTED) => <aPTED>, pack=gameDistance.utils.apted.distance, label=aPTED, cls=gameDistance.utils.apted.distance.APTED, keyword=aPTED, atomic=APTED, atomic path=gameDistance.utils.apted.distance.APTED
~~~~ <allPossibleMappingsTED> name=AllPossibleMappingsTED type=Ludeme (gameDistance.utils.apted.distance.AllPossibleMappingsTED) => <allPossibleMappingsTED>, pack=gameDistance.utils.apted.distance, label=allPossibleMappingsTED, cls=gameDistance.utils.apted.distance.AllPossibleMappingsTED, keyword=allPossibleMappingsTED, atomic=AllPossibleMappingsTED, atomic path=gameDistance.utils.apted.distance.AllPossibleMappingsTED
~~~~ <node> name=Node type=Ludeme (gameDistance.utils.apted.node.Node) => <node>, pack=gameDistance.utils.apted.node, label=node, cls=gameDistance.utils.apted.node.Node, keyword=node, atomic=Node, atomic path=gameDistance.utils.apted.node.Node
~~~~ <nodeIndexer> name=NodeIndexer type=Ludeme (gameDistance.utils.apted.node.NodeIndexer) => <nodeIndexer>, pack=gameDistance.utils.apted.node, label=nodeIndexer, cls=gameDistance.utils.apted.node.NodeIndexer, keyword=nodeIndexer, atomic=NodeIndexer, atomic path=gameDistance.utils.apted.node.NodeIndexer
~~~~ <stringNodeData> name=StringNodeData type=Ludeme (gameDistance.utils.apted.node.StringNodeData) => <stringNodeData>, pack=gameDistance.utils.apted.node, label=stringNodeData, cls=gameDistance.utils.apted.node.StringNodeData, keyword=stringNodeData, atomic=StringNodeData, atomic path=gameDistance.utils.apted.node.StringNodeData
~~~~ <bracketStringInputParser> name=BracketStringInputParser type=Ludeme (gameDistance.utils.apted.parser.BracketStringInputParser) => <bracketStringInputParser>, pack=gameDistance.utils.apted.parser, label=bracketStringInputParser, cls=gameDistance.utils.apted.parser.BracketStringInputParser, keyword=bracketStringInputParser, atomic=BracketStringInputParser, atomic path=gameDistance.utils.apted.parser.BracketStringInputParser
~~~* <inputParser> name=InputParser type=Structural (gameDistance.utils.apted.parser.InputParser) => <inputParser>, pack=gameDistance.utils.apted.parser, label=inputParser, cls=gameDistance.utils.apted.parser.InputParser, keyword=inputParser, atomic=InputParser, atomic path=gameDistance.utils.apted.parser.InputParser
~~~~ <correctnes> name=Correctnes type=Ludeme (gameDistance.utils.apted.test.java.CorrectnessTest) => <correctnes>, pack=gameDistance.utils.apted.test.java, label=correctnes, cls=gameDistance.utils.apted.test.java.CorrectnessTest, keyword=correctnes, atomic=Correctnes, atomic path=gameDistance.utils.apted.test.java.CorrectnessTest
~~~~ <perEditOperationCorrectnes> name=PerEditOperationCorrectnes type=Ludeme (gameDistance.utils.apted.test.java.PerEditOperationCorrectnessTest) => <perEditOperationCorrectnes>, pack=gameDistance.utils.apted.test.java, label=perEditOperationCorrectnes, cls=gameDistance.utils.apted.test.java.PerEditOperationCorrectnessTest, keyword=perEditOperationCorrectnes, atomic=PerEditOperationCorrectnes, atomic path=gameDistance.utils.apted.test.java.PerEditOperationCorrectnessTest
~~~~ <commandLine> name=CommandLine type=Ludeme (gameDistance.utils.apted.util.CommandLine) => <commandLine>, pack=gameDistance.utils.apted.util, label=commandLine, cls=gameDistance.utils.apted.util.CommandLine, keyword=commandLine, atomic=CommandLine, atomic path=gameDistance.utils.apted.util.CommandLine
~~~~ <formatUtilities> name=FormatUtilities type=Ludeme (gameDistance.utils.apted.util.FormatUtilities) => <formatUtilities>, pack=gameDistance.utils.apted.util, label=formatUtilities, cls=gameDistance.utils.apted.util.FormatUtilities, keyword=formatUtilities, atomic=FormatUtilities, atomic path=gameDistance.utils.apted.util.FormatUtilities
~~m~ <metadata> name=Metadata type=Structural (metadata.Metadata) => <metadata>, pack=metadata, label=metadata, cls=metadata.Metadata, keyword=metadata, atomic=Metadata, atomic path=metadata.Metadata
~~m* <metadataItem> name=MetadataItem type=Structural (metadata.MetadataItem) => <metadataItem>, pack=metadata, label=metadataItem, cls=metadata.MetadataItem, keyword=metadataItem, atomic=MetadataItem, atomic path=metadata.MetadataItem
~~m* <aIItem> name=AIItem type=Structural (metadata.ai.AIItem) => <aIItem>, pack=metadata.ai, label=aIItem, cls=metadata.ai.AIItem, keyword=aIItem, atomic=AIItem, atomic path=metadata.ai.AIItem
~~m~ <ai> name=Ai type=Structural (metadata.ai.Ai) => <ai>, pack=metadata.ai, label=ai, cls=metadata.ai.Ai, keyword=ai, atomic=Ai, atomic path=metadata.ai.Ai
~~m* <agent> name=Agent type=Structural (metadata.ai.agents.Agent) => <agent>, pack=metadata.ai.agents, label=agent, cls=metadata.ai.agents.Agent, keyword=agent, atomic=Agent, atomic path=metadata.ai.agents.Agent
~~m~ <bestAgent> name=BestAgent type=Structural (metadata.ai.agents.BestAgent) => <bestAgent>, pack=metadata.ai.agents, label=bestAgent, cls=metadata.ai.agents.BestAgent, keyword=bestAgent, atomic=BestAgent, atomic path=metadata.ai.agents.BestAgent
~~m~ <mcts> name=Mcts type=Structural (metadata.ai.agents.mcts.Mcts) => <mcts>, pack=metadata.ai.agents.mcts, label=mcts, cls=metadata.ai.agents.mcts.Mcts, keyword=mcts, atomic=Mcts, atomic path=metadata.ai.agents.mcts.Mcts
~~m~ <ag0> name=Ag0 type=Structural (metadata.ai.agents.mcts.selection.Ag0) => <ag0>, pack=metadata.ai.agents.mcts.selection, label=ag0, cls=metadata.ai.agents.mcts.selection.Ag0, keyword=ag0, atomic=Ag0, atomic path=metadata.ai.agents.mcts.selection.Ag0
~~m* <selection> name=Selection type=Structural (metadata.ai.agents.mcts.selection.Selection) => <selection>, pack=metadata.ai.agents.mcts.selection, label=selection, cls=metadata.ai.agents.mcts.selection.Selection, keyword=selection, atomic=Selection, atomic path=metadata.ai.agents.mcts.selection.Selection
~~m~ <ucb1> name=Ucb1 type=Structural (metadata.ai.agents.mcts.selection.Ucb1) => <ucb1>, pack=metadata.ai.agents.mcts.selection, label=ucb1, cls=metadata.ai.agents.mcts.selection.Ucb1, keyword=ucb1, atomic=Ucb1, atomic path=metadata.ai.agents.mcts.selection.Ucb1
~~m~ <alphaBeta> name=AlphaBeta type=Structural (metadata.ai.agents.minimax.AlphaBeta) => <alphaBeta>, pack=metadata.ai.agents.minimax, label=alphaBeta, cls=metadata.ai.agents.minimax.AlphaBeta, keyword=alphaBeta, atomic=AlphaBeta, atomic path=metadata.ai.agents.minimax.AlphaBeta
~~m~ <featureSet> name=FeatureSet type=Structural (metadata.ai.features.FeatureSet) => <featureSet>, pack=metadata.ai.features, label=featureSet, cls=metadata.ai.features.FeatureSet, keyword=featureSet, atomic=FeatureSet, atomic path=metadata.ai.features.FeatureSet
~~m~ <features> name=Features type=Structural (metadata.ai.features.Features) => <features>, pack=metadata.ai.features, label=features, cls=metadata.ai.features.Features, keyword=features, atomic=Features, atomic path=metadata.ai.features.Features
~~m~ <featureTrees> name=FeatureTrees type=Structural (metadata.ai.features.trees.FeatureTrees) => <featureTrees>, pack=metadata.ai.features.trees, label=featureTrees, cls=metadata.ai.features.trees.FeatureTrees, keyword=featureTrees, atomic=FeatureTrees, atomic path=metadata.ai.features.trees.FeatureTrees
~~m~ <binaryLeaf> name=BinaryLeaf type=Structural (metadata.ai.features.trees.classifiers.BinaryLeaf) => <binaryLeaf>, pack=metadata.ai.features.trees.classifiers, label=binaryLeaf, cls=metadata.ai.features.trees.classifiers.BinaryLeaf, keyword=binaryLeaf, atomic=BinaryLeaf, atomic path=metadata.ai.features.trees.classifiers.BinaryLeaf
~~m~ <decisionTree> name=DecisionTree type=Structural (metadata.ai.features.trees.classifiers.DecisionTree) => <decisionTree>, pack=metadata.ai.features.trees.classifiers, label=decisionTree, cls=metadata.ai.features.trees.classifiers.DecisionTree, keyword=decisionTree, atomic=DecisionTree, atomic path=metadata.ai.features.trees.classifiers.DecisionTree
~~m* <decisionTreeNode> name=DecisionTreeNode type=Structural (metadata.ai.features.trees.classifiers.DecisionTreeNode) => <decisionTreeNode>, pack=metadata.ai.features.trees.classifiers, label=decisionTreeNode, cls=metadata.ai.features.trees.classifiers.DecisionTreeNode, keyword=decisionTreeNode, atomic=DecisionTreeNode, atomic path=metadata.ai.features.trees.classifiers.DecisionTreeNode
~~m~ <classifiers.if> name=If type=Structural (metadata.ai.features.trees.classifiers.If) => <classifiers.if>, pack=metadata.ai.features.trees.classifiers, label=classifiers.if, cls=metadata.ai.features.trees.classifiers.If, keyword=if, atomic=If, atomic path=metadata.ai.features.trees.classifiers.If
~~m~ <classifiers.leaf> name=Leaf type=Structural (metadata.ai.features.trees.classifiers.Leaf) => <classifiers.leaf>, pack=metadata.ai.features.trees.classifiers, label=classifiers.leaf, cls=metadata.ai.features.trees.classifiers.Leaf, keyword=leaf, atomic=Leaf, atomic path=metadata.ai.features.trees.classifiers.Leaf
~~m~ <logits.if> name=If type=Structural (metadata.ai.features.trees.logits.If) => <logits.if>, pack=metadata.ai.features.trees.logits, label=logits.if, cls=metadata.ai.features.trees.logits.If, keyword=if, atomic=If, atomic path=metadata.ai.features.trees.logits.If
~~m~ <logits.leaf> name=Leaf type=Structural (metadata.ai.features.trees.logits.Leaf) => <logits.leaf>, pack=metadata.ai.features.trees.logits, label=logits.leaf, cls=metadata.ai.features.trees.logits.Leaf, keyword=leaf, atomic=Leaf, atomic path=metadata.ai.features.trees.logits.Leaf
~~m* <logitNode> name=LogitNode type=Structural (metadata.ai.features.trees.logits.LogitNode) => <logitNode>, pack=metadata.ai.features.trees.logits, label=logitNode, cls=metadata.ai.features.trees.logits.LogitNode, keyword=logitNode, atomic=LogitNode, atomic path=metadata.ai.features.trees.logits.LogitNode
~~m~ <logitTree> name=LogitTree type=Structural (metadata.ai.features.trees.logits.LogitTree) => <logitTree>, pack=metadata.ai.features.trees.logits, label=logitTree, cls=metadata.ai.features.trees.logits.LogitTree, keyword=logitTree, atomic=LogitTree, atomic path=metadata.ai.features.trees.logits.LogitTree
~~m~ <heuristicUtil> name=HeuristicUtil type=Ludeme (metadata.ai.heuristics.HeuristicUtil) => <heuristicUtil>, pack=metadata.ai.heuristics, label=heuristicUtil, cls=metadata.ai.heuristics.HeuristicUtil, keyword=heuristicUtil, atomic=HeuristicUtil, atomic path=metadata.ai.heuristics.HeuristicUtil
~~m~ <heuristics> name=Heuristics type=Structural (metadata.ai.heuristics.Heuristics) => <heuristics>, pack=metadata.ai.heuristics, label=heuristics, cls=metadata.ai.heuristics.Heuristics, keyword=heuristics, atomic=Heuristics, atomic path=metadata.ai.heuristics.Heuristics
~~m~ <centreProximity> name=CentreProximity type=Structural (metadata.ai.heuristics.terms.CentreProximity) => <centreProximity>, pack=metadata.ai.heuristics.terms, label=centreProximity, cls=metadata.ai.heuristics.terms.CentreProximity, keyword=centreProximity, atomic=CentreProximity, atomic path=metadata.ai.heuristics.terms.CentreProximity
~~m~ <componentValues> name=ComponentValues type=Structural (metadata.ai.heuristics.terms.ComponentValues) => <componentValues>, pack=metadata.ai.heuristics.terms, label=componentValues, cls=metadata.ai.heuristics.terms.ComponentValues, keyword=componentValues, atomic=ComponentValues, atomic path=metadata.ai.heuristics.terms.ComponentValues
~~m~ <cornerProximity> name=CornerProximity type=Structural (metadata.ai.heuristics.terms.CornerProximity) => <cornerProximity>, pack=metadata.ai.heuristics.terms, label=cornerProximity, cls=metadata.ai.heuristics.terms.CornerProximity, keyword=cornerProximity, atomic=CornerProximity, atomic path=metadata.ai.heuristics.terms.CornerProximity
~~m~ <currentMoverHeuristic> name=CurrentMoverHeuristic type=Structural (metadata.ai.heuristics.terms.CurrentMoverHeuristic) => <currentMoverHeuristic>, pack=metadata.ai.heuristics.terms, label=currentMoverHeuristic, cls=metadata.ai.heuristics.terms.CurrentMoverHeuristic, keyword=currentMoverHeuristic, atomic=CurrentMoverHeuristic, atomic path=metadata.ai.heuristics.terms.CurrentMoverHeuristic
~~m* <heuristicTerm> name=HeuristicTerm type=Structural (metadata.ai.heuristics.terms.HeuristicTerm) => <heuristicTerm>, pack=metadata.ai.heuristics.terms, label=heuristicTerm, cls=metadata.ai.heuristics.terms.HeuristicTerm, keyword=heuristicTerm, atomic=HeuristicTerm, atomic path=metadata.ai.heuristics.terms.HeuristicTerm
~~m~ <influence> name=Influence type=Structural (metadata.ai.heuristics.terms.Influence) => <influence>, pack=metadata.ai.heuristics.terms, label=influence, cls=metadata.ai.heuristics.terms.Influence, keyword=influence, atomic=Influence, atomic path=metadata.ai.heuristics.terms.Influence
~~m~ <influenceAdvanced> name=InfluenceAdvanced type=Structural (metadata.ai.heuristics.terms.InfluenceAdvanced) => <influenceAdvanced>, pack=metadata.ai.heuristics.terms, label=influenceAdvanced, cls=metadata.ai.heuristics.terms.InfluenceAdvanced, keyword=influenceAdvanced, atomic=InfluenceAdvanced, atomic path=metadata.ai.heuristics.terms.InfluenceAdvanced
~~m~ <intercept> name=Intercept type=Structural (metadata.ai.heuristics.terms.Intercept) => <intercept>, pack=metadata.ai.heuristics.terms, label=intercept, cls=metadata.ai.heuristics.terms.Intercept, keyword=intercept, atomic=Intercept, atomic path=metadata.ai.heuristics.terms.Intercept
~~m~ <lineCompletionHeuristic> name=LineCompletionHeuristic type=Structural (metadata.ai.heuristics.terms.LineCompletionHeuristic) => <lineCompletionHeuristic>, pack=metadata.ai.heuristics.terms, label=lineCompletionHeuristic, cls=metadata.ai.heuristics.terms.LineCompletionHeuristic, keyword=lineCompletionHeuristic, atomic=LineCompletionHeuristic, atomic path=metadata.ai.heuristics.terms.LineCompletionHeuristic
~~m~ <material> name=Material type=Structural (metadata.ai.heuristics.terms.Material) => <material>, pack=metadata.ai.heuristics.terms, label=material, cls=metadata.ai.heuristics.terms.Material, keyword=material, atomic=Material, atomic path=metadata.ai.heuristics.terms.Material
~~m~ <mobilityAdvanced> name=MobilityAdvanced type=Structural (metadata.ai.heuristics.terms.MobilityAdvanced) => <mobilityAdvanced>, pack=metadata.ai.heuristics.terms, label=mobilityAdvanced, cls=metadata.ai.heuristics.terms.MobilityAdvanced, keyword=mobilityAdvanced, atomic=MobilityAdvanced, atomic path=metadata.ai.heuristics.terms.MobilityAdvanced
~~m~ <mobilitySimple> name=MobilitySimple type=Structural (metadata.ai.heuristics.terms.MobilitySimple) => <mobilitySimple>, pack=metadata.ai.heuristics.terms, label=mobilitySimple, cls=metadata.ai.heuristics.terms.MobilitySimple, keyword=mobilitySimple, atomic=MobilitySimple, atomic path=metadata.ai.heuristics.terms.MobilitySimple
~~m~ <nullHeuristic> name=NullHeuristic type=Structural (metadata.ai.heuristics.terms.NullHeuristic) => <nullHeuristic>, pack=metadata.ai.heuristics.terms, label=nullHeuristic, cls=metadata.ai.heuristics.terms.NullHeuristic, keyword=nullHeuristic, atomic=NullHeuristic, atomic path=metadata.ai.heuristics.terms.NullHeuristic
~~m~ <ownRegionsCount> name=OwnRegionsCount type=Structural (metadata.ai.heuristics.terms.OwnRegionsCount) => <ownRegionsCount>, pack=metadata.ai.heuristics.terms, label=ownRegionsCount, cls=metadata.ai.heuristics.terms.OwnRegionsCount, keyword=ownRegionsCount, atomic=OwnRegionsCount, atomic path=metadata.ai.heuristics.terms.OwnRegionsCount
~~m~ <playerRegionsProximity> name=PlayerRegionsProximity type=Structural (metadata.ai.heuristics.terms.PlayerRegionsProximity) => <playerRegionsProximity>, pack=metadata.ai.heuristics.terms, label=playerRegionsProximity, cls=metadata.ai.heuristics.terms.PlayerRegionsProximity, keyword=playerRegionsProximity, atomic=PlayerRegionsProximity, atomic path=metadata.ai.heuristics.terms.PlayerRegionsProximity
~~m~ <playerSiteMapCount> name=PlayerSiteMapCount type=Structural (metadata.ai.heuristics.terms.PlayerSiteMapCount) => <playerSiteMapCount>, pack=metadata.ai.heuristics.terms, label=playerSiteMapCount, cls=metadata.ai.heuristics.terms.PlayerSiteMapCount, keyword=playerSiteMapCount, atomic=PlayerSiteMapCount, atomic path=metadata.ai.heuristics.terms.PlayerSiteMapCount
~~m~ <regionProximity> name=RegionProximity type=Structural (metadata.ai.heuristics.terms.RegionProximity) => <regionProximity>, pack=metadata.ai.heuristics.terms, label=regionProximity, cls=metadata.ai.heuristics.terms.RegionProximity, keyword=regionProximity, atomic=RegionProximity, atomic path=metadata.ai.heuristics.terms.RegionProximity
~~m~ <terms.score> name=Score type=Structural (metadata.ai.heuristics.terms.Score) => <terms.score>, pack=metadata.ai.heuristics.terms, label=terms.score, cls=metadata.ai.heuristics.terms.Score, keyword=score, atomic=Score, atomic path=metadata.ai.heuristics.terms.Score
~~m~ <sidesProximity> name=SidesProximity type=Structural (metadata.ai.heuristics.terms.SidesProximity) => <sidesProximity>, pack=metadata.ai.heuristics.terms, label=sidesProximity, cls=metadata.ai.heuristics.terms.SidesProximity, keyword=sidesProximity, atomic=SidesProximity, atomic path=metadata.ai.heuristics.terms.SidesProximity
~~m~ <unthreatenedMaterial> name=UnthreatenedMaterial type=Structural (metadata.ai.heuristics.terms.UnthreatenedMaterial) => <unthreatenedMaterial>, pack=metadata.ai.heuristics.terms, label=unthreatenedMaterial, cls=metadata.ai.heuristics.terms.UnthreatenedMaterial, keyword=unthreatenedMaterial, atomic=UnthreatenedMaterial, atomic path=metadata.ai.heuristics.terms.UnthreatenedMaterial
~~m~ <divNumBoardSites> name=DivNumBoardSites type=Structural (metadata.ai.heuristics.transformations.DivNumBoardSites) => <divNumBoardSites>, pack=metadata.ai.heuristics.transformations, label=divNumBoardSites, cls=metadata.ai.heuristics.transformations.DivNumBoardSites, keyword=divNumBoardSites, atomic=DivNumBoardSites, atomic path=metadata.ai.heuristics.transformations.DivNumBoardSites
~~m~ <divNumInitPlacement> name=DivNumInitPlacement type=Structural (metadata.ai.heuristics.transformations.DivNumInitPlacement) => <divNumInitPlacement>, pack=metadata.ai.heuristics.transformations, label=divNumInitPlacement, cls=metadata.ai.heuristics.transformations.DivNumInitPlacement, keyword=divNumInitPlacement, atomic=DivNumInitPlacement, atomic path=metadata.ai.heuristics.transformations.DivNumInitPlacement
~~m* <heuristicTransformation> name=HeuristicTransformation type=Structural (metadata.ai.heuristics.transformations.HeuristicTransformation) => <heuristicTransformation>, pack=metadata.ai.heuristics.transformations, label=heuristicTransformation, cls=metadata.ai.heuristics.transformations.HeuristicTransformation, keyword=heuristicTransformation, atomic=HeuristicTransformation, atomic path=metadata.ai.heuristics.transformations.HeuristicTransformation
~~m~ <logisticFunction> name=LogisticFunction type=Structural (metadata.ai.heuristics.transformations.LogisticFunction) => <logisticFunction>, pack=metadata.ai.heuristics.transformations, label=logisticFunction, cls=metadata.ai.heuristics.transformations.LogisticFunction, keyword=logisticFunction, atomic=LogisticFunction, atomic path=metadata.ai.heuristics.transformations.LogisticFunction
~~m~ <tanh> name=Tanh type=Structural (metadata.ai.heuristics.transformations.Tanh) => <tanh>, pack=metadata.ai.heuristics.transformations, label=tanh, cls=metadata.ai.heuristics.transformations.Tanh, keyword=tanh, atomic=Tanh, atomic path=metadata.ai.heuristics.transformations.Tanh
~~m~ <misc.pair> name=Pair type=Structural (metadata.ai.misc.Pair) => <misc.pair>, pack=metadata.ai.misc, label=misc.pair, cls=metadata.ai.misc.Pair, keyword=pair, atomic=Pair, atomic path=metadata.ai.misc.Pair
~~m~ <graphics> name=Graphics type=Structural (metadata.graphics.Graphics) => <graphics>, pack=metadata.graphics, label=graphics, cls=metadata.graphics.Graphics, keyword=graphics, atomic=Graphics, atomic path=metadata.graphics.Graphics
~~m* <graphicsItem> name=GraphicsItem type=Structural (metadata.graphics.GraphicsItem) => <graphicsItem>, pack=metadata.graphics, label=graphicsItem, cls=metadata.graphics.GraphicsItem, keyword=graphicsItem, atomic=GraphicsItem, atomic path=metadata.graphics.GraphicsItem
~~m~ <graphics.board.board> name=Board type=Structural (metadata.graphics.board.Board) => <graphics.board.board>, pack=metadata.graphics.board, label=graphics.board.board, cls=metadata.graphics.board.Board, keyword=board, atomic=Board, atomic path=metadata.graphics.board.Board
~~m~ <boardBooleanType> name=BoardBooleanType type=Structural (metadata.graphics.board.BoardBooleanType) => <boardBooleanType>, pack=metadata.graphics.board, label=boardBooleanType, cls=metadata.graphics.board.BoardBooleanType, keyword=boardBooleanType, atomic=BoardBooleanType, atomic path=metadata.graphics.board.BoardBooleanType
~~m~ <boardColourType> name=BoardColourType type=Structural (metadata.graphics.board.BoardColourType) => <boardColourType>, pack=metadata.graphics.board, label=boardColourType, cls=metadata.graphics.board.BoardColourType, keyword=boardColourType, atomic=BoardColourType, atomic path=metadata.graphics.board.BoardColourType
~~m~ <boardCurvatureType> name=BoardCurvatureType type=Structural (metadata.graphics.board.BoardCurvatureType) => <boardCurvatureType>, pack=metadata.graphics.board, label=boardCurvatureType, cls=metadata.graphics.board.BoardCurvatureType, keyword=boardCurvatureType, atomic=BoardCurvatureType, atomic path=metadata.graphics.board.BoardCurvatureType
~~m~ <boardPlacementType> name=BoardPlacementType type=Structural (metadata.graphics.board.BoardPlacementType) => <boardPlacementType>, pack=metadata.graphics.board, label=boardPlacementType, cls=metadata.graphics.board.BoardPlacementType, keyword=boardPlacementType, atomic=BoardPlacementType, atomic path=metadata.graphics.board.BoardPlacementType
~~m~ <boardStyleThicknessType> name=BoardStyleThicknessType type=Structural (metadata.graphics.board.BoardStyleThicknessType) => <boardStyleThicknessType>, pack=metadata.graphics.board, label=boardStyleThicknessType, cls=metadata.graphics.board.BoardStyleThicknessType, keyword=boardStyleThicknessType, atomic=BoardStyleThicknessType, atomic path=metadata.graphics.board.BoardStyleThicknessType
~~m~ <boardStyleType> name=BoardStyleType type=Structural (metadata.graphics.board.BoardStyleType) => <boardStyleType>, pack=metadata.graphics.board, label=boardStyleType, cls=metadata.graphics.board.BoardStyleType, keyword=boardStyleType, atomic=BoardStyleType, atomic path=metadata.graphics.board.BoardStyleType
~~m~ <boardCheckered> name=BoardCheckered type=Ludeme (metadata.graphics.board.Boolean.BoardCheckered) => <boardCheckered>, pack=metadata.graphics.board.Boolean, label=boardCheckered, cls=metadata.graphics.board.Boolean.BoardCheckered, keyword=boardCheckered, atomic=BoardCheckered, atomic path=metadata.graphics.board.Boolean.BoardCheckered
~~m~ <boardColour> name=BoardColour type=Ludeme (metadata.graphics.board.colour.BoardColour) => <boardColour>, pack=metadata.graphics.board.colour, label=boardColour, cls=metadata.graphics.board.colour.BoardColour, keyword=boardColour, atomic=BoardColour, atomic path=metadata.graphics.board.colour.BoardColour
~~m~ <boardCurvature> name=BoardCurvature type=Ludeme (metadata.graphics.board.curvature.BoardCurvature) => <boardCurvature>, pack=metadata.graphics.board.curvature, label=boardCurvature, cls=metadata.graphics.board.curvature.BoardCurvature, keyword=boardCurvature, atomic=BoardCurvature, atomic path=metadata.graphics.board.curvature.BoardCurvature
~~m~ <boardBackground> name=BoardBackground type=Ludeme (metadata.graphics.board.ground.BoardBackground) => <boardBackground>, pack=metadata.graphics.board.ground, label=boardBackground, cls=metadata.graphics.board.ground.BoardBackground, keyword=boardBackground, atomic=BoardBackground, atomic path=metadata.graphics.board.ground.BoardBackground
~~m~ <boardForeground> name=BoardForeground type=Ludeme (metadata.graphics.board.ground.BoardForeground) => <boardForeground>, pack=metadata.graphics.board.ground, label=boardForeground, cls=metadata.graphics.board.ground.BoardForeground, keyword=boardForeground, atomic=BoardForeground, atomic path=metadata.graphics.board.ground.BoardForeground
~~m~ <boardPlacement> name=BoardPlacement type=Ludeme (metadata.graphics.board.placement.BoardPlacement) => <boardPlacement>, pack=metadata.graphics.board.placement, label=boardPlacement, cls=metadata.graphics.board.placement.BoardPlacement, keyword=boardPlacement, atomic=BoardPlacement, atomic path=metadata.graphics.board.placement.BoardPlacement
~~m~ <boardShape> name=BoardShape type=Ludeme (metadata.graphics.board.shape.BoardShape) => <boardShape>, pack=metadata.graphics.board.shape, label=boardShape, cls=metadata.graphics.board.shape.BoardShape, keyword=boardShape, atomic=BoardShape, atomic path=metadata.graphics.board.shape.BoardShape
~~m~ <boardStyleThickness> name=BoardStyleThickness type=Ludeme (metadata.graphics.board.styleThickness.BoardStyleThickness) => <boardStyleThickness>, pack=metadata.graphics.board.styleThickness, label=boardStyleThickness, cls=metadata.graphics.board.styleThickness.BoardStyleThickness, keyword=boardStyleThickness, atomic=BoardStyleThickness, atomic path=metadata.graphics.board.styleThickness.BoardStyleThickness
~~m~ <boardStyle> name=BoardStyle type=Ludeme (metadata.graphics.board.style.BoardStyle) => <boardStyle>, pack=metadata.graphics.board.style, label=boardStyle, cls=metadata.graphics.board.style.BoardStyle, keyword=boardStyle, atomic=BoardStyle, atomic path=metadata.graphics.board.style.BoardStyle
~~m~ <hand.hand> name=Hand type=Structural (metadata.graphics.hand.Hand) => <hand.hand>, pack=metadata.graphics.hand, label=hand.hand, cls=metadata.graphics.hand.Hand, keyword=hand, atomic=Hand, atomic path=metadata.graphics.hand.Hand
~~m~ <handPlacementType> name=HandPlacementType type=Structural (metadata.graphics.hand.HandPlacementType) => <handPlacementType>, pack=metadata.graphics.hand, label=handPlacementType, cls=metadata.graphics.hand.HandPlacementType, keyword=handPlacementType, atomic=HandPlacementType, atomic path=metadata.graphics.hand.HandPlacementType
~~m~ <handPlacement> name=HandPlacement type=Ludeme (metadata.graphics.hand.placement.HandPlacement) => <handPlacement>, pack=metadata.graphics.hand.placement, label=handPlacement, cls=metadata.graphics.hand.placement.HandPlacement, keyword=handPlacement, atomic=HandPlacement, atomic path=metadata.graphics.hand.placement.HandPlacement
~~m~ <noAnimation> name=NoAnimation type=Ludeme (metadata.graphics.no.Boolean.NoAnimation) => <noAnimation>, pack=metadata.graphics.no.Boolean, label=noAnimation, cls=metadata.graphics.no.Boolean.NoAnimation, keyword=noAnimation, atomic=NoAnimation, atomic path=metadata.graphics.no.Boolean.NoAnimation
~~m~ <noBoard> name=NoBoard type=Ludeme (metadata.graphics.no.Boolean.NoBoard) => <noBoard>, pack=metadata.graphics.no.Boolean, label=noBoard, cls=metadata.graphics.no.Boolean.NoBoard, keyword=noBoard, atomic=NoBoard, atomic path=metadata.graphics.no.Boolean.NoBoard
~~m~ <noCurves> name=NoCurves type=Ludeme (metadata.graphics.no.Boolean.NoCurves) => <noCurves>, pack=metadata.graphics.no.Boolean, label=noCurves, cls=metadata.graphics.no.Boolean.NoCurves, keyword=noCurves, atomic=NoCurves, atomic path=metadata.graphics.no.Boolean.NoCurves
~~m~ <noDicePips> name=NoDicePips type=Ludeme (metadata.graphics.no.Boolean.NoDicePips) => <noDicePips>, pack=metadata.graphics.no.Boolean, label=noDicePips, cls=metadata.graphics.no.Boolean.NoDicePips, keyword=noDicePips, atomic=NoDicePips, atomic path=metadata.graphics.no.Boolean.NoDicePips
~~m~ <noSunken> name=NoSunken type=Ludeme (metadata.graphics.no.Boolean.NoSunken) => <noSunken>, pack=metadata.graphics.no.Boolean, label=noSunken, cls=metadata.graphics.no.Boolean.NoSunken, keyword=noSunken, atomic=NoSunken, atomic path=metadata.graphics.no.Boolean.NoSunken
~~m~ <graphics.no.no> name=No type=Structural (metadata.graphics.no.No) => <graphics.no.no>, pack=metadata.graphics.no, label=graphics.no.no, cls=metadata.graphics.no.No, keyword=no, atomic=No, atomic path=metadata.graphics.no.No
~~m~ <noBooleanType> name=NoBooleanType type=Structural (metadata.graphics.no.NoBooleanType) => <noBooleanType>, pack=metadata.graphics.no, label=noBooleanType, cls=metadata.graphics.no.NoBooleanType, keyword=noBooleanType, atomic=NoBooleanType, atomic path=metadata.graphics.no.NoBooleanType
~~m~ <hiddenImage> name=HiddenImage type=Structural (metadata.graphics.others.HiddenImage) => <hiddenImage>, pack=metadata.graphics.others, label=hiddenImage, cls=metadata.graphics.others.HiddenImage, keyword=hiddenImage, atomic=HiddenImage, atomic path=metadata.graphics.others.HiddenImage
~~m~ <stackType> name=StackType type=Structural (metadata.graphics.others.StackType) => <stackType>, pack=metadata.graphics.others, label=stackType, cls=metadata.graphics.others.StackType, keyword=stackType, atomic=StackType, atomic path=metadata.graphics.others.StackType
~~m~ <suitRanking> name=SuitRanking type=Structural (metadata.graphics.others.SuitRanking) => <suitRanking>, pack=metadata.graphics.others, label=suitRanking, cls=metadata.graphics.others.SuitRanking, keyword=suitRanking, atomic=SuitRanking, atomic path=metadata.graphics.others.SuitRanking
~~m~ <piece.piece> name=Piece type=Structural (metadata.graphics.piece.Piece) => <piece.piece>, pack=metadata.graphics.piece, label=piece.piece, cls=metadata.graphics.piece.Piece, keyword=piece, atomic=Piece, atomic path=metadata.graphics.piece.Piece
~~m~ <piece.pieceColourType> name=PieceColourType type=Structural (metadata.graphics.piece.PieceColourType) => <piece.pieceColourType>, pack=metadata.graphics.piece, label=piece.pieceColourType, cls=metadata.graphics.piece.PieceColourType, keyword=pieceColourType, atomic=PieceColourType, atomic path=metadata.graphics.piece.PieceColourType
~~m~ <pieceFamiliesType> name=PieceFamiliesType type=Structural (metadata.graphics.piece.PieceFamiliesType) => <pieceFamiliesType>, pack=metadata.graphics.piece, label=pieceFamiliesType, cls=metadata.graphics.piece.PieceFamiliesType, keyword=pieceFamiliesType, atomic=PieceFamiliesType, atomic path=metadata.graphics.piece.PieceFamiliesType
~~m~ <pieceGroundType> name=PieceGroundType type=Structural (metadata.graphics.piece.PieceGroundType) => <pieceGroundType>, pack=metadata.graphics.piece, label=pieceGroundType, cls=metadata.graphics.piece.PieceGroundType, keyword=pieceGroundType, atomic=PieceGroundType, atomic path=metadata.graphics.piece.PieceGroundType
~~m~ <pieceNameType> name=PieceNameType type=Structural (metadata.graphics.piece.PieceNameType) => <pieceNameType>, pack=metadata.graphics.piece, label=pieceNameType, cls=metadata.graphics.piece.PieceNameType, keyword=pieceNameType, atomic=PieceNameType, atomic path=metadata.graphics.piece.PieceNameType
~~m~ <pieceReflectType> name=PieceReflectType type=Structural (metadata.graphics.piece.PieceReflectType) => <pieceReflectType>, pack=metadata.graphics.piece, label=pieceReflectType, cls=metadata.graphics.piece.PieceReflectType, keyword=pieceReflectType, atomic=PieceReflectType, atomic path=metadata.graphics.piece.PieceReflectType
~~m~ <pieceRotateType> name=PieceRotateType type=Structural (metadata.graphics.piece.PieceRotateType) => <pieceRotateType>, pack=metadata.graphics.piece, label=pieceRotateType, cls=metadata.graphics.piece.PieceRotateType, keyword=pieceRotateType, atomic=PieceRotateType, atomic path=metadata.graphics.piece.PieceRotateType
~~m~ <pieceScaleByType> name=PieceScaleByType type=Structural (metadata.graphics.piece.PieceScaleByType) => <pieceScaleByType>, pack=metadata.graphics.piece, label=pieceScaleByType, cls=metadata.graphics.piece.PieceScaleByType, keyword=pieceScaleByType, atomic=PieceScaleByType, atomic path=metadata.graphics.piece.PieceScaleByType
~~m~ <pieceScaleType> name=PieceScaleType type=Structural (metadata.graphics.piece.PieceScaleType) => <pieceScaleType>, pack=metadata.graphics.piece, label=pieceScaleType, cls=metadata.graphics.piece.PieceScaleType, keyword=pieceScaleType, atomic=PieceScaleType, atomic path=metadata.graphics.piece.PieceScaleType
~~m~ <pieceStyleType> name=PieceStyleType type=Structural (metadata.graphics.piece.PieceStyleType) => <pieceStyleType>, pack=metadata.graphics.piece, label=pieceStyleType, cls=metadata.graphics.piece.PieceStyleType, keyword=pieceStyleType, atomic=PieceStyleType, atomic path=metadata.graphics.piece.PieceStyleType
~~m~ <pieceColour> name=PieceColour type=Ludeme (metadata.graphics.piece.colour.PieceColour) => <pieceColour>, pack=metadata.graphics.piece.colour, label=pieceColour, cls=metadata.graphics.piece.colour.PieceColour, keyword=pieceColour, atomic=PieceColour, atomic path=metadata.graphics.piece.colour.PieceColour
~~m~ <pieceFamilies> name=PieceFamilies type=Ludeme (metadata.graphics.piece.families.PieceFamilies) => <pieceFamilies>, pack=metadata.graphics.piece.families, label=pieceFamilies, cls=metadata.graphics.piece.families.PieceFamilies, keyword=pieceFamilies, atomic=PieceFamilies, atomic path=metadata.graphics.piece.families.PieceFamilies
~~m~ <pieceBackground> name=PieceBackground type=Ludeme (metadata.graphics.piece.ground.PieceBackground) => <pieceBackground>, pack=metadata.graphics.piece.ground, label=pieceBackground, cls=metadata.graphics.piece.ground.PieceBackground, keyword=pieceBackground, atomic=PieceBackground, atomic path=metadata.graphics.piece.ground.PieceBackground
~~m~ <pieceForeground> name=PieceForeground type=Ludeme (metadata.graphics.piece.ground.PieceForeground) => <pieceForeground>, pack=metadata.graphics.piece.ground, label=pieceForeground, cls=metadata.graphics.piece.ground.PieceForeground, keyword=pieceForeground, atomic=PieceForeground, atomic path=metadata.graphics.piece.ground.PieceForeground
~~m~ <pieceAddStateToName> name=PieceAddStateToName type=Ludeme (metadata.graphics.piece.name.PieceAddStateToName) => <pieceAddStateToName>, pack=metadata.graphics.piece.name, label=pieceAddStateToName, cls=metadata.graphics.piece.name.PieceAddStateToName, keyword=pieceAddStateToName, atomic=PieceAddStateToName, atomic path=metadata.graphics.piece.name.PieceAddStateToName
~~m~ <pieceExtendName> name=PieceExtendName type=Ludeme (metadata.graphics.piece.name.PieceExtendName) => <pieceExtendName>, pack=metadata.graphics.piece.name, label=pieceExtendName, cls=metadata.graphics.piece.name.PieceExtendName, keyword=pieceExtendName, atomic=PieceExtendName, atomic path=metadata.graphics.piece.name.PieceExtendName
~~m~ <pieceRename> name=PieceRename type=Ludeme (metadata.graphics.piece.name.PieceRename) => <pieceRename>, pack=metadata.graphics.piece.name, label=pieceRename, cls=metadata.graphics.piece.name.PieceRename, keyword=pieceRename, atomic=PieceRename, atomic path=metadata.graphics.piece.name.PieceRename
~~m~ <pieceRotate> name=PieceRotate type=Ludeme (metadata.graphics.piece.rotate.PieceRotate) => <pieceRotate>, pack=metadata.graphics.piece.rotate, label=pieceRotate, cls=metadata.graphics.piece.rotate.PieceRotate, keyword=pieceRotate, atomic=PieceRotate, atomic path=metadata.graphics.piece.rotate.PieceRotate
~~m~ <pieceScale> name=PieceScale type=Ludeme (metadata.graphics.piece.scale.PieceScale) => <pieceScale>, pack=metadata.graphics.piece.scale, label=pieceScale, cls=metadata.graphics.piece.scale.PieceScale, keyword=pieceScale, atomic=PieceScale, atomic path=metadata.graphics.piece.scale.PieceScale
~~m~ <pieceStyle> name=PieceStyle type=Ludeme (metadata.graphics.piece.style.PieceStyle) => <pieceStyle>, pack=metadata.graphics.piece.style, label=pieceStyle, cls=metadata.graphics.piece.style.PieceStyle, keyword=pieceStyle, atomic=PieceStyle, atomic path=metadata.graphics.piece.style.PieceStyle
~~m~ <player.player> name=Player type=Structural (metadata.graphics.player.Player) => <player.player>, pack=metadata.graphics.player, label=player.player, cls=metadata.graphics.player.Player, keyword=player, atomic=Player, atomic path=metadata.graphics.player.Player
~~m~ <playerColourType> name=PlayerColourType type=Structural (metadata.graphics.player.PlayerColourType) => <playerColourType>, pack=metadata.graphics.player, label=playerColourType, cls=metadata.graphics.player.PlayerColourType, keyword=playerColourType, atomic=PlayerColourType, atomic path=metadata.graphics.player.PlayerColourType
~~m~ <playerNameType> name=PlayerNameType type=Structural (metadata.graphics.player.PlayerNameType) => <playerNameType>, pack=metadata.graphics.player, label=playerNameType, cls=metadata.graphics.player.PlayerNameType, keyword=playerNameType, atomic=PlayerNameType, atomic path=metadata.graphics.player.PlayerNameType
~~m~ <playerColour> name=PlayerColour type=Ludeme (metadata.graphics.player.colour.PlayerColour) => <playerColour>, pack=metadata.graphics.player.colour, label=playerColour, cls=metadata.graphics.player.colour.PlayerColour, keyword=playerColour, atomic=PlayerColour, atomic path=metadata.graphics.player.colour.PlayerColour
~~m~ <playerName> name=PlayerName type=Ludeme (metadata.graphics.player.name.PlayerName) => <playerName>, pack=metadata.graphics.player.name, label=playerName, cls=metadata.graphics.player.name.PlayerName, keyword=playerName, atomic=PlayerName, atomic path=metadata.graphics.player.name.PlayerName
~~m~ <adversarialPuzzle> name=AdversarialPuzzle type=Structural (metadata.graphics.puzzle.AdversarialPuzzle) => <adversarialPuzzle>, pack=metadata.graphics.puzzle, label=adversarialPuzzle, cls=metadata.graphics.puzzle.AdversarialPuzzle, keyword=adversarialPuzzle, atomic=AdversarialPuzzle, atomic path=metadata.graphics.puzzle.AdversarialPuzzle
~~m~ <drawHint> name=DrawHint type=Structural (metadata.graphics.puzzle.DrawHint) => <drawHint>, pack=metadata.graphics.puzzle, label=drawHint, cls=metadata.graphics.puzzle.DrawHint, keyword=drawHint, atomic=DrawHint, atomic path=metadata.graphics.puzzle.DrawHint
~~m~ <hintLocation> name=HintLocation type=Structural (metadata.graphics.puzzle.HintLocation) => <hintLocation>, pack=metadata.graphics.puzzle, label=hintLocation, cls=metadata.graphics.puzzle.HintLocation, keyword=hintLocation, atomic=HintLocation, atomic path=metadata.graphics.puzzle.HintLocation
~~m~ <region.region> name=Region type=Structural (metadata.graphics.region.Region) => <region.region>, pack=metadata.graphics.region, label=region.region, cls=metadata.graphics.region.Region, keyword=region, atomic=Region, atomic path=metadata.graphics.region.Region
~~m~ <regionColourType> name=RegionColourType type=Structural (metadata.graphics.region.RegionColourType) => <regionColourType>, pack=metadata.graphics.region, label=regionColourType, cls=metadata.graphics.region.RegionColourType, keyword=regionColourType, atomic=RegionColourType, atomic path=metadata.graphics.region.RegionColourType
~~m~ <regionColour> name=RegionColour type=Ludeme (metadata.graphics.region.colour.RegionColour) => <regionColour>, pack=metadata.graphics.region.colour, label=regionColour, cls=metadata.graphics.region.colour.RegionColour, keyword=regionColour, atomic=RegionColour, atomic path=metadata.graphics.region.colour.RegionColour
~~m~ <showCost> name=ShowCost type=Ludeme (metadata.graphics.show.Boolean.ShowCost) => <showCost>, pack=metadata.graphics.show.Boolean, label=showCost, cls=metadata.graphics.show.Boolean.ShowCost, keyword=showCost, atomic=ShowCost, atomic path=metadata.graphics.show.Boolean.ShowCost
~~m~ <showCurvedEdges> name=ShowCurvedEdges type=Ludeme (metadata.graphics.show.Boolean.ShowCurvedEdges) => <showCurvedEdges>, pack=metadata.graphics.show.Boolean, label=showCurvedEdges, cls=metadata.graphics.show.Boolean.ShowCurvedEdges, keyword=showCurvedEdges, atomic=ShowCurvedEdges, atomic path=metadata.graphics.show.Boolean.ShowCurvedEdges
~~m~ <showEdgeDirections> name=ShowEdgeDirections type=Ludeme (metadata.graphics.show.Boolean.ShowEdgeDirections) => <showEdgeDirections>, pack=metadata.graphics.show.Boolean, label=showEdgeDirections, cls=metadata.graphics.show.Boolean.ShowEdgeDirections, keyword=showEdgeDirections, atomic=ShowEdgeDirections, atomic path=metadata.graphics.show.Boolean.ShowEdgeDirections
~~m~ <showLocalStateHoles> name=ShowLocalStateHoles type=Ludeme (metadata.graphics.show.Boolean.ShowLocalStateHoles) => <showLocalStateHoles>, pack=metadata.graphics.show.Boolean, label=showLocalStateHoles, cls=metadata.graphics.show.Boolean.ShowLocalStateHoles, keyword=showLocalStateHoles, atomic=ShowLocalStateHoles, atomic path=metadata.graphics.show.Boolean.ShowLocalStateHoles
~~m~ <showPits> name=ShowPits type=Ludeme (metadata.graphics.show.Boolean.ShowPits) => <showPits>, pack=metadata.graphics.show.Boolean, label=showPits, cls=metadata.graphics.show.Boolean.ShowPits, keyword=showPits, atomic=ShowPits, atomic path=metadata.graphics.show.Boolean.ShowPits
~~m~ <showPlayerHoles> name=ShowPlayerHoles type=Ludeme (metadata.graphics.show.Boolean.ShowPlayerHoles) => <showPlayerHoles>, pack=metadata.graphics.show.Boolean, label=showPlayerHoles, cls=metadata.graphics.show.Boolean.ShowPlayerHoles, keyword=showPlayerHoles, atomic=ShowPlayerHoles, atomic path=metadata.graphics.show.Boolean.ShowPlayerHoles
~~m~ <showPossibleMoves> name=ShowPossibleMoves type=Ludeme (metadata.graphics.show.Boolean.ShowPossibleMoves) => <showPossibleMoves>, pack=metadata.graphics.show.Boolean, label=showPossibleMoves, cls=metadata.graphics.show.Boolean.ShowPossibleMoves, keyword=showPossibleMoves, atomic=ShowPossibleMoves, atomic path=metadata.graphics.show.Boolean.ShowPossibleMoves
~~m~ <showRegionOwner> name=ShowRegionOwner type=Ludeme (metadata.graphics.show.Boolean.ShowRegionOwner) => <showRegionOwner>, pack=metadata.graphics.show.Boolean, label=showRegionOwner, cls=metadata.graphics.show.Boolean.ShowRegionOwner, keyword=showRegionOwner, atomic=ShowRegionOwner, atomic path=metadata.graphics.show.Boolean.ShowRegionOwner
~~m~ <showStraightEdges> name=ShowStraightEdges type=Ludeme (metadata.graphics.show.Boolean.ShowStraightEdges) => <showStraightEdges>, pack=metadata.graphics.show.Boolean, label=showStraightEdges, cls=metadata.graphics.show.Boolean.ShowStraightEdges, keyword=showStraightEdges, atomic=ShowStraightEdges, atomic path=metadata.graphics.show.Boolean.ShowStraightEdges
~~m~ <show> name=Show type=Structural (metadata.graphics.show.Show) => <show>, pack=metadata.graphics.show, label=show, cls=metadata.graphics.show.Show, keyword=show, atomic=Show, atomic path=metadata.graphics.show.Show
~~m~ <showBooleanType> name=ShowBooleanType type=Structural (metadata.graphics.show.ShowBooleanType) => <showBooleanType>, pack=metadata.graphics.show, label=showBooleanType, cls=metadata.graphics.show.ShowBooleanType, keyword=showBooleanType, atomic=ShowBooleanType, atomic path=metadata.graphics.show.ShowBooleanType
~~m~ <showCheckType> name=ShowCheckType type=Structural (metadata.graphics.show.ShowCheckType) => <showCheckType>, pack=metadata.graphics.show, label=showCheckType, cls=metadata.graphics.show.ShowCheckType, keyword=showCheckType, atomic=ShowCheckType, atomic path=metadata.graphics.show.ShowCheckType
~~m~ <showComponentDataType> name=ShowComponentDataType type=Structural (metadata.graphics.show.ShowComponentDataType) => <showComponentDataType>, pack=metadata.graphics.show, label=showComponentDataType, cls=metadata.graphics.show.ShowComponentDataType, keyword=showComponentDataType, atomic=ShowComponentDataType, atomic path=metadata.graphics.show.ShowComponentDataType
~~m~ <showComponentType> name=ShowComponentType type=Structural (metadata.graphics.show.ShowComponentType) => <showComponentType>, pack=metadata.graphics.show, label=showComponentType, cls=metadata.graphics.show.ShowComponentType, keyword=showComponentType, atomic=ShowComponentType, atomic path=metadata.graphics.show.ShowComponentType
~~m~ <showEdgeType> name=ShowEdgeType type=Structural (metadata.graphics.show.ShowEdgeType) => <showEdgeType>, pack=metadata.graphics.show, label=showEdgeType, cls=metadata.graphics.show.ShowEdgeType, keyword=showEdgeType, atomic=ShowEdgeType, atomic path=metadata.graphics.show.ShowEdgeType
~~m~ <showLineType> name=ShowLineType type=Structural (metadata.graphics.show.ShowLineType) => <showLineType>, pack=metadata.graphics.show, label=showLineType, cls=metadata.graphics.show.ShowLineType, keyword=showLineType, atomic=ShowLineType, atomic path=metadata.graphics.show.ShowLineType
~~m~ <showScoreType> name=ShowScoreType type=Structural (metadata.graphics.show.ShowScoreType) => <showScoreType>, pack=metadata.graphics.show, label=showScoreType, cls=metadata.graphics.show.ShowScoreType, keyword=showScoreType, atomic=ShowScoreType, atomic path=metadata.graphics.show.ShowScoreType
~~m~ <showSiteDataType> name=ShowSiteDataType type=Structural (metadata.graphics.show.ShowSiteDataType) => <showSiteDataType>, pack=metadata.graphics.show, label=showSiteDataType, cls=metadata.graphics.show.ShowSiteDataType, keyword=showSiteDataType, atomic=ShowSiteDataType, atomic path=metadata.graphics.show.ShowSiteDataType
~~m~ <showSiteType> name=ShowSiteType type=Structural (metadata.graphics.show.ShowSiteType) => <showSiteType>, pack=metadata.graphics.show, label=showSiteType, cls=metadata.graphics.show.ShowSiteType, keyword=showSiteType, atomic=ShowSiteType, atomic path=metadata.graphics.show.ShowSiteType
~~m~ <showSymbolType> name=ShowSymbolType type=Structural (metadata.graphics.show.ShowSymbolType) => <showSymbolType>, pack=metadata.graphics.show, label=showSymbolType, cls=metadata.graphics.show.ShowSymbolType, keyword=showSymbolType, atomic=ShowSymbolType, atomic path=metadata.graphics.show.ShowSymbolType
~~m~ <showCheck> name=ShowCheck type=Ludeme (metadata.graphics.show.check.ShowCheck) => <showCheck>, pack=metadata.graphics.show.check, label=showCheck, cls=metadata.graphics.show.check.ShowCheck, keyword=showCheck, atomic=ShowCheck, atomic path=metadata.graphics.show.check.ShowCheck
~~m~ <showPieceState> name=ShowPieceState type=Ludeme (metadata.graphics.show.component.ShowPieceState) => <showPieceState>, pack=metadata.graphics.show.component, label=showPieceState, cls=metadata.graphics.show.component.ShowPieceState, keyword=showPieceState, atomic=ShowPieceState, atomic path=metadata.graphics.show.component.ShowPieceState
~~m~ <showPieceValue> name=ShowPieceValue type=Ludeme (metadata.graphics.show.component.ShowPieceValue) => <showPieceValue>, pack=metadata.graphics.show.component, label=showPieceValue, cls=metadata.graphics.show.component.ShowPieceValue, keyword=showPieceValue, atomic=ShowPieceValue, atomic path=metadata.graphics.show.component.ShowPieceValue
~~m~ <showEdges> name=ShowEdges type=Ludeme (metadata.graphics.show.edges.ShowEdges) => <showEdges>, pack=metadata.graphics.show.edges, label=showEdges, cls=metadata.graphics.show.edges.ShowEdges, keyword=showEdges, atomic=ShowEdges, atomic path=metadata.graphics.show.edges.ShowEdges
~~m~ <showLine> name=ShowLine type=Ludeme (metadata.graphics.show.line.ShowLine) => <showLine>, pack=metadata.graphics.show.line, label=showLine, cls=metadata.graphics.show.line.ShowLine, keyword=showLine, atomic=ShowLine, atomic path=metadata.graphics.show.line.ShowLine
~~m~ <showScore> name=ShowScore type=Ludeme (metadata.graphics.show.score.ShowScore) => <showScore>, pack=metadata.graphics.show.score, label=showScore, cls=metadata.graphics.show.score.ShowScore, keyword=showScore, atomic=ShowScore, atomic path=metadata.graphics.show.score.ShowScore
~~m~ <showSitesAsHoles> name=ShowSitesAsHoles type=Ludeme (metadata.graphics.show.sites.ShowSitesAsHoles) => <showSitesAsHoles>, pack=metadata.graphics.show.sites, label=showSitesAsHoles, cls=metadata.graphics.show.sites.ShowSitesAsHoles, keyword=showSitesAsHoles, atomic=ShowSitesAsHoles, atomic path=metadata.graphics.show.sites.ShowSitesAsHoles
~~m~ <showSitesIndex> name=ShowSitesIndex type=Ludeme (metadata.graphics.show.sites.ShowSitesIndex) => <showSitesIndex>, pack=metadata.graphics.show.sites, label=showSitesIndex, cls=metadata.graphics.show.sites.ShowSitesIndex, keyword=showSitesIndex, atomic=ShowSitesIndex, atomic path=metadata.graphics.show.sites.ShowSitesIndex
~~m~ <showSitesShape> name=ShowSitesShape type=Ludeme (metadata.graphics.show.sites.ShowSitesShape) => <showSitesShape>, pack=metadata.graphics.show.sites, label=showSitesShape, cls=metadata.graphics.show.sites.ShowSitesShape, keyword=showSitesShape, atomic=ShowSitesShape, atomic path=metadata.graphics.show.sites.ShowSitesShape
~~m~ <showSymbol> name=ShowSymbol type=Ludeme (metadata.graphics.show.symbol.ShowSymbol) => <showSymbol>, pack=metadata.graphics.show.symbol, label=showSymbol, cls=metadata.graphics.show.symbol.ShowSymbol, keyword=showSymbol, atomic=ShowSymbol, atomic path=metadata.graphics.show.symbol.ShowSymbol
~~m~ <boardGraphicsType> name=BoardGraphicsType type=Structural (metadata.graphics.util.BoardGraphicsType) => <boardGraphicsType>, pack=metadata.graphics.util, label=boardGraphicsType, cls=metadata.graphics.util.BoardGraphicsType, keyword=boardGraphicsType, atomic=BoardGraphicsType, atomic path=metadata.graphics.util.BoardGraphicsType
~~m~ <componentStyleType> name=ComponentStyleType type=Structural (metadata.graphics.util.ComponentStyleType) => <componentStyleType>, pack=metadata.graphics.util, label=componentStyleType, cls=metadata.graphics.util.ComponentStyleType, keyword=componentStyleType, atomic=ComponentStyleType, atomic path=metadata.graphics.util.ComponentStyleType
~~m~ <containerStyleType> name=ContainerStyleType type=Structural (metadata.graphics.util.ContainerStyleType) => <containerStyleType>, pack=metadata.graphics.util, label=containerStyleType, cls=metadata.graphics.util.ContainerStyleType, keyword=containerStyleType, atomic=ContainerStyleType, atomic path=metadata.graphics.util.ContainerStyleType
~~m~ <controllerType> name=ControllerType type=Structural (metadata.graphics.util.ControllerType) => <controllerType>, pack=metadata.graphics.util, label=controllerType, cls=metadata.graphics.util.ControllerType, keyword=controllerType, atomic=ControllerType, atomic path=metadata.graphics.util.ControllerType
~~m~ <curveType> name=CurveType type=Structural (metadata.graphics.util.CurveType) => <curveType>, pack=metadata.graphics.util, label=curveType, cls=metadata.graphics.util.CurveType, keyword=curveType, atomic=CurveType, atomic path=metadata.graphics.util.CurveType
~~m~ <edgeInfoGUI> name=EdgeInfoGUI type=Structural (metadata.graphics.util.EdgeInfoGUI) => <edgeInfoGUI>, pack=metadata.graphics.util, label=edgeInfoGUI, cls=metadata.graphics.util.EdgeInfoGUI, keyword=edgeInfoGUI, atomic=EdgeInfoGUI, atomic path=metadata.graphics.util.EdgeInfoGUI
~~m~ <edgeType> name=EdgeType type=Structural (metadata.graphics.util.EdgeType) => <edgeType>, pack=metadata.graphics.util, label=edgeType, cls=metadata.graphics.util.EdgeType, keyword=edgeType, atomic=EdgeType, atomic path=metadata.graphics.util.EdgeType
~~m~ <holeType> name=HoleType type=Structural (metadata.graphics.util.HoleType) => <holeType>, pack=metadata.graphics.util, label=holeType, cls=metadata.graphics.util.HoleType, keyword=holeType, atomic=HoleType, atomic path=metadata.graphics.util.HoleType
~~m~ <lineStyle> name=LineStyle type=Structural (metadata.graphics.util.LineStyle) => <lineStyle>, pack=metadata.graphics.util, label=lineStyle, cls=metadata.graphics.util.LineStyle, keyword=lineStyle, atomic=LineStyle, atomic path=metadata.graphics.util.LineStyle
~~m~ <metadataFunctions> name=MetadataFunctions type=Structural (metadata.graphics.util.MetadataFunctions) => <metadataFunctions>, pack=metadata.graphics.util, label=metadataFunctions, cls=metadata.graphics.util.MetadataFunctions, keyword=metadataFunctions, atomic=MetadataFunctions, atomic path=metadata.graphics.util.MetadataFunctions
~~m~ <metadataImageInfo> name=MetadataImageInfo type=Structural (metadata.graphics.util.MetadataImageInfo) => <metadataImageInfo>, pack=metadata.graphics.util, label=metadataImageInfo, cls=metadata.graphics.util.MetadataImageInfo, keyword=metadataImageInfo, atomic=MetadataImageInfo, atomic path=metadata.graphics.util.MetadataImageInfo
~~m~ <util.pieceColourType> name=PieceColourType type=Structural (metadata.graphics.util.PieceColourType) => <util.pieceColourType>, pack=metadata.graphics.util, label=util.pieceColourType, cls=metadata.graphics.util.PieceColourType, keyword=pieceColourType, atomic=PieceColourType, atomic path=metadata.graphics.util.PieceColourType
~~m~ <pieceStackType> name=PieceStackType type=Structural (metadata.graphics.util.PieceStackType) => <pieceStackType>, pack=metadata.graphics.util, label=pieceStackType, cls=metadata.graphics.util.PieceStackType, keyword=pieceStackType, atomic=PieceStackType, atomic path=metadata.graphics.util.PieceStackType
~~m~ <puzzleDrawHintType> name=PuzzleDrawHintType type=Structural (metadata.graphics.util.PuzzleDrawHintType) => <puzzleDrawHintType>, pack=metadata.graphics.util, label=puzzleDrawHintType, cls=metadata.graphics.util.PuzzleDrawHintType, keyword=puzzleDrawHintType, atomic=PuzzleDrawHintType, atomic path=metadata.graphics.util.PuzzleDrawHintType
~~m~ <puzzleHintLocationType> name=PuzzleHintLocationType type=Structural (metadata.graphics.util.PuzzleHintLocationType) => <puzzleHintLocationType>, pack=metadata.graphics.util, label=puzzleHintLocationType, cls=metadata.graphics.util.PuzzleHintLocationType, keyword=puzzleHintLocationType, atomic=PuzzleHintLocationType, atomic path=metadata.graphics.util.PuzzleHintLocationType
~~m~ <scoreDisplayInfo> name=ScoreDisplayInfo type=Structural (metadata.graphics.util.ScoreDisplayInfo) => <scoreDisplayInfo>, pack=metadata.graphics.util, label=scoreDisplayInfo, cls=metadata.graphics.util.ScoreDisplayInfo, keyword=scoreDisplayInfo, atomic=ScoreDisplayInfo, atomic path=metadata.graphics.util.ScoreDisplayInfo
~~m~ <stackPropertyType> name=StackPropertyType type=Structural (metadata.graphics.util.StackPropertyType) => <stackPropertyType>, pack=metadata.graphics.util, label=stackPropertyType, cls=metadata.graphics.util.StackPropertyType, keyword=stackPropertyType, atomic=StackPropertyType, atomic path=metadata.graphics.util.StackPropertyType
~~m~ <valueDisplayInfo> name=ValueDisplayInfo type=Structural (metadata.graphics.util.ValueDisplayInfo) => <valueDisplayInfo>, pack=metadata.graphics.util, label=valueDisplayInfo, cls=metadata.graphics.util.ValueDisplayInfo, keyword=valueDisplayInfo, atomic=ValueDisplayInfo, atomic path=metadata.graphics.util.ValueDisplayInfo
~~m~ <valueLocationType> name=ValueLocationType type=Structural (metadata.graphics.util.ValueLocationType) => <valueLocationType>, pack=metadata.graphics.util, label=valueLocationType, cls=metadata.graphics.util.ValueLocationType, keyword=valueLocationType, atomic=ValueLocationType, atomic path=metadata.graphics.util.ValueLocationType
~~m~ <whenScoreType> name=WhenScoreType type=Structural (metadata.graphics.util.WhenScoreType) => <whenScoreType>, pack=metadata.graphics.util, label=whenScoreType, cls=metadata.graphics.util.WhenScoreType, keyword=whenScoreType, atomic=WhenScoreType, atomic path=metadata.graphics.util.WhenScoreType
~~m~ <colour> name=Colour type=Structural (metadata.graphics.util.colour.Colour) => <colour>, pack=metadata.graphics.util.colour, label=colour, cls=metadata.graphics.util.colour.Colour, keyword=colour, atomic=Colour, atomic path=metadata.graphics.util.colour.Colour
~~m~ <colourRoutines> name=ColourRoutines type=Structural (metadata.graphics.util.colour.ColourRoutines) => <colourRoutines>, pack=metadata.graphics.util.colour, label=colourRoutines, cls=metadata.graphics.util.colour.ColourRoutines, keyword=colourRoutines, atomic=ColourRoutines, atomic path=metadata.graphics.util.colour.ColourRoutines
~~m~ <userColourType> name=UserColourType type=Structural (metadata.graphics.util.colour.UserColourType) => <userColourType>, pack=metadata.graphics.util.colour, label=userColourType, cls=metadata.graphics.util.colour.UserColourType, keyword=userColourType, atomic=UserColourType, atomic path=metadata.graphics.util.colour.UserColourType
~~m~ <info> name=Info type=Structural (metadata.info.Info) => <info>, pack=metadata.info, label=info, cls=metadata.info.Info, keyword=info, atomic=Info, atomic path=metadata.info.Info
~~m* <infoItem> name=InfoItem type=Structural (metadata.info.InfoItem) => <infoItem>, pack=metadata.info, label=infoItem, cls=metadata.info.InfoItem, keyword=infoItem, atomic=InfoItem, atomic path=metadata.info.InfoItem
~~m~ <aliases> name=Aliases type=Structural (metadata.info.database.Aliases) => <aliases>, pack=metadata.info.database, label=aliases, cls=metadata.info.database.Aliases, keyword=aliases, atomic=Aliases, atomic path=metadata.info.database.Aliases
~~m~ <author> name=Author type=Structural (metadata.info.database.Author) => <author>, pack=metadata.info.database, label=author, cls=metadata.info.database.Author, keyword=author, atomic=Author, atomic path=metadata.info.database.Author
~~m~ <classification> name=Classification type=Structural (metadata.info.database.Classification) => <classification>, pack=metadata.info.database, label=classification, cls=metadata.info.database.Classification, keyword=classification, atomic=Classification, atomic path=metadata.info.database.Classification
~~m~ <credit> name=Credit type=Structural (metadata.info.database.Credit) => <credit>, pack=metadata.info.database, label=credit, cls=metadata.info.database.Credit, keyword=credit, atomic=Credit, atomic path=metadata.info.database.Credit
~~m~ <date> name=Date type=Structural (metadata.info.database.Date) => <date>, pack=metadata.info.database, label=date, cls=metadata.info.database.Date, keyword=date, atomic=Date, atomic path=metadata.info.database.Date
~~m~ <description> name=Description type=Structural (metadata.info.database.Description) => <description>, pack=metadata.info.database, label=description, cls=metadata.info.database.Description, keyword=description, atomic=Description, atomic path=metadata.info.database.Description
~~m~ <database.id> name=Id type=Structural (metadata.info.database.Id) => <database.id>, pack=metadata.info.database, label=database.id, cls=metadata.info.database.Id, keyword=id, atomic=Id, atomic path=metadata.info.database.Id
~~m~ <origin> name=Origin type=Structural (metadata.info.database.Origin) => <origin>, pack=metadata.info.database, label=origin, cls=metadata.info.database.Origin, keyword=origin, atomic=Origin, atomic path=metadata.info.database.Origin
~~m~ <publisher> name=Publisher type=Structural (metadata.info.database.Publisher) => <publisher>, pack=metadata.info.database, label=publisher, cls=metadata.info.database.Publisher, keyword=publisher, atomic=Publisher, atomic path=metadata.info.database.Publisher
~~m~ <database.rules> name=Rules type=Structural (metadata.info.database.Rules) => <database.rules>, pack=metadata.info.database, label=database.rules, cls=metadata.info.database.Rules, keyword=rules, atomic=Rules, atomic path=metadata.info.database.Rules
~~m~ <source> name=Source type=Structural (metadata.info.database.Source) => <source>, pack=metadata.info.database, label=source, cls=metadata.info.database.Source, keyword=source, atomic=Source, atomic path=metadata.info.database.Source
~~m~ <version> name=Version type=Structural (metadata.info.database.Version) => <version>, pack=metadata.info.database, label=version, cls=metadata.info.database.Version, keyword=version, atomic=Version, atomic path=metadata.info.database.Version
~~m~ <recon> name=Recon type=Structural (metadata.recon.Recon) => <recon>, pack=metadata.recon, label=recon, cls=metadata.recon.Recon, keyword=recon, atomic=Recon, atomic path=metadata.recon.Recon
~~m* <reconItem> name=ReconItem type=Structural (metadata.recon.ReconItem) => <reconItem>, pack=metadata.recon, label=reconItem, cls=metadata.recon.ReconItem, keyword=reconItem, atomic=ReconItem, atomic path=metadata.recon.ReconItem
~~m~ <concept> name=Concept type=Structural (metadata.recon.concept.Concept) => <concept>, pack=metadata.recon.concept, label=concept, cls=metadata.recon.concept.Concept, keyword=concept, atomic=Concept, atomic path=metadata.recon.concept.Concept
gd~~ Groups name=Groups type=Constant (game.functions.booleans.all.AllGroupsType.Groups) => <allGroupsType>, pack=game.functions.booleans.all, label=Groups, cls=game.functions.booleans.all.AllGroupsType, keyword=Groups, atomic=Groups, atomic path=game.functions.booleans.all.AllGroupsType.Groups
gd~~ DiceUsed name=DiceUsed type=Constant (game.functions.booleans.all.AllSimpleType.DiceUsed) => <allSimpleType>, pack=game.functions.booleans.all, label=DiceUsed, cls=game.functions.booleans.all.AllSimpleType, keyword=DiceUsed, atomic=DiceUsed, atomic path=game.functions.booleans.all.AllSimpleType.DiceUsed
gd~~ DiceEqual name=DiceEqual type=Constant (game.functions.booleans.all.AllSimpleType.DiceEqual) => <allSimpleType>, pack=game.functions.booleans.all, label=DiceEqual, cls=game.functions.booleans.all.AllSimpleType, keyword=DiceEqual, atomic=DiceEqual, atomic path=game.functions.booleans.all.AllSimpleType.DiceEqual
gd~~ Passed name=Passed type=Constant (game.functions.booleans.all.AllSimpleType.Passed) => <allSimpleType>, pack=game.functions.booleans.all, label=Passed, cls=game.functions.booleans.all.AllSimpleType, keyword=Passed, atomic=Passed, atomic path=game.functions.booleans.all.AllSimpleType.Passed
gd~~ Sites name=Sites type=Constant (game.functions.booleans.all.AllSitesType.Sites) => <allSitesType>, pack=game.functions.booleans.all, label=Sites, cls=game.functions.booleans.all.AllSitesType, keyword=Sites, atomic=Sites, atomic path=game.functions.booleans.all.AllSitesType.Sites
gd~~ Different name=Different type=Constant (game.functions.booleans.all.AllSitesType.Different) => <allSitesType>, pack=game.functions.booleans.all, label=Different, cls=game.functions.booleans.all.AllSitesType, keyword=Different, atomic=Different, atomic path=game.functions.booleans.all.AllSitesType.Different
gd~~ Values name=Values type=Constant (game.functions.booleans.all.AllValuesType.Values) => <allValuesType>, pack=game.functions.booleans.all, label=Values, cls=game.functions.booleans.all.AllValuesType, keyword=Values, atomic=Values, atomic path=game.functions.booleans.all.AllValuesType.Values
gd~~ Move name=Move type=Constant (game.functions.booleans.can.CanType.Move) => <canType>, pack=game.functions.booleans.can, label=Move, cls=game.functions.booleans.can.CanType, keyword=Move, atomic=Move, atomic path=game.functions.booleans.can.CanType.Move
gd~~ Different name=Different type=Constant (game.functions.booleans.deductionPuzzle.all.AllPuzzleType.Different) => <allPuzzleType>, pack=game.functions.booleans.deductionPuzzle.all, label=Different, cls=game.functions.booleans.deductionPuzzle.all.AllPuzzleType, keyword=Different, atomic=Different, atomic path=game.functions.booleans.deductionPuzzle.all.AllPuzzleType.Different
gd~~ Unique name=Unique type=Constant (game.functions.booleans.deductionPuzzle.is.IsPuzzleGraphType.Unique) => <isPuzzleGraphType>, pack=game.functions.booleans.deductionPuzzle.is, label=Unique, cls=game.functions.booleans.deductionPuzzle.is.IsPuzzleGraphType, keyword=Unique, atomic=Unique, atomic path=game.functions.booleans.deductionPuzzle.is.IsPuzzleGraphType.Unique
gd~~ Count name=Count type=Constant (game.functions.booleans.deductionPuzzle.is.IsPuzzleRegionResultType.Count) => <isPuzzleRegionResultType>, pack=game.functions.booleans.deductionPuzzle.is, label=Count, cls=game.functions.booleans.deductionPuzzle.is.IsPuzzleRegionResultType, keyword=Count, atomic=Count, atomic path=game.functions.booleans.deductionPuzzle.is.IsPuzzleRegionResultType.Count
gd~~ Sum name=Sum type=Constant (game.functions.booleans.deductionPuzzle.is.IsPuzzleRegionResultType.Sum) => <isPuzzleRegionResultType>, pack=game.functions.booleans.deductionPuzzle.is, label=Sum, cls=game.functions.booleans.deductionPuzzle.is.IsPuzzleRegionResultType, keyword=Sum, atomic=Sum, atomic path=game.functions.booleans.deductionPuzzle.is.IsPuzzleRegionResultType.Sum
gd~~ Solved name=Solved type=Constant (game.functions.booleans.deductionPuzzle.is.IsPuzzleSimpleType.Solved) => <isPuzzleSimpleType>, pack=game.functions.booleans.deductionPuzzle.is, label=Solved, cls=game.functions.booleans.deductionPuzzle.is.IsPuzzleSimpleType, keyword=Solved, atomic=Solved, atomic path=game.functions.booleans.deductionPuzzle.is.IsPuzzleSimpleType.Solved
gd~~ Acute name=Acute type=Constant (game.functions.booleans.is.IsAngleType.Acute) => <isAngleType>, pack=game.functions.booleans.is, label=Acute, cls=game.functions.booleans.is.IsAngleType, keyword=Acute, atomic=Acute, atomic path=game.functions.booleans.is.IsAngleType.Acute
gd~~ Right name=Right type=Constant (game.functions.booleans.is.IsAngleType.Right) => <isAngleType>, pack=game.functions.booleans.is, label=Right, cls=game.functions.booleans.is.IsAngleType, keyword=Right, atomic=Right, atomic path=game.functions.booleans.is.IsAngleType.Right
gd~~ Obtuse name=Obtuse type=Constant (game.functions.booleans.is.IsAngleType.Obtuse) => <isAngleType>, pack=game.functions.booleans.is, label=Obtuse, cls=game.functions.booleans.is.IsAngleType, keyword=Obtuse, atomic=Obtuse, atomic path=game.functions.booleans.is.IsAngleType.Obtuse
gd~~ Reflex name=Reflex type=Constant (game.functions.booleans.is.IsAngleType.Reflex) => <isAngleType>, pack=game.functions.booleans.is, label=Reflex, cls=game.functions.booleans.is.IsAngleType, keyword=Reflex, atomic=Reflex, atomic path=game.functions.booleans.is.IsAngleType.Reflex
gd~~ Threatened name=Threatened type=Constant (game.functions.booleans.is.IsComponentType.Threatened) => <isComponentType>, pack=game.functions.booleans.is, label=Threatened, cls=game.functions.booleans.is.IsComponentType, keyword=Threatened, atomic=Threatened, atomic path=game.functions.booleans.is.IsComponentType.Threatened
gd~~ Within name=Within type=Constant (game.functions.booleans.is.IsComponentType.Within) => <isComponentType>, pack=game.functions.booleans.is, label=Within, cls=game.functions.booleans.is.IsComponentType, keyword=Within, atomic=Within, atomic path=game.functions.booleans.is.IsComponentType.Within
gd~~ Connected name=Connected type=Constant (game.functions.booleans.is.IsConnectType.Connected) => <isConnectType>, pack=game.functions.booleans.is, label=Connected, cls=game.functions.booleans.is.IsConnectType, keyword=Connected, atomic=Connected, atomic path=game.functions.booleans.is.IsConnectType.Connected
gd~~ Blocked name=Blocked type=Constant (game.functions.booleans.is.IsConnectType.Blocked) => <isConnectType>, pack=game.functions.booleans.is, label=Blocked, cls=game.functions.booleans.is.IsConnectType, keyword=Blocked, atomic=Blocked, atomic path=game.functions.booleans.is.IsConnectType.Blocked
gd~~ Crossing name=Crossing type=Constant (game.functions.booleans.is.IsEdgeType.Crossing) => <isEdgeType>, pack=game.functions.booleans.is, label=Crossing, cls=game.functions.booleans.is.IsEdgeType, keyword=Crossing, atomic=Crossing, atomic path=game.functions.booleans.is.IsEdgeType.Crossing
gd~~ LastFrom name=LastFrom type=Constant (game.functions.booleans.is.IsGraphType.LastFrom) => <isGraphType>, pack=game.functions.booleans.is, label=LastFrom, cls=game.functions.booleans.is.IsGraphType, keyword=LastFrom, atomic=LastFrom, atomic path=game.functions.booleans.is.IsGraphType.LastFrom
gd~~ LastTo name=LastTo type=Constant (game.functions.booleans.is.IsGraphType.LastTo) => <isGraphType>, pack=game.functions.booleans.is, label=LastTo, cls=game.functions.booleans.is.IsGraphType, keyword=LastTo, atomic=LastTo, atomic path=game.functions.booleans.is.IsGraphType.LastTo
gd~~ Hidden name=Hidden type=Constant (game.functions.booleans.is.IsHiddenType.Hidden) => <isHiddenType>, pack=game.functions.booleans.is, label=Hidden, cls=game.functions.booleans.is.IsHiddenType, keyword=Hidden, atomic=Hidden, atomic path=game.functions.booleans.is.IsHiddenType.Hidden
gd~~ In name=In type=Constant (game.functions.booleans.is.IsInType.In) => <isInType>, pack=game.functions.booleans.is, label=In, cls=game.functions.booleans.is.IsInType, keyword=In, atomic=In, atomic path=game.functions.booleans.is.IsInType.In
gd~~ Odd name=Odd type=Constant (game.functions.booleans.is.IsIntegerType.Odd) => <isIntegerType>, pack=game.functions.booleans.is, label=Odd, cls=game.functions.booleans.is.IsIntegerType, keyword=Odd, atomic=Odd, atomic path=game.functions.booleans.is.IsIntegerType.Odd
gd~~ Even name=Even type=Constant (game.functions.booleans.is.IsIntegerType.Even) => <isIntegerType>, pack=game.functions.booleans.is, label=Even, cls=game.functions.booleans.is.IsIntegerType, keyword=Even, atomic=Even, atomic path=game.functions.booleans.is.IsIntegerType.Even
gd~~ Visited name=Visited type=Constant (game.functions.booleans.is.IsIntegerType.Visited) => <isIntegerType>, pack=game.functions.booleans.is, label=Visited, cls=game.functions.booleans.is.IsIntegerType, keyword=Visited, atomic=Visited, atomic path=game.functions.booleans.is.IsIntegerType.Visited
gd~~ SidesMatch name=SidesMatch type=Constant (game.functions.booleans.is.IsIntegerType.SidesMatch) => <isIntegerType>, pack=game.functions.booleans.is, label=SidesMatch, cls=game.functions.booleans.is.IsIntegerType, keyword=SidesMatch, atomic=SidesMatch, atomic path=game.functions.booleans.is.IsIntegerType.SidesMatch
gd~~ PipsMatch name=PipsMatch type=Constant (game.functions.booleans.is.IsIntegerType.PipsMatch) => <isIntegerType>, pack=game.functions.booleans.is, label=PipsMatch, cls=game.functions.booleans.is.IsIntegerType, keyword=PipsMatch, atomic=PipsMatch, atomic path=game.functions.booleans.is.IsIntegerType.PipsMatch
gd~~ Flat name=Flat type=Constant (game.functions.booleans.is.IsIntegerType.Flat) => <isIntegerType>, pack=game.functions.booleans.is, label=Flat, cls=game.functions.booleans.is.IsIntegerType, keyword=Flat, atomic=Flat, atomic path=game.functions.booleans.is.IsIntegerType.Flat
gd~~ AnyDie name=AnyDie type=Constant (game.functions.booleans.is.IsIntegerType.AnyDie) => <isIntegerType>, pack=game.functions.booleans.is, label=AnyDie, cls=game.functions.booleans.is.IsIntegerType, keyword=AnyDie, atomic=AnyDie, atomic path=game.functions.booleans.is.IsIntegerType.AnyDie
gd~~ Line name=Line type=Constant (game.functions.booleans.is.IsLineType.Line) => <isLineType>, pack=game.functions.booleans.is, label=Line, cls=game.functions.booleans.is.IsLineType, keyword=Line, atomic=Line, atomic path=game.functions.booleans.is.IsLineType.Line
gd~~ Loop name=Loop type=Constant (game.functions.booleans.is.IsLoopType.Loop) => <isLoopType>, pack=game.functions.booleans.is, label=Loop, cls=game.functions.booleans.is.IsLoopType, keyword=Loop, atomic=Loop, atomic path=game.functions.booleans.is.IsLoopType.Loop
gd~~ Path name=Path type=Constant (game.functions.booleans.is.IsPathType.Path) => <isPathType>, pack=game.functions.booleans.is, label=Path, cls=game.functions.booleans.is.IsPathType, keyword=Path, atomic=Path, atomic path=game.functions.booleans.is.IsPathType.Path
gd~~ Pattern name=Pattern type=Constant (game.functions.booleans.is.IsPatternType.Pattern) => <isPatternType>, pack=game.functions.booleans.is, label=Pattern, cls=game.functions.booleans.is.IsPatternType, keyword=Pattern, atomic=Pattern, atomic path=game.functions.booleans.is.IsPatternType.Pattern
gd~~ Mover name=Mover type=Constant (game.functions.booleans.is.IsPlayerType.Mover) => <isPlayerType>, pack=game.functions.booleans.is, label=Mover, cls=game.functions.booleans.is.IsPlayerType, keyword=Mover, atomic=Mover, atomic path=game.functions.booleans.is.IsPlayerType.Mover
gd~~ Next name=Next type=Constant (game.functions.booleans.is.IsPlayerType.Next) => <isPlayerType>, pack=game.functions.booleans.is, label=Next, cls=game.functions.booleans.is.IsPlayerType, keyword=Next, atomic=Next, atomic path=game.functions.booleans.is.IsPlayerType.Next
gd~~ Prev name=Prev type=Constant (game.functions.booleans.is.IsPlayerType.Prev) => <isPlayerType>, pack=game.functions.booleans.is, label=Prev, cls=game.functions.booleans.is.IsPlayerType, keyword=Prev, atomic=Prev, atomic path=game.functions.booleans.is.IsPlayerType.Prev
gd~~ Friend name=Friend type=Constant (game.functions.booleans.is.IsPlayerType.Friend) => <isPlayerType>, pack=game.functions.booleans.is, label=Friend, cls=game.functions.booleans.is.IsPlayerType, keyword=Friend, atomic=Friend, atomic path=game.functions.booleans.is.IsPlayerType.Friend
gd~~ Enemy name=Enemy type=Constant (game.functions.booleans.is.IsPlayerType.Enemy) => <isPlayerType>, pack=game.functions.booleans.is, label=Enemy, cls=game.functions.booleans.is.IsPlayerType, keyword=Enemy, atomic=Enemy, atomic path=game.functions.booleans.is.IsPlayerType.Enemy
gd~~ Active name=Active type=Constant (game.functions.booleans.is.IsPlayerType.Active) => <isPlayerType>, pack=game.functions.booleans.is, label=Active, cls=game.functions.booleans.is.IsPlayerType, keyword=Active, atomic=Active, atomic path=game.functions.booleans.is.IsPlayerType.Active
gd~~ RegularGraph name=RegularGraph type=Constant (game.functions.booleans.is.IsRegularGraphType.RegularGraph) => <isRegularGraphType>, pack=game.functions.booleans.is, label=RegularGraph, cls=game.functions.booleans.is.IsRegularGraphType, keyword=RegularGraph, atomic=RegularGraph, atomic path=game.functions.booleans.is.IsRegularGraphType.RegularGraph
gd~~ Related name=Related type=Constant (game.functions.booleans.is.IsRelationType.Related) => <isRelationType>, pack=game.functions.booleans.is, label=Related, cls=game.functions.booleans.is.IsRelationType, keyword=Related, atomic=Related, atomic path=game.functions.booleans.is.IsRelationType.Related
gd~~ Repeat name=Repeat type=Constant (game.functions.booleans.is.IsRepeatType.Repeat) => <isRepeatType>, pack=game.functions.booleans.is, label=Repeat, cls=game.functions.booleans.is.IsRepeatType, keyword=Repeat, atomic=Repeat, atomic path=game.functions.booleans.is.IsRepeatType.Repeat
gd~~ Cycle name=Cycle type=Constant (game.functions.booleans.is.IsSimpleType.Cycle) => <isSimpleType>, pack=game.functions.booleans.is, label=Cycle, cls=game.functions.booleans.is.IsSimpleType, keyword=Cycle, atomic=Cycle, atomic path=game.functions.booleans.is.IsSimpleType.Cycle
gd~~ Pending name=Pending type=Constant (game.functions.booleans.is.IsSimpleType.Pending) => <isSimpleType>, pack=game.functions.booleans.is, label=Pending, cls=game.functions.booleans.is.IsSimpleType, keyword=Pending, atomic=Pending, atomic path=game.functions.booleans.is.IsSimpleType.Pending
gd~~ Full name=Full type=Constant (game.functions.booleans.is.IsSimpleType.Full) => <isSimpleType>, pack=game.functions.booleans.is, label=Full, cls=game.functions.booleans.is.IsSimpleType, keyword=Full, atomic=Full, atomic path=game.functions.booleans.is.IsSimpleType.Full
gd~~ Empty name=Empty type=Constant (game.functions.booleans.is.IsSiteType.Empty) => <isSiteType>, pack=game.functions.booleans.is, label=Empty, cls=game.functions.booleans.is.IsSiteType, keyword=Empty, atomic=Empty, atomic path=game.functions.booleans.is.IsSiteType.Empty
gd~~ Occupied name=Occupied type=Constant (game.functions.booleans.is.IsSiteType.Occupied) => <isSiteType>, pack=game.functions.booleans.is, label=Occupied, cls=game.functions.booleans.is.IsSiteType, keyword=Occupied, atomic=Occupied, atomic path=game.functions.booleans.is.IsSiteType.Occupied
gd~~ Proposed name=Proposed type=Constant (game.functions.booleans.is.IsStringType.Proposed) => <isStringType>, pack=game.functions.booleans.is, label=Proposed, cls=game.functions.booleans.is.IsStringType, keyword=Proposed, atomic=Proposed, atomic path=game.functions.booleans.is.IsStringType.Proposed
gd~~ Decided name=Decided type=Constant (game.functions.booleans.is.IsStringType.Decided) => <isStringType>, pack=game.functions.booleans.is, label=Decided, cls=game.functions.booleans.is.IsStringType, keyword=Decided, atomic=Decided, atomic path=game.functions.booleans.is.IsStringType.Decided
gd~~ Target name=Target type=Constant (game.functions.booleans.is.IsTargetType.Target) => <isTargetType>, pack=game.functions.booleans.is, label=Target, cls=game.functions.booleans.is.IsTargetType, keyword=Target, atomic=Target, atomic path=game.functions.booleans.is.IsTargetType.Target
gd~~ Tree name=Tree type=Constant (game.functions.booleans.is.IsTreeType.Tree) => <isTreeType>, pack=game.functions.booleans.is, label=Tree, cls=game.functions.booleans.is.IsTreeType, keyword=Tree, atomic=Tree, atomic path=game.functions.booleans.is.IsTreeType.Tree
gd~~ SpanningTree name=SpanningTree type=Constant (game.functions.booleans.is.IsTreeType.SpanningTree) => <isTreeType>, pack=game.functions.booleans.is, label=SpanningTree, cls=game.functions.booleans.is.IsTreeType, keyword=SpanningTree, atomic=SpanningTree, atomic path=game.functions.booleans.is.IsTreeType.SpanningTree
gd~~ CaterpillarTree name=CaterpillarTree type=Constant (game.functions.booleans.is.IsTreeType.CaterpillarTree) => <isTreeType>, pack=game.functions.booleans.is, label=CaterpillarTree, cls=game.functions.booleans.is.IsTreeType, keyword=CaterpillarTree, atomic=CaterpillarTree, atomic path=game.functions.booleans.is.IsTreeType.CaterpillarTree
gd~~ TreeCentre name=TreeCentre type=Constant (game.functions.booleans.is.IsTreeType.TreeCentre) => <isTreeType>, pack=game.functions.booleans.is, label=TreeCentre, cls=game.functions.booleans.is.IsTreeType, keyword=TreeCentre, atomic=TreeCentre, atomic path=game.functions.booleans.is.IsTreeType.TreeCentre
gd~~ Triggered name=Triggered type=Constant (game.functions.booleans.is.IsTriggeredType.Triggered) => <isTriggeredType>, pack=game.functions.booleans.is, label=Triggered, cls=game.functions.booleans.is.IsTriggeredType, keyword=Triggered, atomic=Triggered, atomic path=game.functions.booleans.is.IsTriggeredType.Triggered
gd~~ Moves name=Moves type=Constant (game.functions.booleans.no.NoMoveType.Moves) => <noMoveType>, pack=game.functions.booleans.no, label=Moves, cls=game.functions.booleans.no.NoMoveType, keyword=Moves, atomic=Moves, atomic path=game.functions.booleans.no.NoMoveType.Moves
gd~~ Pieces name=Pieces type=Constant (game.functions.booleans.no.NoPieceType.Pieces) => <noPieceType>, pack=game.functions.booleans.no, label=Pieces, cls=game.functions.booleans.no.NoPieceType, keyword=Pieces, atomic=Pieces, atomic path=game.functions.booleans.no.NoPieceType.Pieces
gd~~ Pass name=Pass type=Constant (game.functions.booleans.was.WasType.Pass) => <wasType>, pack=game.functions.booleans.was, label=Pass, cls=game.functions.booleans.was.WasType, keyword=Pass, atomic=Pass, atomic path=game.functions.booleans.was.WasType.Pass
gd~~ Random name=Random type=Constant (game.functions.directions.RandomDirectionType.Random) => <randomDirectionType>, pack=game.functions.directions, label=Random, cls=game.functions.directions.RandomDirectionType, keyword=Random, atomic=Random, atomic path=game.functions.directions.RandomDirectionType.Random
gd~~ Square name=Square type=Constant (game.functions.graph.generators.basis.brick.BrickShapeType.Square) => <brickShapeType>, pack=game.functions.graph.generators.basis.brick, label=Square, cls=game.functions.graph.generators.basis.brick.BrickShapeType, keyword=Square, atomic=Square, atomic path=game.functions.graph.generators.basis.brick.BrickShapeType.Square
gd~~ Rectangle name=Rectangle type=Constant (game.functions.graph.generators.basis.brick.BrickShapeType.Rectangle) => <brickShapeType>, pack=game.functions.graph.generators.basis.brick, label=Rectangle, cls=game.functions.graph.generators.basis.brick.BrickShapeType, keyword=Rectangle, atomic=Rectangle, atomic path=game.functions.graph.generators.basis.brick.BrickShapeType.Rectangle
gd~~ Diamond name=Diamond type=Constant (game.functions.graph.generators.basis.brick.BrickShapeType.Diamond) => <brickShapeType>, pack=game.functions.graph.generators.basis.brick, label=Diamond, cls=game.functions.graph.generators.basis.brick.BrickShapeType, keyword=Diamond, atomic=Diamond, atomic path=game.functions.graph.generators.basis.brick.BrickShapeType.Diamond
gd~~ Prism name=Prism type=Constant (game.functions.graph.generators.basis.brick.BrickShapeType.Prism) => <brickShapeType>, pack=game.functions.graph.generators.basis.brick, label=Prism, cls=game.functions.graph.generators.basis.brick.BrickShapeType, keyword=Prism, atomic=Prism, atomic path=game.functions.graph.generators.basis.brick.BrickShapeType.Prism
gd~~ Spiral name=Spiral type=Constant (game.functions.graph.generators.basis.brick.BrickShapeType.Spiral) => <brickShapeType>, pack=game.functions.graph.generators.basis.brick, label=Spiral, cls=game.functions.graph.generators.basis.brick.BrickShapeType, keyword=Spiral, atomic=Spiral, atomic path=game.functions.graph.generators.basis.brick.BrickShapeType.Spiral
gd~~ Limping name=Limping type=Constant (game.functions.graph.generators.basis.brick.BrickShapeType.Limping) => <brickShapeType>, pack=game.functions.graph.generators.basis.brick, label=Limping, cls=game.functions.graph.generators.basis.brick.BrickShapeType, keyword=Limping, atomic=Limping, atomic path=game.functions.graph.generators.basis.brick.BrickShapeType.Limping
gd~~ NoShape name=NoShape type=Constant (game.functions.graph.generators.basis.hex.HexShapeType.NoShape) => <hexShapeType>, pack=game.functions.graph.generators.basis.hex, label=NoShape, cls=game.functions.graph.generators.basis.hex.HexShapeType, keyword=NoShape, atomic=NoShape, atomic path=game.functions.graph.generators.basis.hex.HexShapeType.NoShape
gd~~ Square name=Square type=Constant (game.functions.graph.generators.basis.hex.HexShapeType.Square) => <hexShapeType>, pack=game.functions.graph.generators.basis.hex, label=Square, cls=game.functions.graph.generators.basis.hex.HexShapeType, keyword=Square, atomic=Square, atomic path=game.functions.graph.generators.basis.hex.HexShapeType.Square
gd~~ Rectangle name=Rectangle type=Constant (game.functions.graph.generators.basis.hex.HexShapeType.Rectangle) => <hexShapeType>, pack=game.functions.graph.generators.basis.hex, label=Rectangle, cls=game.functions.graph.generators.basis.hex.HexShapeType, keyword=Rectangle, atomic=Rectangle, atomic path=game.functions.graph.generators.basis.hex.HexShapeType.Rectangle
gd~~ Diamond name=Diamond type=Constant (game.functions.graph.generators.basis.hex.HexShapeType.Diamond) => <hexShapeType>, pack=game.functions.graph.generators.basis.hex, label=Diamond, cls=game.functions.graph.generators.basis.hex.HexShapeType, keyword=Diamond, atomic=Diamond, atomic path=game.functions.graph.generators.basis.hex.HexShapeType.Diamond
gd~~ Triangle name=Triangle type=Constant (game.functions.graph.generators.basis.hex.HexShapeType.Triangle) => <hexShapeType>, pack=game.functions.graph.generators.basis.hex, label=Triangle, cls=game.functions.graph.generators.basis.hex.HexShapeType, keyword=Triangle, atomic=Triangle, atomic path=game.functions.graph.generators.basis.hex.HexShapeType.Triangle
gd~~ Hexagon name=Hexagon type=Constant (game.functions.graph.generators.basis.hex.HexShapeType.Hexagon) => <hexShapeType>, pack=game.functions.graph.generators.basis.hex, label=Hexagon, cls=game.functions.graph.generators.basis.hex.HexShapeType, keyword=Hexagon, atomic=Hexagon, atomic path=game.functions.graph.generators.basis.hex.HexShapeType.Hexagon
gd~~ Star name=Star type=Constant (game.functions.graph.generators.basis.hex.HexShapeType.Star) => <hexShapeType>, pack=game.functions.graph.generators.basis.hex, label=Star, cls=game.functions.graph.generators.basis.hex.HexShapeType, keyword=Star, atomic=Star, atomic path=game.functions.graph.generators.basis.hex.HexShapeType.Star
gd~~ Limping name=Limping type=Constant (game.functions.graph.generators.basis.hex.HexShapeType.Limping) => <hexShapeType>, pack=game.functions.graph.generators.basis.hex, label=Limping, cls=game.functions.graph.generators.basis.hex.HexShapeType, keyword=Limping, atomic=Limping, atomic path=game.functions.graph.generators.basis.hex.HexShapeType.Limping
gd~~ Prism name=Prism type=Constant (game.functions.graph.generators.basis.hex.HexShapeType.Prism) => <hexShapeType>, pack=game.functions.graph.generators.basis.hex, label=Prism, cls=game.functions.graph.generators.basis.hex.HexShapeType, keyword=Prism, atomic=Prism, atomic path=game.functions.graph.generators.basis.hex.HexShapeType.Prism
gd~~ Implied name=Implied type=Constant (game.functions.graph.generators.basis.square.DiagonalsType.Implied) => <diagonalsType>, pack=game.functions.graph.generators.basis.square, label=Implied, cls=game.functions.graph.generators.basis.square.DiagonalsType, keyword=Implied, atomic=Implied, atomic path=game.functions.graph.generators.basis.square.DiagonalsType.Implied
gd~~ Solid name=Solid type=Constant (game.functions.graph.generators.basis.square.DiagonalsType.Solid) => <diagonalsType>, pack=game.functions.graph.generators.basis.square, label=Solid, cls=game.functions.graph.generators.basis.square.DiagonalsType, keyword=Solid, atomic=Solid, atomic path=game.functions.graph.generators.basis.square.DiagonalsType.Solid
gd~~ SolidNoSplit name=SolidNoSplit type=Constant (game.functions.graph.generators.basis.square.DiagonalsType.SolidNoSplit) => <diagonalsType>, pack=game.functions.graph.generators.basis.square, label=SolidNoSplit, cls=game.functions.graph.generators.basis.square.DiagonalsType, keyword=SolidNoSplit, atomic=SolidNoSplit, atomic path=game.functions.graph.generators.basis.square.DiagonalsType.SolidNoSplit
gd~~ Alternating name=Alternating type=Constant (game.functions.graph.generators.basis.square.DiagonalsType.Alternating) => <diagonalsType>, pack=game.functions.graph.generators.basis.square, label=Alternating, cls=game.functions.graph.generators.basis.square.DiagonalsType, keyword=Alternating, atomic=Alternating, atomic path=game.functions.graph.generators.basis.square.DiagonalsType.Alternating
gd~~ Concentric name=Concentric type=Constant (game.functions.graph.generators.basis.square.DiagonalsType.Concentric) => <diagonalsType>, pack=game.functions.graph.generators.basis.square, label=Concentric, cls=game.functions.graph.generators.basis.square.DiagonalsType, keyword=Concentric, atomic=Concentric, atomic path=game.functions.graph.generators.basis.square.DiagonalsType.Concentric
gd~~ Radiating name=Radiating type=Constant (game.functions.graph.generators.basis.square.DiagonalsType.Radiating) => <diagonalsType>, pack=game.functions.graph.generators.basis.square, label=Radiating, cls=game.functions.graph.generators.basis.square.DiagonalsType, keyword=Radiating, atomic=Radiating, atomic path=game.functions.graph.generators.basis.square.DiagonalsType.Radiating
gd~~ NoShape name=NoShape type=Constant (game.functions.graph.generators.basis.square.SquareShapeType.NoShape) => <squareShapeType>, pack=game.functions.graph.generators.basis.square, label=NoShape, cls=game.functions.graph.generators.basis.square.SquareShapeType, keyword=NoShape, atomic=NoShape, atomic path=game.functions.graph.generators.basis.square.SquareShapeType.NoShape
gd~~ Square name=Square type=Constant (game.functions.graph.generators.basis.square.SquareShapeType.Square) => <squareShapeType>, pack=game.functions.graph.generators.basis.square, label=Square, cls=game.functions.graph.generators.basis.square.SquareShapeType, keyword=Square, atomic=Square, atomic path=game.functions.graph.generators.basis.square.SquareShapeType.Square
gd~~ Rectangle name=Rectangle type=Constant (game.functions.graph.generators.basis.square.SquareShapeType.Rectangle) => <squareShapeType>, pack=game.functions.graph.generators.basis.square, label=Rectangle, cls=game.functions.graph.generators.basis.square.SquareShapeType, keyword=Rectangle, atomic=Rectangle, atomic path=game.functions.graph.generators.basis.square.SquareShapeType.Rectangle
gd~~ Diamond name=Diamond type=Constant (game.functions.graph.generators.basis.square.SquareShapeType.Diamond) => <squareShapeType>, pack=game.functions.graph.generators.basis.square, label=Diamond, cls=game.functions.graph.generators.basis.square.SquareShapeType, keyword=Diamond, atomic=Diamond, atomic path=game.functions.graph.generators.basis.square.SquareShapeType.Diamond
gd~~ Limping name=Limping type=Constant (game.functions.graph.generators.basis.square.SquareShapeType.Limping) => <squareShapeType>, pack=game.functions.graph.generators.basis.square, label=Limping, cls=game.functions.graph.generators.basis.square.SquareShapeType, keyword=Limping, atomic=Limping, atomic path=game.functions.graph.generators.basis.square.SquareShapeType.Limping
gd~~ T31212 name=T31212 type=Constant (game.functions.graph.generators.basis.tiling.TilingType.T31212) => <tilingType>, pack=game.functions.graph.generators.basis.tiling, label=T31212, cls=game.functions.graph.generators.basis.tiling.TilingType, keyword=T31212, atomic=T31212, atomic path=game.functions.graph.generators.basis.tiling.TilingType.T31212
gd~~ T3464 name=T3464 type=Constant (game.functions.graph.generators.basis.tiling.TilingType.T3464) => <tilingType>, pack=game.functions.graph.generators.basis.tiling, label=T3464, cls=game.functions.graph.generators.basis.tiling.TilingType, keyword=T3464, atomic=T3464, atomic path=game.functions.graph.generators.basis.tiling.TilingType.T3464
gd~~ T488 name=T488 type=Constant (game.functions.graph.generators.basis.tiling.TilingType.T488) => <tilingType>, pack=game.functions.graph.generators.basis.tiling, label=T488, cls=game.functions.graph.generators.basis.tiling.TilingType, keyword=T488, atomic=T488, atomic path=game.functions.graph.generators.basis.tiling.TilingType.T488
gd~~ T33434 name=T33434 type=Constant (game.functions.graph.generators.basis.tiling.TilingType.T33434) => <tilingType>, pack=game.functions.graph.generators.basis.tiling, label=T33434, cls=game.functions.graph.generators.basis.tiling.TilingType, keyword=T33434, atomic=T33434, atomic path=game.functions.graph.generators.basis.tiling.TilingType.T33434
gd~~ T33336 name=T33336 type=Constant (game.functions.graph.generators.basis.tiling.TilingType.T33336) => <tilingType>, pack=game.functions.graph.generators.basis.tiling, label=T33336, cls=game.functions.graph.generators.basis.tiling.TilingType, keyword=T33336, atomic=T33336, atomic path=game.functions.graph.generators.basis.tiling.TilingType.T33336
gd~~ T33344 name=T33344 type=Constant (game.functions.graph.generators.basis.tiling.TilingType.T33344) => <tilingType>, pack=game.functions.graph.generators.basis.tiling, label=T33344, cls=game.functions.graph.generators.basis.tiling.TilingType, keyword=T33344, atomic=T33344, atomic path=game.functions.graph.generators.basis.tiling.TilingType.T33344
gd~~ T3636 name=T3636 type=Constant (game.functions.graph.generators.basis.tiling.TilingType.T3636) => <tilingType>, pack=game.functions.graph.generators.basis.tiling, label=T3636, cls=game.functions.graph.generators.basis.tiling.TilingType, keyword=T3636, atomic=T3636, atomic path=game.functions.graph.generators.basis.tiling.TilingType.T3636
gd~~ T4612 name=T4612 type=Constant (game.functions.graph.generators.basis.tiling.TilingType.T4612) => <tilingType>, pack=game.functions.graph.generators.basis.tiling, label=T4612, cls=game.functions.graph.generators.basis.tiling.TilingType, keyword=T4612, atomic=T4612, atomic path=game.functions.graph.generators.basis.tiling.TilingType.T4612
gd~~ T333333_33434 name=T333333_33434 type=Constant (game.functions.graph.generators.basis.tiling.TilingType.T333333_33434) => <tilingType>, pack=game.functions.graph.generators.basis.tiling, label=T333333_33434, cls=game.functions.graph.generators.basis.tiling.TilingType, keyword=T333333_33434, atomic=T333333_33434, atomic path=game.functions.graph.generators.basis.tiling.TilingType.T333333_33434
~~~~ Custom name=Custom type=Constant (game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Custom) => <tiling3464ShapeType>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=Custom, cls=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType, keyword=Custom, atomic=Custom, atomic path=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Custom
~~~~ Square name=Square type=Constant (game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Square) => <tiling3464ShapeType>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=Square, cls=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType, keyword=Square, atomic=Square, atomic path=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Square
~~~~ Rectangle name=Rectangle type=Constant (game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Rectangle) => <tiling3464ShapeType>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=Rectangle, cls=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType, keyword=Rectangle, atomic=Rectangle, atomic path=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Rectangle
~~~~ Diamond name=Diamond type=Constant (game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Diamond) => <tiling3464ShapeType>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=Diamond, cls=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType, keyword=Diamond, atomic=Diamond, atomic path=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Diamond
~~~~ Prism name=Prism type=Constant (game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Prism) => <tiling3464ShapeType>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=Prism, cls=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType, keyword=Prism, atomic=Prism, atomic path=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Prism
~~~~ Triangle name=Triangle type=Constant (game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Triangle) => <tiling3464ShapeType>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=Triangle, cls=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType, keyword=Triangle, atomic=Triangle, atomic path=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Triangle
~~~~ Hexagon name=Hexagon type=Constant (game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Hexagon) => <tiling3464ShapeType>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=Hexagon, cls=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType, keyword=Hexagon, atomic=Hexagon, atomic path=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Hexagon
~~~~ Star name=Star type=Constant (game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Star) => <tiling3464ShapeType>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=Star, cls=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType, keyword=Star, atomic=Star, atomic path=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Star
~~~~ Limping name=Limping type=Constant (game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Limping) => <tiling3464ShapeType>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=Limping, cls=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType, keyword=Limping, atomic=Limping, atomic path=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Limping
gd~~ NoShape name=NoShape type=Constant (game.functions.graph.generators.basis.tri.TriShapeType.NoShape) => <triShapeType>, pack=game.functions.graph.generators.basis.tri, label=NoShape, cls=game.functions.graph.generators.basis.tri.TriShapeType, keyword=NoShape, atomic=NoShape, atomic path=game.functions.graph.generators.basis.tri.TriShapeType.NoShape
gd~~ Square name=Square type=Constant (game.functions.graph.generators.basis.tri.TriShapeType.Square) => <triShapeType>, pack=game.functions.graph.generators.basis.tri, label=Square, cls=game.functions.graph.generators.basis.tri.TriShapeType, keyword=Square, atomic=Square, atomic path=game.functions.graph.generators.basis.tri.TriShapeType.Square
gd~~ Rectangle name=Rectangle type=Constant (game.functions.graph.generators.basis.tri.TriShapeType.Rectangle) => <triShapeType>, pack=game.functions.graph.generators.basis.tri, label=Rectangle, cls=game.functions.graph.generators.basis.tri.TriShapeType, keyword=Rectangle, atomic=Rectangle, atomic path=game.functions.graph.generators.basis.tri.TriShapeType.Rectangle
gd~~ Diamond name=Diamond type=Constant (game.functions.graph.generators.basis.tri.TriShapeType.Diamond) => <triShapeType>, pack=game.functions.graph.generators.basis.tri, label=Diamond, cls=game.functions.graph.generators.basis.tri.TriShapeType, keyword=Diamond, atomic=Diamond, atomic path=game.functions.graph.generators.basis.tri.TriShapeType.Diamond
gd~~ Triangle name=Triangle type=Constant (game.functions.graph.generators.basis.tri.TriShapeType.Triangle) => <triShapeType>, pack=game.functions.graph.generators.basis.tri, label=Triangle, cls=game.functions.graph.generators.basis.tri.TriShapeType, keyword=Triangle, atomic=Triangle, atomic path=game.functions.graph.generators.basis.tri.TriShapeType.Triangle
gd~~ Hexagon name=Hexagon type=Constant (game.functions.graph.generators.basis.tri.TriShapeType.Hexagon) => <triShapeType>, pack=game.functions.graph.generators.basis.tri, label=Hexagon, cls=game.functions.graph.generators.basis.tri.TriShapeType, keyword=Hexagon, atomic=Hexagon, atomic path=game.functions.graph.generators.basis.tri.TriShapeType.Hexagon
gd~~ Star name=Star type=Constant (game.functions.graph.generators.basis.tri.TriShapeType.Star) => <triShapeType>, pack=game.functions.graph.generators.basis.tri, label=Star, cls=game.functions.graph.generators.basis.tri.TriShapeType, keyword=Star, atomic=Star, atomic path=game.functions.graph.generators.basis.tri.TriShapeType.Star
gd~~ Limping name=Limping type=Constant (game.functions.graph.generators.basis.tri.TriShapeType.Limping) => <triShapeType>, pack=game.functions.graph.generators.basis.tri, label=Limping, cls=game.functions.graph.generators.basis.tri.TriShapeType, keyword=Limping, atomic=Limping, atomic path=game.functions.graph.generators.basis.tri.TriShapeType.Limping
gd~~ Prism name=Prism type=Constant (game.functions.graph.generators.basis.tri.TriShapeType.Prism) => <triShapeType>, pack=game.functions.graph.generators.basis.tri, label=Prism, cls=game.functions.graph.generators.basis.tri.TriShapeType, keyword=Prism, atomic=Prism, atomic path=game.functions.graph.generators.basis.tri.TriShapeType.Prism
gd~~ Star name=Star type=Constant (game.functions.graph.generators.shape.ShapeStarType.Star) => <shapeStarType>, pack=game.functions.graph.generators.shape, label=Star, cls=game.functions.graph.generators.shape.ShapeStarType, keyword=Star, atomic=Star, atomic path=game.functions.graph.generators.shape.ShapeStarType.Star
gd~~ Square name=Square type=Constant (game.functions.graph.generators.shape.concentric.ConcentricShapeType.Square) => <concentricShapeType>, pack=game.functions.graph.generators.shape.concentric, label=Square, cls=game.functions.graph.generators.shape.concentric.ConcentricShapeType, keyword=Square, atomic=Square, atomic path=game.functions.graph.generators.shape.concentric.ConcentricShapeType.Square
gd~~ Triangle name=Triangle type=Constant (game.functions.graph.generators.shape.concentric.ConcentricShapeType.Triangle) => <concentricShapeType>, pack=game.functions.graph.generators.shape.concentric, label=Triangle, cls=game.functions.graph.generators.shape.concentric.ConcentricShapeType, keyword=Triangle, atomic=Triangle, atomic path=game.functions.graph.generators.shape.concentric.ConcentricShapeType.Triangle
gd~~ Hexagon name=Hexagon type=Constant (game.functions.graph.generators.shape.concentric.ConcentricShapeType.Hexagon) => <concentricShapeType>, pack=game.functions.graph.generators.shape.concentric, label=Hexagon, cls=game.functions.graph.generators.shape.concentric.ConcentricShapeType, keyword=Hexagon, atomic=Hexagon, atomic path=game.functions.graph.generators.shape.concentric.ConcentricShapeType.Hexagon
gd~~ Target name=Target type=Constant (game.functions.graph.generators.shape.concentric.ConcentricShapeType.Target) => <concentricShapeType>, pack=game.functions.graph.generators.shape.concentric, label=Target, cls=game.functions.graph.generators.shape.concentric.ConcentricShapeType, keyword=Target, atomic=Target, atomic path=game.functions.graph.generators.shape.concentric.ConcentricShapeType.Target
gd~~ All name=All type=Constant (game.functions.intArray.players.PlayersManyType.All) => <playersManyType>, pack=game.functions.intArray.players, label=All, cls=game.functions.intArray.players.PlayersManyType, keyword=All, atomic=All, atomic path=game.functions.intArray.players.PlayersManyType.All
gd~~ NonMover name=NonMover type=Constant (game.functions.intArray.players.PlayersManyType.NonMover) => <playersManyType>, pack=game.functions.intArray.players, label=NonMover, cls=game.functions.intArray.players.PlayersManyType, keyword=NonMover, atomic=NonMover, atomic path=game.functions.intArray.players.PlayersManyType.NonMover
gd~~ Enemy name=Enemy type=Constant (game.functions.intArray.players.PlayersManyType.Enemy) => <playersManyType>, pack=game.functions.intArray.players, label=Enemy, cls=game.functions.intArray.players.PlayersManyType, keyword=Enemy, atomic=Enemy, atomic path=game.functions.intArray.players.PlayersManyType.Enemy
gd~~ Friend name=Friend type=Constant (game.functions.intArray.players.PlayersManyType.Friend) => <playersManyType>, pack=game.functions.intArray.players, label=Friend, cls=game.functions.intArray.players.PlayersManyType, keyword=Friend, atomic=Friend, atomic path=game.functions.intArray.players.PlayersManyType.Friend
gd~~ Ally name=Ally type=Constant (game.functions.intArray.players.PlayersManyType.Ally) => <playersManyType>, pack=game.functions.intArray.players, label=Ally, cls=game.functions.intArray.players.PlayersManyType, keyword=Ally, atomic=Ally, atomic path=game.functions.intArray.players.PlayersManyType.Ally
gd~~ Team1 name=Team1 type=Constant (game.functions.intArray.players.PlayersTeamType.Team1) => <playersTeamType>, pack=game.functions.intArray.players, label=Team1, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team1, atomic=Team1, atomic path=game.functions.intArray.players.PlayersTeamType.Team1
gd~~ Team2 name=Team2 type=Constant (game.functions.intArray.players.PlayersTeamType.Team2) => <playersTeamType>, pack=game.functions.intArray.players, label=Team2, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team2, atomic=Team2, atomic path=game.functions.intArray.players.PlayersTeamType.Team2
gd~~ Team3 name=Team3 type=Constant (game.functions.intArray.players.PlayersTeamType.Team3) => <playersTeamType>, pack=game.functions.intArray.players, label=Team3, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team3, atomic=Team3, atomic path=game.functions.intArray.players.PlayersTeamType.Team3
gd~~ Team4 name=Team4 type=Constant (game.functions.intArray.players.PlayersTeamType.Team4) => <playersTeamType>, pack=game.functions.intArray.players, label=Team4, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team4, atomic=Team4, atomic path=game.functions.intArray.players.PlayersTeamType.Team4
gd~~ Team5 name=Team5 type=Constant (game.functions.intArray.players.PlayersTeamType.Team5) => <playersTeamType>, pack=game.functions.intArray.players, label=Team5, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team5, atomic=Team5, atomic path=game.functions.intArray.players.PlayersTeamType.Team5
gd~~ Team6 name=Team6 type=Constant (game.functions.intArray.players.PlayersTeamType.Team6) => <playersTeamType>, pack=game.functions.intArray.players, label=Team6, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team6, atomic=Team6, atomic path=game.functions.intArray.players.PlayersTeamType.Team6
gd~~ Team7 name=Team7 type=Constant (game.functions.intArray.players.PlayersTeamType.Team7) => <playersTeamType>, pack=game.functions.intArray.players, label=Team7, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team7, atomic=Team7, atomic path=game.functions.intArray.players.PlayersTeamType.Team7
gd~~ Team8 name=Team8 type=Constant (game.functions.intArray.players.PlayersTeamType.Team8) => <playersTeamType>, pack=game.functions.intArray.players, label=Team8, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team8, atomic=Team8, atomic path=game.functions.intArray.players.PlayersTeamType.Team8
gd~~ Team9 name=Team9 type=Constant (game.functions.intArray.players.PlayersTeamType.Team9) => <playersTeamType>, pack=game.functions.intArray.players, label=Team9, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team9, atomic=Team9, atomic path=game.functions.intArray.players.PlayersTeamType.Team9
gd~~ Team10 name=Team10 type=Constant (game.functions.intArray.players.PlayersTeamType.Team10) => <playersTeamType>, pack=game.functions.intArray.players, label=Team10, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team10, atomic=Team10, atomic path=game.functions.intArray.players.PlayersTeamType.Team10
gd~~ Team11 name=Team11 type=Constant (game.functions.intArray.players.PlayersTeamType.Team11) => <playersTeamType>, pack=game.functions.intArray.players, label=Team11, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team11, atomic=Team11, atomic path=game.functions.intArray.players.PlayersTeamType.Team11
gd~~ Team12 name=Team12 type=Constant (game.functions.intArray.players.PlayersTeamType.Team12) => <playersTeamType>, pack=game.functions.intArray.players, label=Team12, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team12, atomic=Team12, atomic path=game.functions.intArray.players.PlayersTeamType.Team12
gd~~ Team13 name=Team13 type=Constant (game.functions.intArray.players.PlayersTeamType.Team13) => <playersTeamType>, pack=game.functions.intArray.players, label=Team13, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team13, atomic=Team13, atomic path=game.functions.intArray.players.PlayersTeamType.Team13
gd~~ Team14 name=Team14 type=Constant (game.functions.intArray.players.PlayersTeamType.Team14) => <playersTeamType>, pack=game.functions.intArray.players, label=Team14, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team14, atomic=Team14, atomic path=game.functions.intArray.players.PlayersTeamType.Team14
gd~~ Team15 name=Team15 type=Constant (game.functions.intArray.players.PlayersTeamType.Team15) => <playersTeamType>, pack=game.functions.intArray.players, label=Team15, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team15, atomic=Team15, atomic path=game.functions.intArray.players.PlayersTeamType.Team15
gd~~ Team16 name=Team16 type=Constant (game.functions.intArray.players.PlayersTeamType.Team16) => <playersTeamType>, pack=game.functions.intArray.players, label=Team16, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team16, atomic=Team16, atomic path=game.functions.intArray.players.PlayersTeamType.Team16
gd~~ Group name=Group type=Constant (game.functions.intArray.sizes.SizesGroupType.Group) => <sizesGroupType>, pack=game.functions.intArray.sizes, label=Group, cls=game.functions.intArray.sizes.SizesGroupType, keyword=Group, atomic=Group, atomic path=game.functions.intArray.sizes.SizesGroupType.Group
gd~~ Remembered name=Remembered type=Constant (game.functions.intArray.values.ValuesStringType.Remembered) => <valuesStringType>, pack=game.functions.intArray.values, label=Remembered, cls=game.functions.intArray.values.ValuesStringType, keyword=Remembered, atomic=Remembered, atomic path=game.functions.intArray.values.ValuesStringType.Remembered
gd~~ Level name=Level type=Constant (game.functions.ints.board.where.WhereLevelType.Level) => <whereLevelType>, pack=game.functions.ints.board.where, label=Level, cls=game.functions.ints.board.where.WhereLevelType, keyword=Level, atomic=Level, atomic path=game.functions.ints.board.where.WhereLevelType.Level
gd~~ TrumpSuit name=TrumpSuit type=Constant (game.functions.ints.card.CardSimpleType.TrumpSuit) => <cardSimpleType>, pack=game.functions.ints.card, label=TrumpSuit, cls=game.functions.ints.card.CardSimpleType, keyword=TrumpSuit, atomic=TrumpSuit, atomic path=game.functions.ints.card.CardSimpleType.TrumpSuit
gd~~ Rank name=Rank type=Constant (game.functions.ints.card.CardSiteType.Rank) => <cardSiteType>, pack=game.functions.ints.card, label=Rank, cls=game.functions.ints.card.CardSiteType, keyword=Rank, atomic=Rank, atomic path=game.functions.ints.card.CardSiteType.Rank
gd~~ Suit name=Suit type=Constant (game.functions.ints.card.CardSiteType.Suit) => <cardSiteType>, pack=game.functions.ints.card, label=Suit, cls=game.functions.ints.card.CardSiteType, keyword=Suit, atomic=Suit, atomic path=game.functions.ints.card.CardSiteType.Suit
gd~~ TrumpValue name=TrumpValue type=Constant (game.functions.ints.card.CardSiteType.TrumpValue) => <cardSiteType>, pack=game.functions.ints.card, label=TrumpValue, cls=game.functions.ints.card.CardSiteType, keyword=TrumpValue, atomic=TrumpValue, atomic path=game.functions.ints.card.CardSiteType.TrumpValue
gd~~ TrumpRank name=TrumpRank type=Constant (game.functions.ints.card.CardSiteType.TrumpRank) => <cardSiteType>, pack=game.functions.ints.card, label=TrumpRank, cls=game.functions.ints.card.CardSiteType, keyword=TrumpRank, atomic=TrumpRank, atomic path=game.functions.ints.card.CardSiteType.TrumpRank
gd~~ Pieces name=Pieces type=Constant (game.functions.ints.count.CountComponentType.Pieces) => <countComponentType>, pack=game.functions.ints.count, label=Pieces, cls=game.functions.ints.count.CountComponentType, keyword=Pieces, atomic=Pieces, atomic path=game.functions.ints.count.CountComponentType.Pieces
gd~~ Pips name=Pips type=Constant (game.functions.ints.count.CountComponentType.Pips) => <countComponentType>, pack=game.functions.ints.count, label=Pips, cls=game.functions.ints.count.CountComponentType, keyword=Pips, atomic=Pips, atomic path=game.functions.ints.count.CountComponentType.Pips
gd~~ Groups name=Groups type=Constant (game.functions.ints.count.CountGroupsType.Groups) => <countGroupsType>, pack=game.functions.ints.count, label=Groups, cls=game.functions.ints.count.CountGroupsType, keyword=Groups, atomic=Groups, atomic path=game.functions.ints.count.CountGroupsType.Groups
gd~~ Liberties name=Liberties type=Constant (game.functions.ints.count.CountLibertiesType.Liberties) => <countLibertiesType>, pack=game.functions.ints.count, label=Liberties, cls=game.functions.ints.count.CountLibertiesType, keyword=Liberties, atomic=Liberties, atomic path=game.functions.ints.count.CountLibertiesType.Liberties
gd~~ Rows name=Rows type=Constant (game.functions.ints.count.CountSimpleType.Rows) => <countSimpleType>, pack=game.functions.ints.count, label=Rows, cls=game.functions.ints.count.CountSimpleType, keyword=Rows, atomic=Rows, atomic path=game.functions.ints.count.CountSimpleType.Rows
gd~~ Columns name=Columns type=Constant (game.functions.ints.count.CountSimpleType.Columns) => <countSimpleType>, pack=game.functions.ints.count, label=Columns, cls=game.functions.ints.count.CountSimpleType, keyword=Columns, atomic=Columns, atomic path=game.functions.ints.count.CountSimpleType.Columns
gd~~ Turns name=Turns type=Constant (game.functions.ints.count.CountSimpleType.Turns) => <countSimpleType>, pack=game.functions.ints.count, label=Turns, cls=game.functions.ints.count.CountSimpleType, keyword=Turns, atomic=Turns, atomic path=game.functions.ints.count.CountSimpleType.Turns
gd~~ Moves name=Moves type=Constant (game.functions.ints.count.CountSimpleType.Moves) => <countSimpleType>, pack=game.functions.ints.count, label=Moves, cls=game.functions.ints.count.CountSimpleType, keyword=Moves, atomic=Moves, atomic path=game.functions.ints.count.CountSimpleType.Moves
gd~~ Trials name=Trials type=Constant (game.functions.ints.count.CountSimpleType.Trials) => <countSimpleType>, pack=game.functions.ints.count, label=Trials, cls=game.functions.ints.count.CountSimpleType, keyword=Trials, atomic=Trials, atomic path=game.functions.ints.count.CountSimpleType.Trials
gd~~ MovesThisTurn name=MovesThisTurn type=Constant (game.functions.ints.count.CountSimpleType.MovesThisTurn) => <countSimpleType>, pack=game.functions.ints.count, label=MovesThisTurn, cls=game.functions.ints.count.CountSimpleType, keyword=MovesThisTurn, atomic=MovesThisTurn, atomic path=game.functions.ints.count.CountSimpleType.MovesThisTurn
gd~~ Phases name=Phases type=Constant (game.functions.ints.count.CountSimpleType.Phases) => <countSimpleType>, pack=game.functions.ints.count, label=Phases, cls=game.functions.ints.count.CountSimpleType, keyword=Phases, atomic=Phases, atomic path=game.functions.ints.count.CountSimpleType.Phases
gd~~ Vertices name=Vertices type=Constant (game.functions.ints.count.CountSimpleType.Vertices) => <countSimpleType>, pack=game.functions.ints.count, label=Vertices, cls=game.functions.ints.count.CountSimpleType, keyword=Vertices, atomic=Vertices, atomic path=game.functions.ints.count.CountSimpleType.Vertices
gd~~ Edges name=Edges type=Constant (game.functions.ints.count.CountSimpleType.Edges) => <countSimpleType>, pack=game.functions.ints.count, label=Edges, cls=game.functions.ints.count.CountSimpleType, keyword=Edges, atomic=Edges, atomic path=game.functions.ints.count.CountSimpleType.Edges
gd~~ Cells name=Cells type=Constant (game.functions.ints.count.CountSimpleType.Cells) => <countSimpleType>, pack=game.functions.ints.count, label=Cells, cls=game.functions.ints.count.CountSimpleType, keyword=Cells, atomic=Cells, atomic path=game.functions.ints.count.CountSimpleType.Cells
gd~~ Players name=Players type=Constant (game.functions.ints.count.CountSimpleType.Players) => <countSimpleType>, pack=game.functions.ints.count, label=Players, cls=game.functions.ints.count.CountSimpleType, keyword=Players, atomic=Players, atomic path=game.functions.ints.count.CountSimpleType.Players
gd~~ Active name=Active type=Constant (game.functions.ints.count.CountSimpleType.Active) => <countSimpleType>, pack=game.functions.ints.count, label=Active, cls=game.functions.ints.count.CountSimpleType, keyword=Active, atomic=Active, atomic path=game.functions.ints.count.CountSimpleType.Active
gd~~ LegalMoves name=LegalMoves type=Constant (game.functions.ints.count.CountSimpleType.LegalMoves) => <countSimpleType>, pack=game.functions.ints.count, label=LegalMoves, cls=game.functions.ints.count.CountSimpleType, keyword=LegalMoves, atomic=LegalMoves, atomic path=game.functions.ints.count.CountSimpleType.LegalMoves
gd~~ Sites name=Sites type=Constant (game.functions.ints.count.CountSiteType.Sites) => <countSiteType>, pack=game.functions.ints.count, label=Sites, cls=game.functions.ints.count.CountSiteType, keyword=Sites, atomic=Sites, atomic path=game.functions.ints.count.CountSiteType.Sites
gd~~ Adjacent name=Adjacent type=Constant (game.functions.ints.count.CountSiteType.Adjacent) => <countSiteType>, pack=game.functions.ints.count, label=Adjacent, cls=game.functions.ints.count.CountSiteType, keyword=Adjacent, atomic=Adjacent, atomic path=game.functions.ints.count.CountSiteType.Adjacent
gd~~ Neighbours name=Neighbours type=Constant (game.functions.ints.count.CountSiteType.Neighbours) => <countSiteType>, pack=game.functions.ints.count, label=Neighbours, cls=game.functions.ints.count.CountSiteType, keyword=Neighbours, atomic=Neighbours, atomic path=game.functions.ints.count.CountSiteType.Neighbours
gd~~ Orthogonal name=Orthogonal type=Constant (game.functions.ints.count.CountSiteType.Orthogonal) => <countSiteType>, pack=game.functions.ints.count, label=Orthogonal, cls=game.functions.ints.count.CountSiteType, keyword=Orthogonal, atomic=Orthogonal, atomic path=game.functions.ints.count.CountSiteType.Orthogonal
gd~~ Diagonal name=Diagonal type=Constant (game.functions.ints.count.CountSiteType.Diagonal) => <countSiteType>, pack=game.functions.ints.count, label=Diagonal, cls=game.functions.ints.count.CountSiteType, keyword=Diagonal, atomic=Diagonal, atomic path=game.functions.ints.count.CountSiteType.Diagonal
gd~~ Off name=Off type=Constant (game.functions.ints.count.CountSiteType.Off) => <countSiteType>, pack=game.functions.ints.count, label=Off, cls=game.functions.ints.count.CountSiteType, keyword=Off, atomic=Off, atomic path=game.functions.ints.count.CountSiteType.Off
gd~~ Stack name=Stack type=Constant (game.functions.ints.count.CountStackType.Stack) => <countStackType>, pack=game.functions.ints.count, label=Stack, cls=game.functions.ints.count.CountStackType, keyword=Stack, atomic=Stack, atomic path=game.functions.ints.count.CountStackType.Stack
gd~~ StepsOnTrack name=StepsOnTrack type=Constant (game.functions.ints.count.CountStepsOnTrackType.StepsOnTrack) => <countStepsOnTrackType>, pack=game.functions.ints.count, label=StepsOnTrack, cls=game.functions.ints.count.CountStepsOnTrackType, keyword=StepsOnTrack, atomic=StepsOnTrack, atomic path=game.functions.ints.count.CountStepsOnTrackType.StepsOnTrack
gd~~ Steps name=Steps type=Constant (game.functions.ints.count.CountStepsType.Steps) => <countStepsType>, pack=game.functions.ints.count, label=Steps, cls=game.functions.ints.count.CountStepsType, keyword=Steps, atomic=Steps, atomic path=game.functions.ints.count.CountStepsType.Steps
gd~~ Value name=Value type=Constant (game.functions.ints.count.CountValueType.Value) => <countValueType>, pack=game.functions.ints.count, label=Value, cls=game.functions.ints.count.CountValueType, keyword=Value, atomic=Value, atomic path=game.functions.ints.count.CountValueType.Value
gd~~ From name=From type=Constant (game.functions.ints.last.LastType.From) => <lastType>, pack=game.functions.ints.last, label=From, cls=game.functions.ints.last.LastType, keyword=From, atomic=From, atomic path=game.functions.ints.last.LastType.From
gd~~ LevelFrom name=LevelFrom type=Constant (game.functions.ints.last.LastType.LevelFrom) => <lastType>, pack=game.functions.ints.last, label=LevelFrom, cls=game.functions.ints.last.LastType, keyword=LevelFrom, atomic=LevelFrom, atomic path=game.functions.ints.last.LastType.LevelFrom
gd~~ To name=To type=Constant (game.functions.ints.last.LastType.To) => <lastType>, pack=game.functions.ints.last, label=To, cls=game.functions.ints.last.LastType, keyword=To, atomic=To, atomic path=game.functions.ints.last.LastType.To
gd~~ LevelTo name=LevelTo type=Constant (game.functions.ints.last.LastType.LevelTo) => <lastType>, pack=game.functions.ints.last, label=LevelTo, cls=game.functions.ints.last.LastType, keyword=LevelTo, atomic=LevelTo, atomic path=game.functions.ints.last.LastType.LevelTo
gd~~ Array name=Array type=Constant (game.functions.ints.size.SizeArrayType.Array) => <sizeArrayType>, pack=game.functions.ints.size, label=Array, cls=game.functions.ints.size.SizeArrayType, keyword=Array, atomic=Array, atomic path=game.functions.ints.size.SizeArrayType.Array
gd~~ Group name=Group type=Constant (game.functions.ints.size.SizeGroupType.Group) => <sizeGroupType>, pack=game.functions.ints.size, label=Group, cls=game.functions.ints.size.SizeGroupType, keyword=Group, atomic=Group, atomic path=game.functions.ints.size.SizeGroupType.Group
gd~~ LargePiece name=LargePiece type=Constant (game.functions.ints.size.SizeLargePieceType.LargePiece) => <sizeLargePieceType>, pack=game.functions.ints.size, label=LargePiece, cls=game.functions.ints.size.SizeLargePieceType, keyword=LargePiece, atomic=LargePiece, atomic path=game.functions.ints.size.SizeLargePieceType.LargePiece
gd~~ Stack name=Stack type=Constant (game.functions.ints.size.SizeSiteType.Stack) => <sizeSiteType>, pack=game.functions.ints.size, label=Stack, cls=game.functions.ints.size.SizeSiteType, keyword=Stack, atomic=Stack, atomic path=game.functions.ints.size.SizeSiteType.Stack
gd~~ Territory name=Territory type=Constant (game.functions.ints.size.SizeTerritoryType.Territory) => <sizeTerritoryType>, pack=game.functions.ints.size, label=Territory, cls=game.functions.ints.size.SizeTerritoryType, keyword=Territory, atomic=Territory, atomic path=game.functions.ints.size.SizeTerritoryType.Territory
gd~~ FirstSite name=FirstSite type=Constant (game.functions.ints.trackSite.TrackSiteFirstType.FirstSite) => <trackSiteFirstType>, pack=game.functions.ints.trackSite, label=FirstSite, cls=game.functions.ints.trackSite.TrackSiteFirstType, keyword=FirstSite, atomic=FirstSite, atomic path=game.functions.ints.trackSite.TrackSiteFirstType.FirstSite
gd~~ Move name=Move type=Constant (game.functions.ints.trackSite.TrackSiteMoveType.Move) => <trackSiteMoveType>, pack=game.functions.ints.trackSite, label=Move, cls=game.functions.ints.trackSite.TrackSiteMoveType, keyword=Move, atomic=Move, atomic path=game.functions.ints.trackSite.TrackSiteMoveType.Move
gd~~ EndSite name=EndSite type=Constant (game.functions.ints.trackSite.TrackSiteType.EndSite) => <trackSiteType>, pack=game.functions.ints.trackSite, label=EndSite, cls=game.functions.ints.trackSite.TrackSiteType, keyword=EndSite, atomic=EndSite, atomic path=game.functions.ints.trackSite.TrackSiteType.EndSite
gd~~ Piece name=Piece type=Constant (game.functions.ints.value.ValueComponentType.Piece) => <valueComponentType>, pack=game.functions.ints.value, label=Piece, cls=game.functions.ints.value.ValueComponentType, keyword=Piece, atomic=Piece, atomic path=game.functions.ints.value.ValueComponentType.Piece
gd~~ Player name=Player type=Constant (game.functions.ints.value.ValuePlayerType.Player) => <valuePlayerType>, pack=game.functions.ints.value, label=Player, cls=game.functions.ints.value.ValuePlayerType, keyword=Player, atomic=Player, atomic path=game.functions.ints.value.ValuePlayerType.Player
gd~~ Random name=Random type=Constant (game.functions.ints.value.ValueRandomType.Random) => <valueRandomType>, pack=game.functions.ints.value, label=Random, cls=game.functions.ints.value.ValueRandomType, keyword=Random, atomic=Random, atomic path=game.functions.ints.value.ValueRandomType.Random
gd~~ Pending name=Pending type=Constant (game.functions.ints.value.ValueSimpleType.Pending) => <valueSimpleType>, pack=game.functions.ints.value, label=Pending, cls=game.functions.ints.value.ValueSimpleType, keyword=Pending, atomic=Pending, atomic path=game.functions.ints.value.ValueSimpleType.Pending
gd~~ MoveLimit name=MoveLimit type=Constant (game.functions.ints.value.ValueSimpleType.MoveLimit) => <valueSimpleType>, pack=game.functions.ints.value, label=MoveLimit, cls=game.functions.ints.value.ValueSimpleType, keyword=MoveLimit, atomic=MoveLimit, atomic path=game.functions.ints.value.ValueSimpleType.MoveLimit
gd~~ TurnLimit name=TurnLimit type=Constant (game.functions.ints.value.ValueSimpleType.TurnLimit) => <valueSimpleType>, pack=game.functions.ints.value, label=TurnLimit, cls=game.functions.ints.value.ValueSimpleType, keyword=TurnLimit, atomic=TurnLimit, atomic path=game.functions.ints.value.ValueSimpleType.TurnLimit
gd~~ Level name=Level type=Constant (game.functions.region.foreach.ForEachLevelType.Level) => <forEachLevelType>, pack=game.functions.region.foreach, label=Level, cls=game.functions.region.foreach.ForEachLevelType, keyword=Level, atomic=Level, atomic path=game.functions.region.foreach.ForEachLevelType.Level
gd~~ Between name=Between type=Constant (game.functions.region.last.LastRegionType.Between) => <lastRegionType>, pack=game.functions.region.last, label=Between, cls=game.functions.region.last.LastRegionType, keyword=Between, atomic=Between, atomic path=game.functions.region.last.LastRegionType.Between
gd~~ Empty name=Empty type=Constant (game.functions.region.sites.LineOfSightType.Empty) => <lineOfSightType>, pack=game.functions.region.sites, label=Empty, cls=game.functions.region.sites.LineOfSightType, keyword=Empty, atomic=Empty, atomic path=game.functions.region.sites.LineOfSightType.Empty
gd~~ Farthest name=Farthest type=Constant (game.functions.region.sites.LineOfSightType.Farthest) => <lineOfSightType>, pack=game.functions.region.sites, label=Farthest, cls=game.functions.region.sites.LineOfSightType, keyword=Farthest, atomic=Farthest, atomic path=game.functions.region.sites.LineOfSightType.Farthest
gd~~ Piece name=Piece type=Constant (game.functions.region.sites.LineOfSightType.Piece) => <lineOfSightType>, pack=game.functions.region.sites, label=Piece, cls=game.functions.region.sites.LineOfSightType, keyword=Piece, atomic=Piece, atomic path=game.functions.region.sites.LineOfSightType.Piece
gd~~ Around name=Around type=Constant (game.functions.region.sites.SitesAroundType.Around) => <sitesAroundType>, pack=game.functions.region.sites, label=Around, cls=game.functions.region.sites.SitesAroundType, keyword=Around, atomic=Around, atomic path=game.functions.region.sites.SitesAroundType.Around
gd~~ Between name=Between type=Constant (game.functions.region.sites.SitesBetweenType.Between) => <sitesBetweenType>, pack=game.functions.region.sites, label=Between, cls=game.functions.region.sites.SitesBetweenType, keyword=Between, atomic=Between, atomic path=game.functions.region.sites.SitesBetweenType.Between
gd~~ Crossing name=Crossing type=Constant (game.functions.region.sites.SitesCrossingType.Crossing) => <sitesCrossingType>, pack=game.functions.region.sites, label=Crossing, cls=game.functions.region.sites.SitesCrossingType, keyword=Crossing, atomic=Crossing, atomic path=game.functions.region.sites.SitesCrossingType.Crossing
gd~~ Direction name=Direction type=Constant (game.functions.region.sites.SitesDirectionType.Direction) => <sitesDirectionType>, pack=game.functions.region.sites, label=Direction, cls=game.functions.region.sites.SitesDirectionType, keyword=Direction, atomic=Direction, atomic path=game.functions.region.sites.SitesDirectionType.Direction
gd~~ Distance name=Distance type=Constant (game.functions.region.sites.SitesDistanceType.Distance) => <sitesDistanceType>, pack=game.functions.region.sites, label=Distance, cls=game.functions.region.sites.SitesDistanceType, keyword=Distance, atomic=Distance, atomic path=game.functions.region.sites.SitesDistanceType.Distance
gd~~ Axial name=Axial type=Constant (game.functions.region.sites.SitesEdgeType.Axial) => <sitesEdgeType>, pack=game.functions.region.sites, label=Axial, cls=game.functions.region.sites.SitesEdgeType, keyword=Axial, atomic=Axial, atomic path=game.functions.region.sites.SitesEdgeType.Axial
gd~~ Horizontal name=Horizontal type=Constant (game.functions.region.sites.SitesEdgeType.Horizontal) => <sitesEdgeType>, pack=game.functions.region.sites, label=Horizontal, cls=game.functions.region.sites.SitesEdgeType, keyword=Horizontal, atomic=Horizontal, atomic path=game.functions.region.sites.SitesEdgeType.Horizontal
gd~~ Vertical name=Vertical type=Constant (game.functions.region.sites.SitesEdgeType.Vertical) => <sitesEdgeType>, pack=game.functions.region.sites, label=Vertical, cls=game.functions.region.sites.SitesEdgeType, keyword=Vertical, atomic=Vertical, atomic path=game.functions.region.sites.SitesEdgeType.Vertical
gd~~ Angled name=Angled type=Constant (game.functions.region.sites.SitesEdgeType.Angled) => <sitesEdgeType>, pack=game.functions.region.sites, label=Angled, cls=game.functions.region.sites.SitesEdgeType, keyword=Angled, atomic=Angled, atomic path=game.functions.region.sites.SitesEdgeType.Angled
gd~~ Slash name=Slash type=Constant (game.functions.region.sites.SitesEdgeType.Slash) => <sitesEdgeType>, pack=game.functions.region.sites, label=Slash, cls=game.functions.region.sites.SitesEdgeType, keyword=Slash, atomic=Slash, atomic path=game.functions.region.sites.SitesEdgeType.Slash
gd~~ Slosh name=Slosh type=Constant (game.functions.region.sites.SitesEdgeType.Slosh) => <sitesEdgeType>, pack=game.functions.region.sites, label=Slosh, cls=game.functions.region.sites.SitesEdgeType, keyword=Slosh, atomic=Slosh, atomic path=game.functions.region.sites.SitesEdgeType.Slosh
gd~~ Group name=Group type=Constant (game.functions.region.sites.SitesGroupType.Group) => <sitesGroupType>, pack=game.functions.region.sites, label=Group, cls=game.functions.region.sites.SitesGroupType, keyword=Group, atomic=Group, atomic path=game.functions.region.sites.SitesGroupType.Group
gd~~ Hidden name=Hidden type=Constant (game.functions.region.sites.SitesHiddenType.Hidden) => <sitesHiddenType>, pack=game.functions.region.sites, label=Hidden, cls=game.functions.region.sites.SitesHiddenType, keyword=Hidden, atomic=Hidden, atomic path=game.functions.region.sites.SitesHiddenType.Hidden
gd~~ Incident name=Incident type=Constant (game.functions.region.sites.SitesIncidentType.Incident) => <sitesIncidentType>, pack=game.functions.region.sites, label=Incident, cls=game.functions.region.sites.SitesIncidentType, keyword=Incident, atomic=Incident, atomic path=game.functions.region.sites.SitesIncidentType.Incident
gd~~ Row name=Row type=Constant (game.functions.region.sites.SitesIndexType.Row) => <sitesIndexType>, pack=game.functions.region.sites, label=Row, cls=game.functions.region.sites.SitesIndexType, keyword=Row, atomic=Row, atomic path=game.functions.region.sites.SitesIndexType.Row
gd~~ Column name=Column type=Constant (game.functions.region.sites.SitesIndexType.Column) => <sitesIndexType>, pack=game.functions.region.sites, label=Column, cls=game.functions.region.sites.SitesIndexType, keyword=Column, atomic=Column, atomic path=game.functions.region.sites.SitesIndexType.Column
gd~~ Phase name=Phase type=Constant (game.functions.region.sites.SitesIndexType.Phase) => <sitesIndexType>, pack=game.functions.region.sites, label=Phase, cls=game.functions.region.sites.SitesIndexType, keyword=Phase, atomic=Phase, atomic path=game.functions.region.sites.SitesIndexType.Phase
gd~~ Cell name=Cell type=Constant (game.functions.region.sites.SitesIndexType.Cell) => <sitesIndexType>, pack=game.functions.region.sites, label=Cell, cls=game.functions.region.sites.SitesIndexType, keyword=Cell, atomic=Cell, atomic path=game.functions.region.sites.SitesIndexType.Cell
gd~~ Edge name=Edge type=Constant (game.functions.region.sites.SitesIndexType.Edge) => <sitesIndexType>, pack=game.functions.region.sites, label=Edge, cls=game.functions.region.sites.SitesIndexType, keyword=Edge, atomic=Edge, atomic path=game.functions.region.sites.SitesIndexType.Edge
gd~~ State name=State type=Constant (game.functions.region.sites.SitesIndexType.State) => <sitesIndexType>, pack=game.functions.region.sites, label=State, cls=game.functions.region.sites.SitesIndexType, keyword=State, atomic=State, atomic path=game.functions.region.sites.SitesIndexType.State
gd~~ Empty name=Empty type=Constant (game.functions.region.sites.SitesIndexType.Empty) => <sitesIndexType>, pack=game.functions.region.sites, label=Empty, cls=game.functions.region.sites.SitesIndexType, keyword=Empty, atomic=Empty, atomic path=game.functions.region.sites.SitesIndexType.Empty
gd~~ Layer name=Layer type=Constant (game.functions.region.sites.SitesIndexType.Layer) => <sitesIndexType>, pack=game.functions.region.sites, label=Layer, cls=game.functions.region.sites.SitesIndexType, keyword=Layer, atomic=Layer, atomic path=game.functions.region.sites.SitesIndexType.Layer
gd~~ LargePiece name=LargePiece type=Constant (game.functions.region.sites.SitesLargePieceType.LargePiece) => <sitesLargePieceType>, pack=game.functions.region.sites, label=LargePiece, cls=game.functions.region.sites.SitesLargePieceType, keyword=LargePiece, atomic=LargePiece, atomic path=game.functions.region.sites.SitesLargePieceType.LargePiece
gd~~ LineOfSight name=LineOfSight type=Constant (game.functions.region.sites.SitesLineOfSightType.LineOfSight) => <sitesLineOfSightType>, pack=game.functions.region.sites, label=LineOfSight, cls=game.functions.region.sites.SitesLineOfSightType, keyword=LineOfSight, atomic=LineOfSight, atomic path=game.functions.region.sites.SitesLineOfSightType.LineOfSight
gd~~ Loop name=Loop type=Constant (game.functions.region.sites.SitesLoopType.Loop) => <sitesLoopType>, pack=game.functions.region.sites, label=Loop, cls=game.functions.region.sites.SitesLoopType, keyword=Loop, atomic=Loop, atomic path=game.functions.region.sites.SitesLoopType.Loop
gd~~ From name=From type=Constant (game.functions.region.sites.SitesMoveType.From) => <sitesMoveType>, pack=game.functions.region.sites, label=From, cls=game.functions.region.sites.SitesMoveType, keyword=From, atomic=From, atomic path=game.functions.region.sites.SitesMoveType.From
gd~~ Between name=Between type=Constant (game.functions.region.sites.SitesMoveType.Between) => <sitesMoveType>, pack=game.functions.region.sites, label=Between, cls=game.functions.region.sites.SitesMoveType, keyword=Between, atomic=Between, atomic path=game.functions.region.sites.SitesMoveType.Between
gd~~ To name=To type=Constant (game.functions.region.sites.SitesMoveType.To) => <sitesMoveType>, pack=game.functions.region.sites, label=To, cls=game.functions.region.sites.SitesMoveType, keyword=To, atomic=To, atomic path=game.functions.region.sites.SitesMoveType.To
gd~~ Occupied name=Occupied type=Constant (game.functions.region.sites.SitesOccupiedType.Occupied) => <sitesOccupiedType>, pack=game.functions.region.sites, label=Occupied, cls=game.functions.region.sites.SitesOccupiedType, keyword=Occupied, atomic=Occupied, atomic path=game.functions.region.sites.SitesOccupiedType.Occupied
gd~~ Pattern name=Pattern type=Constant (game.functions.region.sites.SitesPatternType.Pattern) => <sitesPatternType>, pack=game.functions.region.sites, label=Pattern, cls=game.functions.region.sites.SitesPatternType, keyword=Pattern, atomic=Pattern, atomic path=game.functions.region.sites.SitesPatternType.Pattern
gd~~ Start name=Start type=Constant (game.functions.region.sites.SitesPieceType.Start) => <sitesPieceType>, pack=game.functions.region.sites, label=Start, cls=game.functions.region.sites.SitesPieceType, keyword=Start, atomic=Start, atomic path=game.functions.region.sites.SitesPieceType.Start
gd~~ Hand name=Hand type=Constant (game.functions.region.sites.SitesPlayerType.Hand) => <sitesPlayerType>, pack=game.functions.region.sites, label=Hand, cls=game.functions.region.sites.SitesPlayerType, keyword=Hand, atomic=Hand, atomic path=game.functions.region.sites.SitesPlayerType.Hand
gd~~ Winning name=Winning type=Constant (game.functions.region.sites.SitesPlayerType.Winning) => <sitesPlayerType>, pack=game.functions.region.sites, label=Winning, cls=game.functions.region.sites.SitesPlayerType, keyword=Winning, atomic=Winning, atomic path=game.functions.region.sites.SitesPlayerType.Winning
gd~~ Random name=Random type=Constant (game.functions.region.sites.SitesRandomType.Random) => <sitesRandomType>, pack=game.functions.region.sites, label=Random, cls=game.functions.region.sites.SitesRandomType, keyword=Random, atomic=Random, atomic path=game.functions.region.sites.SitesRandomType.Random
gd~~ Side name=Side type=Constant (game.functions.region.sites.SitesSideType.Side) => <sitesSideType>, pack=game.functions.region.sites, label=Side, cls=game.functions.region.sites.SitesSideType, keyword=Side, atomic=Side, atomic path=game.functions.region.sites.SitesSideType.Side
gd~~ Board name=Board type=Constant (game.functions.region.sites.SitesSimpleType.Board) => <sitesSimpleType>, pack=game.functions.region.sites, label=Board, cls=game.functions.region.sites.SitesSimpleType, keyword=Board, atomic=Board, atomic path=game.functions.region.sites.SitesSimpleType.Board
gd~~ Top name=Top type=Constant (game.functions.region.sites.SitesSimpleType.Top) => <sitesSimpleType>, pack=game.functions.region.sites, label=Top, cls=game.functions.region.sites.SitesSimpleType, keyword=Top, atomic=Top, atomic path=game.functions.region.sites.SitesSimpleType.Top
gd~~ Bottom name=Bottom type=Constant (game.functions.region.sites.SitesSimpleType.Bottom) => <sitesSimpleType>, pack=game.functions.region.sites, label=Bottom, cls=game.functions.region.sites.SitesSimpleType, keyword=Bottom, atomic=Bottom, atomic path=game.functions.region.sites.SitesSimpleType.Bottom
gd~~ Left name=Left type=Constant (game.functions.region.sites.SitesSimpleType.Left) => <sitesSimpleType>, pack=game.functions.region.sites, label=Left, cls=game.functions.region.sites.SitesSimpleType, keyword=Left, atomic=Left, atomic path=game.functions.region.sites.SitesSimpleType.Left
gd~~ Right name=Right type=Constant (game.functions.region.sites.SitesSimpleType.Right) => <sitesSimpleType>, pack=game.functions.region.sites, label=Right, cls=game.functions.region.sites.SitesSimpleType, keyword=Right, atomic=Right, atomic path=game.functions.region.sites.SitesSimpleType.Right
gd~~ Inner name=Inner type=Constant (game.functions.region.sites.SitesSimpleType.Inner) => <sitesSimpleType>, pack=game.functions.region.sites, label=Inner, cls=game.functions.region.sites.SitesSimpleType, keyword=Inner, atomic=Inner, atomic path=game.functions.region.sites.SitesSimpleType.Inner
gd~~ Outer name=Outer type=Constant (game.functions.region.sites.SitesSimpleType.Outer) => <sitesSimpleType>, pack=game.functions.region.sites, label=Outer, cls=game.functions.region.sites.SitesSimpleType, keyword=Outer, atomic=Outer, atomic path=game.functions.region.sites.SitesSimpleType.Outer
gd~~ Perimeter name=Perimeter type=Constant (game.functions.region.sites.SitesSimpleType.Perimeter) => <sitesSimpleType>, pack=game.functions.region.sites, label=Perimeter, cls=game.functions.region.sites.SitesSimpleType, keyword=Perimeter, atomic=Perimeter, atomic path=game.functions.region.sites.SitesSimpleType.Perimeter
gd~~ Corners name=Corners type=Constant (game.functions.region.sites.SitesSimpleType.Corners) => <sitesSimpleType>, pack=game.functions.region.sites, label=Corners, cls=game.functions.region.sites.SitesSimpleType, keyword=Corners, atomic=Corners, atomic path=game.functions.region.sites.SitesSimpleType.Corners
gd~~ ConcaveCorners name=ConcaveCorners type=Constant (game.functions.region.sites.SitesSimpleType.ConcaveCorners) => <sitesSimpleType>, pack=game.functions.region.sites, label=ConcaveCorners, cls=game.functions.region.sites.SitesSimpleType, keyword=ConcaveCorners, atomic=ConcaveCorners, atomic path=game.functions.region.sites.SitesSimpleType.ConcaveCorners
gd~~ ConvexCorners name=ConvexCorners type=Constant (game.functions.region.sites.SitesSimpleType.ConvexCorners) => <sitesSimpleType>, pack=game.functions.region.sites, label=ConvexCorners, cls=game.functions.region.sites.SitesSimpleType, keyword=ConvexCorners, atomic=ConvexCorners, atomic path=game.functions.region.sites.SitesSimpleType.ConvexCorners
gd~~ Major name=Major type=Constant (game.functions.region.sites.SitesSimpleType.Major) => <sitesSimpleType>, pack=game.functions.region.sites, label=Major, cls=game.functions.region.sites.SitesSimpleType, keyword=Major, atomic=Major, atomic path=game.functions.region.sites.SitesSimpleType.Major
gd~~ Minor name=Minor type=Constant (game.functions.region.sites.SitesSimpleType.Minor) => <sitesSimpleType>, pack=game.functions.region.sites, label=Minor, cls=game.functions.region.sites.SitesSimpleType, keyword=Minor, atomic=Minor, atomic path=game.functions.region.sites.SitesSimpleType.Minor
gd~~ Centre name=Centre type=Constant (game.functions.region.sites.SitesSimpleType.Centre) => <sitesSimpleType>, pack=game.functions.region.sites, label=Centre, cls=game.functions.region.sites.SitesSimpleType, keyword=Centre, atomic=Centre, atomic path=game.functions.region.sites.SitesSimpleType.Centre
gd~~ Hint name=Hint type=Constant (game.functions.region.sites.SitesSimpleType.Hint) => <sitesSimpleType>, pack=game.functions.region.sites, label=Hint, cls=game.functions.region.sites.SitesSimpleType, keyword=Hint, atomic=Hint, atomic path=game.functions.region.sites.SitesSimpleType.Hint
gd~~ ToClear name=ToClear type=Constant (game.functions.region.sites.SitesSimpleType.ToClear) => <sitesSimpleType>, pack=game.functions.region.sites, label=ToClear, cls=game.functions.region.sites.SitesSimpleType, keyword=ToClear, atomic=ToClear, atomic path=game.functions.region.sites.SitesSimpleType.ToClear
gd~~ LineOfPlay name=LineOfPlay type=Constant (game.functions.region.sites.SitesSimpleType.LineOfPlay) => <sitesSimpleType>, pack=game.functions.region.sites, label=LineOfPlay, cls=game.functions.region.sites.SitesSimpleType, keyword=LineOfPlay, atomic=LineOfPlay, atomic path=game.functions.region.sites.SitesSimpleType.LineOfPlay
gd~~ Pending name=Pending type=Constant (game.functions.region.sites.SitesSimpleType.Pending) => <sitesSimpleType>, pack=game.functions.region.sites, label=Pending, cls=game.functions.region.sites.SitesSimpleType, keyword=Pending, atomic=Pending, atomic path=game.functions.region.sites.SitesSimpleType.Pending
gd~~ Playable name=Playable type=Constant (game.functions.region.sites.SitesSimpleType.Playable) => <sitesSimpleType>, pack=game.functions.region.sites, label=Playable, cls=game.functions.region.sites.SitesSimpleType, keyword=Playable, atomic=Playable, atomic path=game.functions.region.sites.SitesSimpleType.Playable
gd~~ LastTo name=LastTo type=Constant (game.functions.region.sites.SitesSimpleType.LastTo) => <sitesSimpleType>, pack=game.functions.region.sites, label=LastTo, cls=game.functions.region.sites.SitesSimpleType, keyword=LastTo, atomic=LastTo, atomic path=game.functions.region.sites.SitesSimpleType.LastTo
gd~~ LastFrom name=LastFrom type=Constant (game.functions.region.sites.SitesSimpleType.LastFrom) => <sitesSimpleType>, pack=game.functions.region.sites, label=LastFrom, cls=game.functions.region.sites.SitesSimpleType, keyword=LastFrom, atomic=LastFrom, atomic path=game.functions.region.sites.SitesSimpleType.LastFrom
gd~~ Track name=Track type=Constant (game.functions.region.sites.SitesTrackType.Track) => <sitesTrackType>, pack=game.functions.region.sites, label=Track, cls=game.functions.region.sites.SitesTrackType, keyword=Track, atomic=Track, atomic path=game.functions.region.sites.SitesTrackType.Track
gd~~ Repeat name=Repeat type=Constant (game.rules.meta.no.NoRepeatType.Repeat) => <noRepeatType>, pack=game.rules.meta.no, label=Repeat, cls=game.rules.meta.no.NoRepeatType, keyword=Repeat, atomic=Repeat, atomic path=game.rules.meta.no.NoRepeatType.Repeat
gd~~ Suicide name=Suicide type=Constant (game.rules.meta.no.NoSimpleType.Suicide) => <noSimpleType>, pack=game.rules.meta.no, label=Suicide, cls=game.rules.meta.no.NoSimpleType, keyword=Suicide, atomic=Suicide, atomic path=game.rules.meta.no.NoSimpleType.Suicide
gd~~ Bet name=Bet type=Constant (game.rules.play.moves.decision.MoveBetType.Bet) => <moveBetType>, pack=game.rules.play.moves.decision, label=Bet, cls=game.rules.play.moves.decision.MoveBetType, keyword=Bet, atomic=Bet, atomic path=game.rules.play.moves.decision.MoveBetType.Bet
~~~~ FromTo name=FromTo type=Constant (game.rules.play.moves.decision.MoveFromToType.FromTo) => <moveFromToType>, pack=game.rules.play.moves.decision, label=FromTo, cls=game.rules.play.moves.decision.MoveFromToType, keyword=FromTo, atomic=FromTo, atomic path=game.rules.play.moves.decision.MoveFromToType.FromTo
gd~~ Hop name=Hop type=Constant (game.rules.play.moves.decision.MoveHopType.Hop) => <moveHopType>, pack=game.rules.play.moves.decision, label=Hop, cls=game.rules.play.moves.decision.MoveHopType, keyword=Hop, atomic=Hop, atomic path=game.rules.play.moves.decision.MoveHopType.Hop
gd~~ Leap name=Leap type=Constant (game.rules.play.moves.decision.MoveLeapType.Leap) => <moveLeapType>, pack=game.rules.play.moves.decision, label=Leap, cls=game.rules.play.moves.decision.MoveLeapType, keyword=Leap, atomic=Leap, atomic path=game.rules.play.moves.decision.MoveLeapType.Leap
gd~~ Propose name=Propose type=Constant (game.rules.play.moves.decision.MoveMessageType.Propose) => <moveMessageType>, pack=game.rules.play.moves.decision, label=Propose, cls=game.rules.play.moves.decision.MoveMessageType, keyword=Propose, atomic=Propose, atomic path=game.rules.play.moves.decision.MoveMessageType.Propose
gd~~ Vote name=Vote type=Constant (game.rules.play.moves.decision.MoveMessageType.Vote) => <moveMessageType>, pack=game.rules.play.moves.decision, label=Vote, cls=game.rules.play.moves.decision.MoveMessageType, keyword=Vote, atomic=Vote, atomic path=game.rules.play.moves.decision.MoveMessageType.Vote
gd~~ Promote name=Promote type=Constant (game.rules.play.moves.decision.MovePromoteType.Promote) => <movePromoteType>, pack=game.rules.play.moves.decision, label=Promote, cls=game.rules.play.moves.decision.MovePromoteType, keyword=Promote, atomic=Promote, atomic path=game.rules.play.moves.decision.MovePromoteType.Promote
gd~~ Remove name=Remove type=Constant (game.rules.play.moves.decision.MoveRemoveType.Remove) => <moveRemoveType>, pack=game.rules.play.moves.decision, label=Remove, cls=game.rules.play.moves.decision.MoveRemoveType, keyword=Remove, atomic=Remove, atomic path=game.rules.play.moves.decision.MoveRemoveType.Remove
gd~~ Select name=Select type=Constant (game.rules.play.moves.decision.MoveSelectType.Select) => <moveSelectType>, pack=game.rules.play.moves.decision, label=Select, cls=game.rules.play.moves.decision.MoveSelectType, keyword=Select, atomic=Select, atomic path=game.rules.play.moves.decision.MoveSelectType.Select
gd~~ Set name=Set type=Constant (game.rules.play.moves.decision.MoveSetType.Set) => <moveSetType>, pack=game.rules.play.moves.decision, label=Set, cls=game.rules.play.moves.decision.MoveSetType, keyword=Set, atomic=Set, atomic path=game.rules.play.moves.decision.MoveSetType.Set
gd~~ Shoot name=Shoot type=Constant (game.rules.play.moves.decision.MoveShootType.Shoot) => <moveShootType>, pack=game.rules.play.moves.decision, label=Shoot, cls=game.rules.play.moves.decision.MoveShootType, keyword=Shoot, atomic=Shoot, atomic path=game.rules.play.moves.decision.MoveShootType.Shoot
gd~~ Pass name=Pass type=Constant (game.rules.play.moves.decision.MoveSimpleType.Pass) => <moveSimpleType>, pack=game.rules.play.moves.decision, label=Pass, cls=game.rules.play.moves.decision.MoveSimpleType, keyword=Pass, atomic=Pass, atomic path=game.rules.play.moves.decision.MoveSimpleType.Pass
gd~~ PlayCard name=PlayCard type=Constant (game.rules.play.moves.decision.MoveSimpleType.PlayCard) => <moveSimpleType>, pack=game.rules.play.moves.decision, label=PlayCard, cls=game.rules.play.moves.decision.MoveSimpleType, keyword=PlayCard, atomic=PlayCard, atomic path=game.rules.play.moves.decision.MoveSimpleType.PlayCard
gd~~ Add name=Add type=Constant (game.rules.play.moves.decision.MoveSiteType.Add) => <moveSiteType>, pack=game.rules.play.moves.decision, label=Add, cls=game.rules.play.moves.decision.MoveSiteType, keyword=Add, atomic=Add, atomic path=game.rules.play.moves.decision.MoveSiteType.Add
gd~~ Claim name=Claim type=Constant (game.rules.play.moves.decision.MoveSiteType.Claim) => <moveSiteType>, pack=game.rules.play.moves.decision, label=Claim, cls=game.rules.play.moves.decision.MoveSiteType, keyword=Claim, atomic=Claim, atomic path=game.rules.play.moves.decision.MoveSiteType.Claim
gd~~ Slide name=Slide type=Constant (game.rules.play.moves.decision.MoveSlideType.Slide) => <moveSlideType>, pack=game.rules.play.moves.decision, label=Slide, cls=game.rules.play.moves.decision.MoveSlideType, keyword=Slide, atomic=Slide, atomic path=game.rules.play.moves.decision.MoveSlideType.Slide
gd~~ Step name=Step type=Constant (game.rules.play.moves.decision.MoveStepType.Step) => <moveStepType>, pack=game.rules.play.moves.decision, label=Step, cls=game.rules.play.moves.decision.MoveStepType, keyword=Step, atomic=Step, atomic path=game.rules.play.moves.decision.MoveStepType.Step
gd~~ Swap name=Swap type=Constant (game.rules.play.moves.decision.MoveSwapType.Swap) => <moveSwapType>, pack=game.rules.play.moves.decision, label=Swap, cls=game.rules.play.moves.decision.MoveSwapType, keyword=Swap, atomic=Swap, atomic path=game.rules.play.moves.decision.MoveSwapType.Swap
gd~~ Distance name=Distance type=Constant (game.rules.play.moves.nonDecision.effect.requirement.max.MaxDistanceType.Distance) => <maxDistanceType>, pack=game.rules.play.moves.nonDecision.effect.requirement.max, label=Distance, cls=game.rules.play.moves.nonDecision.effect.requirement.max.MaxDistanceType, keyword=Distance, atomic=Distance, atomic path=game.rules.play.moves.nonDecision.effect.requirement.max.MaxDistanceType.Distance
gd~~ Moves name=Moves type=Constant (game.rules.play.moves.nonDecision.effect.requirement.max.MaxMovesType.Moves) => <maxMovesType>, pack=game.rules.play.moves.nonDecision.effect.requirement.max, label=Moves, cls=game.rules.play.moves.nonDecision.effect.requirement.max.MaxMovesType, keyword=Moves, atomic=Moves, atomic path=game.rules.play.moves.nonDecision.effect.requirement.max.MaxMovesType.Moves
gd~~ Captures name=Captures type=Constant (game.rules.play.moves.nonDecision.effect.requirement.max.MaxMovesType.Captures) => <maxMovesType>, pack=game.rules.play.moves.nonDecision.effect.requirement.max, label=Captures, cls=game.rules.play.moves.nonDecision.effect.requirement.max.MaxMovesType, keyword=Captures, atomic=Captures, atomic path=game.rules.play.moves.nonDecision.effect.requirement.max.MaxMovesType.Captures
gd~~ Hidden name=Hidden type=Constant (game.rules.play.moves.nonDecision.effect.set.SetHiddenType.Hidden) => <setHiddenType>, pack=game.rules.play.moves.nonDecision.effect.set, label=Hidden, cls=game.rules.play.moves.nonDecision.effect.set.SetHiddenType, keyword=Hidden, atomic=Hidden, atomic path=game.rules.play.moves.nonDecision.effect.set.SetHiddenType.Hidden
gd~~ NextPlayer name=NextPlayer type=Constant (game.rules.play.moves.nonDecision.effect.set.SetNextPlayerType.NextPlayer) => <setNextPlayerType>, pack=game.rules.play.moves.nonDecision.effect.set, label=NextPlayer, cls=game.rules.play.moves.nonDecision.effect.set.SetNextPlayerType, keyword=NextPlayer, atomic=NextPlayer, atomic path=game.rules.play.moves.nonDecision.effect.set.SetNextPlayerType.NextPlayer
gd~~ Pending name=Pending type=Constant (game.rules.play.moves.nonDecision.effect.set.SetPendingType.Pending) => <setPendingType>, pack=game.rules.play.moves.nonDecision.effect.set, label=Pending, cls=game.rules.play.moves.nonDecision.effect.set.SetPendingType, keyword=Pending, atomic=Pending, atomic path=game.rules.play.moves.nonDecision.effect.set.SetPendingType.Pending
gd~~ Value name=Value type=Constant (game.rules.play.moves.nonDecision.effect.set.SetPlayerType.Value) => <setPlayerType>, pack=game.rules.play.moves.nonDecision.effect.set, label=Value, cls=game.rules.play.moves.nonDecision.effect.set.SetPlayerType, keyword=Value, atomic=Value, atomic path=game.rules.play.moves.nonDecision.effect.set.SetPlayerType.Value
gd~~ Score name=Score type=Constant (game.rules.play.moves.nonDecision.effect.set.SetPlayerType.Score) => <setPlayerType>, pack=game.rules.play.moves.nonDecision.effect.set, label=Score, cls=game.rules.play.moves.nonDecision.effect.set.SetPlayerType, keyword=Score, atomic=Score, atomic path=game.rules.play.moves.nonDecision.effect.set.SetPlayerType.Score
gd~~ Rotation name=Rotation type=Constant (game.rules.play.moves.nonDecision.effect.set.SetRotationType.Rotation) => <setRotationType>, pack=game.rules.play.moves.nonDecision.effect.set, label=Rotation, cls=game.rules.play.moves.nonDecision.effect.set.SetRotationType, keyword=Rotation, atomic=Rotation, atomic path=game.rules.play.moves.nonDecision.effect.set.SetRotationType.Rotation
gd~~ Count name=Count type=Constant (game.rules.play.moves.nonDecision.effect.set.SetSiteType.Count) => <setSiteType>, pack=game.rules.play.moves.nonDecision.effect.set, label=Count, cls=game.rules.play.moves.nonDecision.effect.set.SetSiteType, keyword=Count, atomic=Count, atomic path=game.rules.play.moves.nonDecision.effect.set.SetSiteType.Count
gd~~ State name=State type=Constant (game.rules.play.moves.nonDecision.effect.set.SetSiteType.State) => <setSiteType>, pack=game.rules.play.moves.nonDecision.effect.set, label=State, cls=game.rules.play.moves.nonDecision.effect.set.SetSiteType, keyword=State, atomic=State, atomic path=game.rules.play.moves.nonDecision.effect.set.SetSiteType.State
gd~~ Value name=Value type=Constant (game.rules.play.moves.nonDecision.effect.set.SetSiteType.Value) => <setSiteType>, pack=game.rules.play.moves.nonDecision.effect.set, label=Value, cls=game.rules.play.moves.nonDecision.effect.set.SetSiteType, keyword=Value, atomic=Value, atomic path=game.rules.play.moves.nonDecision.effect.set.SetSiteType.Value
gd~~ Team name=Team type=Constant (game.rules.play.moves.nonDecision.effect.set.SetTeamType.Team) => <setTeamType>, pack=game.rules.play.moves.nonDecision.effect.set, label=Team, cls=game.rules.play.moves.nonDecision.effect.set.SetTeamType, keyword=Team, atomic=Team, atomic path=game.rules.play.moves.nonDecision.effect.set.SetTeamType.Team
gd~~ TrumpSuit name=TrumpSuit type=Constant (game.rules.play.moves.nonDecision.effect.set.SetTrumpType.TrumpSuit) => <setTrumpType>, pack=game.rules.play.moves.nonDecision.effect.set, label=TrumpSuit, cls=game.rules.play.moves.nonDecision.effect.set.SetTrumpType, keyword=TrumpSuit, atomic=TrumpSuit, atomic path=game.rules.play.moves.nonDecision.effect.set.SetTrumpType.TrumpSuit
gd~~ Counter name=Counter type=Constant (game.rules.play.moves.nonDecision.effect.set.SetValueType.Counter) => <setValueType>, pack=game.rules.play.moves.nonDecision.effect.set, label=Counter, cls=game.rules.play.moves.nonDecision.effect.set.SetValueType, keyword=Counter, atomic=Counter, atomic path=game.rules.play.moves.nonDecision.effect.set.SetValueType.Counter
gd~~ Pot name=Pot type=Constant (game.rules.play.moves.nonDecision.effect.set.SetValueType.Pot) => <setValueType>, pack=game.rules.play.moves.nonDecision.effect.set, label=Pot, cls=game.rules.play.moves.nonDecision.effect.set.SetValueType, keyword=Pot, atomic=Pot, atomic path=game.rules.play.moves.nonDecision.effect.set.SetValueType.Pot
gd~~ Var name=Var type=Constant (game.rules.play.moves.nonDecision.effect.set.SetVarType.Var) => <setVarType>, pack=game.rules.play.moves.nonDecision.effect.set, label=Var, cls=game.rules.play.moves.nonDecision.effect.set.SetVarType, keyword=Var, atomic=Var, atomic path=game.rules.play.moves.nonDecision.effect.set.SetVarType.Var
gd~~ All name=All type=Constant (game.rules.play.moves.nonDecision.effect.state.forget.ForgetValueAllType.All) => <forgetValueAllType>, pack=game.rules.play.moves.nonDecision.effect.state.forget, label=All, cls=game.rules.play.moves.nonDecision.effect.state.forget.ForgetValueAllType, keyword=All, atomic=All, atomic path=game.rules.play.moves.nonDecision.effect.state.forget.ForgetValueAllType.All
gd~~ Value name=Value type=Constant (game.rules.play.moves.nonDecision.effect.state.forget.ForgetValueType.Value) => <forgetValueType>, pack=game.rules.play.moves.nonDecision.effect.state.forget, label=Value, cls=game.rules.play.moves.nonDecision.effect.state.forget.ForgetValueType, keyword=Value, atomic=Value, atomic path=game.rules.play.moves.nonDecision.effect.state.forget.ForgetValueType.Value
gd~~ State name=State type=Constant (game.rules.play.moves.nonDecision.effect.state.remember.RememberStateType.State) => <rememberStateType>, pack=game.rules.play.moves.nonDecision.effect.state.remember, label=State, cls=game.rules.play.moves.nonDecision.effect.state.remember.RememberStateType, keyword=State, atomic=State, atomic path=game.rules.play.moves.nonDecision.effect.state.remember.RememberStateType.State
gd~~ Value name=Value type=Constant (game.rules.play.moves.nonDecision.effect.state.remember.RememberValueType.Value) => <rememberValueType>, pack=game.rules.play.moves.nonDecision.effect.state.remember, label=Value, cls=game.rules.play.moves.nonDecision.effect.state.remember.RememberValueType, keyword=Value, atomic=Value, atomic path=game.rules.play.moves.nonDecision.effect.state.remember.RememberValueType.Value
gd~~ Players name=Players type=Constant (game.rules.play.moves.nonDecision.effect.state.swap.SwapPlayersType.Players) => <swapPlayersType>, pack=game.rules.play.moves.nonDecision.effect.state.swap, label=Players, cls=game.rules.play.moves.nonDecision.effect.state.swap.SwapPlayersType, keyword=Players, atomic=Players, atomic path=game.rules.play.moves.nonDecision.effect.state.swap.SwapPlayersType.Players
gd~~ Pieces name=Pieces type=Constant (game.rules.play.moves.nonDecision.effect.state.swap.SwapSitesType.Pieces) => <swapSitesType>, pack=game.rules.play.moves.nonDecision.effect.state.swap, label=Pieces, cls=game.rules.play.moves.nonDecision.effect.state.swap.SwapSitesType, keyword=Pieces, atomic=Pieces, atomic path=game.rules.play.moves.nonDecision.effect.state.swap.SwapSitesType.Pieces
gd~~ Control name=Control type=Constant (game.rules.play.moves.nonDecision.effect.take.TakeControlType.Control) => <takeControlType>, pack=game.rules.play.moves.nonDecision.effect.take, label=Control, cls=game.rules.play.moves.nonDecision.effect.take.TakeControlType, keyword=Control, atomic=Control, atomic path=game.rules.play.moves.nonDecision.effect.take.TakeControlType.Control
gd~~ Domino name=Domino type=Constant (game.rules.play.moves.nonDecision.effect.take.TakeSimpleType.Domino) => <takeSimpleType>, pack=game.rules.play.moves.nonDecision.effect.take, label=Domino, cls=game.rules.play.moves.nonDecision.effect.take.TakeSimpleType, keyword=Domino, atomic=Domino, atomic path=game.rules.play.moves.nonDecision.effect.take.TakeSimpleType.Domino
gd~~ Die name=Die type=Constant (game.rules.play.moves.nonDecision.operators.foreach.ForEachDieType.Die) => <forEachDieType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=Die, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachDieType, keyword=Die, atomic=Die, atomic path=game.rules.play.moves.nonDecision.operators.foreach.ForEachDieType.Die
gd~~ Direction name=Direction type=Constant (game.rules.play.moves.nonDecision.operators.foreach.ForEachDirectionType.Direction) => <forEachDirectionType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=Direction, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachDirectionType, keyword=Direction, atomic=Direction, atomic path=game.rules.play.moves.nonDecision.operators.foreach.ForEachDirectionType.Direction
gd~~ Group name=Group type=Constant (game.rules.play.moves.nonDecision.operators.foreach.ForEachGroupType.Group) => <forEachGroupType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=Group, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachGroupType, keyword=Group, atomic=Group, atomic path=game.rules.play.moves.nonDecision.operators.foreach.ForEachGroupType.Group
gd~~ Level name=Level type=Constant (game.rules.play.moves.nonDecision.operators.foreach.ForEachLevelType.Level) => <forEachLevelType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=Level, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachLevelType, keyword=Level, atomic=Level, atomic path=game.rules.play.moves.nonDecision.operators.foreach.ForEachLevelType.Level
gd~~ Piece name=Piece type=Constant (game.rules.play.moves.nonDecision.operators.foreach.ForEachPieceType.Piece) => <forEachPieceType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=Piece, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachPieceType, keyword=Piece, atomic=Piece, atomic path=game.rules.play.moves.nonDecision.operators.foreach.ForEachPieceType.Piece
gd~~ Player name=Player type=Constant (game.rules.play.moves.nonDecision.operators.foreach.ForEachPlayerType.Player) => <forEachPlayerType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=Player, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachPlayerType, keyword=Player, atomic=Player, atomic path=game.rules.play.moves.nonDecision.operators.foreach.ForEachPlayerType.Player
gd~~ Site name=Site type=Constant (game.rules.play.moves.nonDecision.operators.foreach.ForEachSiteType.Site) => <forEachSiteType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=Site, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachSiteType, keyword=Site, atomic=Site, atomic path=game.rules.play.moves.nonDecision.operators.foreach.ForEachSiteType.Site
gd~~ Value name=Value type=Constant (game.rules.play.moves.nonDecision.operators.foreach.ForEachValueType.Value) => <forEachValueType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=Value, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachValueType, keyword=Value, atomic=Value, atomic path=game.rules.play.moves.nonDecision.operators.foreach.ForEachValueType.Value
gd~~ Value name=Value type=Constant (game.rules.start.forEach.ForEachStartValueType.Value) => <forEachStartValueType>, pack=game.rules.start.forEach, label=Value, cls=game.rules.start.forEach.ForEachStartValueType, keyword=Value, atomic=Value, atomic path=game.rules.start.forEach.ForEachStartValueType.Value
gd~~ Team name=Team type=Constant (game.rules.start.forEach.ForEachTeamType.Team) => <forEachTeamType>, pack=game.rules.start.forEach, label=Team, cls=game.rules.start.forEach.ForEachTeamType, keyword=Team, atomic=Team, atomic path=game.rules.start.forEach.ForEachTeamType.Team
gd~~ Random name=Random type=Constant (game.rules.start.place.PlaceRandomType.Random) => <placeRandomType>, pack=game.rules.start.place, label=Random, cls=game.rules.start.place.PlaceRandomType, keyword=Random, atomic=Random, atomic path=game.rules.start.place.PlaceRandomType.Random
gd~~ Stack name=Stack type=Constant (game.rules.start.place.PlaceStackType.Stack) => <placeStackType>, pack=game.rules.start.place, label=Stack, cls=game.rules.start.place.PlaceStackType, keyword=Stack, atomic=Stack, atomic path=game.rules.start.place.PlaceStackType.Stack
gd~~ RememberValue name=RememberValue type=Constant (game.rules.start.set.SetRememberValueType.RememberValue) => <setRememberValueType>, pack=game.rules.start.set, label=RememberValue, cls=game.rules.start.set.SetRememberValueType, keyword=RememberValue, atomic=RememberValue, atomic path=game.rules.start.set.SetRememberValueType.RememberValue
~~~~ AllInvisible name=AllInvisible type=Constant (game.rules.start.set.SetStartGraphType.AllInvisible) => <setStartGraphType>, pack=game.rules.start.set, label=AllInvisible, cls=game.rules.start.set.SetStartGraphType, keyword=AllInvisible, atomic=AllInvisible, atomic path=game.rules.start.set.SetStartGraphType.AllInvisible
gd~~ Hidden name=Hidden type=Constant (game.rules.start.set.SetStartHiddenType.Hidden) => <setStartHiddenType>, pack=game.rules.start.set, label=Hidden, cls=game.rules.start.set.SetStartHiddenType, keyword=Hidden, atomic=Hidden, atomic path=game.rules.start.set.SetStartHiddenType.Hidden
gd~~ Amount name=Amount type=Constant (game.rules.start.set.SetStartPlayerType.Amount) => <setStartPlayerType>, pack=game.rules.start.set, label=Amount, cls=game.rules.start.set.SetStartPlayerType, keyword=Amount, atomic=Amount, atomic path=game.rules.start.set.SetStartPlayerType.Amount
gd~~ Score name=Score type=Constant (game.rules.start.set.SetStartPlayerType.Score) => <setStartPlayerType>, pack=game.rules.start.set, label=Score, cls=game.rules.start.set.SetStartPlayerType, keyword=Score, atomic=Score, atomic path=game.rules.start.set.SetStartPlayerType.Score
gd~~ Team name=Team type=Constant (game.rules.start.set.SetStartPlayersType.Team) => <setStartPlayersType>, pack=game.rules.start.set, label=Team, cls=game.rules.start.set.SetStartPlayersType, keyword=Team, atomic=Team, atomic path=game.rules.start.set.SetStartPlayersType.Team
gd~~ Count name=Count type=Constant (game.rules.start.set.SetStartSitesType.Count) => <setStartSitesType>, pack=game.rules.start.set, label=Count, cls=game.rules.start.set.SetStartSitesType, keyword=Count, atomic=Count, atomic path=game.rules.start.set.SetStartSitesType.Count
gd~~ Cost name=Cost type=Constant (game.rules.start.set.SetStartSitesType.Cost) => <setStartSitesType>, pack=game.rules.start.set, label=Cost, cls=game.rules.start.set.SetStartSitesType, keyword=Cost, atomic=Cost, atomic path=game.rules.start.set.SetStartSitesType.Cost
gd~~ Phase name=Phase type=Constant (game.rules.start.set.SetStartSitesType.Phase) => <setStartSitesType>, pack=game.rules.start.set, label=Phase, cls=game.rules.start.set.SetStartSitesType, keyword=Phase, atomic=Phase, atomic path=game.rules.start.set.SetStartSitesType.Phase
gd~~ Deck name=Deck type=Constant (game.rules.start.split.SplitType.Deck) => <splitType>, pack=game.rules.start.split, label=Deck, cls=game.rules.start.split.SplitType, keyword=Deck, atomic=Deck, atomic path=game.rules.start.split.SplitType.Deck
gd~~ NoBasis name=NoBasis type=Constant (game.types.board.BasisType.NoBasis) => <basisType>, pack=game.types.board, label=NoBasis, cls=game.types.board.BasisType, keyword=NoBasis, atomic=NoBasis, atomic path=game.types.board.BasisType.NoBasis
gd~~ Triangular name=Triangular type=Constant (game.types.board.BasisType.Triangular) => <basisType>, pack=game.types.board, label=Triangular, cls=game.types.board.BasisType, keyword=Triangular, atomic=Triangular, atomic path=game.types.board.BasisType.Triangular
gd~~ Square name=Square type=Constant (game.types.board.BasisType.Square) => <basisType>, pack=game.types.board, label=Square, cls=game.types.board.BasisType, keyword=Square, atomic=Square, atomic path=game.types.board.BasisType.Square
gd~~ Hexagonal name=Hexagonal type=Constant (game.types.board.BasisType.Hexagonal) => <basisType>, pack=game.types.board, label=Hexagonal, cls=game.types.board.BasisType, keyword=Hexagonal, atomic=Hexagonal, atomic path=game.types.board.BasisType.Hexagonal
gd~~ T33336 name=T33336 type=Constant (game.types.board.BasisType.T33336) => <basisType>, pack=game.types.board, label=T33336, cls=game.types.board.BasisType, keyword=T33336, atomic=T33336, atomic path=game.types.board.BasisType.T33336
gd~~ T33344 name=T33344 type=Constant (game.types.board.BasisType.T33344) => <basisType>, pack=game.types.board, label=T33344, cls=game.types.board.BasisType, keyword=T33344, atomic=T33344, atomic path=game.types.board.BasisType.T33344
gd~~ T33434 name=T33434 type=Constant (game.types.board.BasisType.T33434) => <basisType>, pack=game.types.board, label=T33434, cls=game.types.board.BasisType, keyword=T33434, atomic=T33434, atomic path=game.types.board.BasisType.T33434
gd~~ T3464 name=T3464 type=Constant (game.types.board.BasisType.T3464) => <basisType>, pack=game.types.board, label=T3464, cls=game.types.board.BasisType, keyword=T3464, atomic=T3464, atomic path=game.types.board.BasisType.T3464
gd~~ T3636 name=T3636 type=Constant (game.types.board.BasisType.T3636) => <basisType>, pack=game.types.board, label=T3636, cls=game.types.board.BasisType, keyword=T3636, atomic=T3636, atomic path=game.types.board.BasisType.T3636
gd~~ T4612 name=T4612 type=Constant (game.types.board.BasisType.T4612) => <basisType>, pack=game.types.board, label=T4612, cls=game.types.board.BasisType, keyword=T4612, atomic=T4612, atomic path=game.types.board.BasisType.T4612
gd~~ T488 name=T488 type=Constant (game.types.board.BasisType.T488) => <basisType>, pack=game.types.board, label=T488, cls=game.types.board.BasisType, keyword=T488, atomic=T488, atomic path=game.types.board.BasisType.T488
gd~~ T31212 name=T31212 type=Constant (game.types.board.BasisType.T31212) => <basisType>, pack=game.types.board, label=T31212, cls=game.types.board.BasisType, keyword=T31212, atomic=T31212, atomic path=game.types.board.BasisType.T31212
gd~~ T333333_33434 name=T333333_33434 type=Constant (game.types.board.BasisType.T333333_33434) => <basisType>, pack=game.types.board, label=T333333_33434, cls=game.types.board.BasisType, keyword=T333333_33434, atomic=T333333_33434, atomic path=game.types.board.BasisType.T333333_33434
gd~~ SquarePyramidal name=SquarePyramidal type=Constant (game.types.board.BasisType.SquarePyramidal) => <basisType>, pack=game.types.board, label=SquarePyramidal, cls=game.types.board.BasisType, keyword=SquarePyramidal, atomic=SquarePyramidal, atomic path=game.types.board.BasisType.SquarePyramidal
gd~~ HexagonalPyramidal name=HexagonalPyramidal type=Constant (game.types.board.BasisType.HexagonalPyramidal) => <basisType>, pack=game.types.board, label=HexagonalPyramidal, cls=game.types.board.BasisType, keyword=HexagonalPyramidal, atomic=HexagonalPyramidal, atomic path=game.types.board.BasisType.HexagonalPyramidal
gd~~ Concentric name=Concentric type=Constant (game.types.board.BasisType.Concentric) => <basisType>, pack=game.types.board, label=Concentric, cls=game.types.board.BasisType, keyword=Concentric, atomic=Concentric, atomic path=game.types.board.BasisType.Concentric
gd~~ Circle name=Circle type=Constant (game.types.board.BasisType.Circle) => <basisType>, pack=game.types.board, label=Circle, cls=game.types.board.BasisType, keyword=Circle, atomic=Circle, atomic path=game.types.board.BasisType.Circle
gd~~ Spiral name=Spiral type=Constant (game.types.board.BasisType.Spiral) => <basisType>, pack=game.types.board, label=Spiral, cls=game.types.board.BasisType, keyword=Spiral, atomic=Spiral, atomic path=game.types.board.BasisType.Spiral
gd~~ Dual name=Dual type=Constant (game.types.board.BasisType.Dual) => <basisType>, pack=game.types.board, label=Dual, cls=game.types.board.BasisType, keyword=Dual, atomic=Dual, atomic path=game.types.board.BasisType.Dual
gd~~ Brick name=Brick type=Constant (game.types.board.BasisType.Brick) => <basisType>, pack=game.types.board, label=Brick, cls=game.types.board.BasisType, keyword=Brick, atomic=Brick, atomic path=game.types.board.BasisType.Brick
gd~~ Mesh name=Mesh type=Constant (game.types.board.BasisType.Mesh) => <basisType>, pack=game.types.board, label=Mesh, cls=game.types.board.BasisType, keyword=Mesh, atomic=Mesh, atomic path=game.types.board.BasisType.Mesh
gd~~ Morris name=Morris type=Constant (game.types.board.BasisType.Morris) => <basisType>, pack=game.types.board, label=Morris, cls=game.types.board.BasisType, keyword=Morris, atomic=Morris, atomic path=game.types.board.BasisType.Morris
gd~~ Celtic name=Celtic type=Constant (game.types.board.BasisType.Celtic) => <basisType>, pack=game.types.board, label=Celtic, cls=game.types.board.BasisType, keyword=Celtic, atomic=Celtic, atomic path=game.types.board.BasisType.Celtic
gd~~ QuadHex name=QuadHex type=Constant (game.types.board.BasisType.QuadHex) => <basisType>, pack=game.types.board, label=QuadHex, cls=game.types.board.BasisType, keyword=QuadHex, atomic=QuadHex, atomic path=game.types.board.BasisType.QuadHex
gd~~ What name=What type=Constant (game.types.board.HiddenData.What) => <hiddenData>, pack=game.types.board, label=What, cls=game.types.board.HiddenData, keyword=What, atomic=What, atomic path=game.types.board.HiddenData.What
gd~~ Who name=Who type=Constant (game.types.board.HiddenData.Who) => <hiddenData>, pack=game.types.board, label=Who, cls=game.types.board.HiddenData, keyword=Who, atomic=Who, atomic path=game.types.board.HiddenData.Who
gd~~ State name=State type=Constant (game.types.board.HiddenData.State) => <hiddenData>, pack=game.types.board, label=State, cls=game.types.board.HiddenData, keyword=State, atomic=State, atomic path=game.types.board.HiddenData.State
gd~~ Count name=Count type=Constant (game.types.board.HiddenData.Count) => <hiddenData>, pack=game.types.board, label=Count, cls=game.types.board.HiddenData, keyword=Count, atomic=Count, atomic path=game.types.board.HiddenData.Count
gd~~ Rotation name=Rotation type=Constant (game.types.board.HiddenData.Rotation) => <hiddenData>, pack=game.types.board, label=Rotation, cls=game.types.board.HiddenData, keyword=Rotation, atomic=Rotation, atomic path=game.types.board.HiddenData.Rotation
gd~~ Value name=Value type=Constant (game.types.board.HiddenData.Value) => <hiddenData>, pack=game.types.board, label=Value, cls=game.types.board.HiddenData, keyword=Value, atomic=Value, atomic path=game.types.board.HiddenData.Value
gd~~ CentreSite name=CentreSite type=Constant (game.types.board.LandmarkType.CentreSite) => <landmarkType>, pack=game.types.board, label=CentreSite, cls=game.types.board.LandmarkType, keyword=CentreSite, atomic=CentreSite, atomic path=game.types.board.LandmarkType.CentreSite
gd~~ LeftSite name=LeftSite type=Constant (game.types.board.LandmarkType.LeftSite) => <landmarkType>, pack=game.types.board, label=LeftSite, cls=game.types.board.LandmarkType, keyword=LeftSite, atomic=LeftSite, atomic path=game.types.board.LandmarkType.LeftSite
gd~~ RightSite name=RightSite type=Constant (game.types.board.LandmarkType.RightSite) => <landmarkType>, pack=game.types.board, label=RightSite, cls=game.types.board.LandmarkType, keyword=RightSite, atomic=RightSite, atomic path=game.types.board.LandmarkType.RightSite
gd~~ Topsite name=Topsite type=Constant (game.types.board.LandmarkType.Topsite) => <landmarkType>, pack=game.types.board, label=Topsite, cls=game.types.board.LandmarkType, keyword=Topsite, atomic=Topsite, atomic path=game.types.board.LandmarkType.Topsite
gd~~ BottomSite name=BottomSite type=Constant (game.types.board.LandmarkType.BottomSite) => <landmarkType>, pack=game.types.board, label=BottomSite, cls=game.types.board.LandmarkType, keyword=BottomSite, atomic=BottomSite, atomic path=game.types.board.LandmarkType.BottomSite
gd~~ FirstSite name=FirstSite type=Constant (game.types.board.LandmarkType.FirstSite) => <landmarkType>, pack=game.types.board, label=FirstSite, cls=game.types.board.LandmarkType, keyword=FirstSite, atomic=FirstSite, atomic path=game.types.board.LandmarkType.FirstSite
gd~~ LastSite name=LastSite type=Constant (game.types.board.LandmarkType.LastSite) => <landmarkType>, pack=game.types.board, label=LastSite, cls=game.types.board.LandmarkType, keyword=LastSite, atomic=LastSite, atomic path=game.types.board.LandmarkType.LastSite
gd~~ Cell name=Cell type=Constant (game.types.board.PuzzleElementType.Cell) => <puzzleElementType>, pack=game.types.board, label=Cell, cls=game.types.board.PuzzleElementType, keyword=Cell, atomic=Cell, atomic path=game.types.board.PuzzleElementType.Cell
gd~~ Edge name=Edge type=Constant (game.types.board.PuzzleElementType.Edge) => <puzzleElementType>, pack=game.types.board, label=Edge, cls=game.types.board.PuzzleElementType, keyword=Edge, atomic=Edge, atomic path=game.types.board.PuzzleElementType.Edge
gd~~ Vertex name=Vertex type=Constant (game.types.board.PuzzleElementType.Vertex) => <puzzleElementType>, pack=game.types.board, label=Vertex, cls=game.types.board.PuzzleElementType, keyword=Vertex, atomic=Vertex, atomic path=game.types.board.PuzzleElementType.Vertex
gd~~ Hint name=Hint type=Constant (game.types.board.PuzzleElementType.Hint) => <puzzleElementType>, pack=game.types.board, label=Hint, cls=game.types.board.PuzzleElementType, keyword=Hint, atomic=Hint, atomic path=game.types.board.PuzzleElementType.Hint
gd~~ Empty name=Empty type=Constant (game.types.board.RegionTypeDynamic.Empty) => <regionTypeDynamic>, pack=game.types.board, label=Empty, cls=game.types.board.RegionTypeDynamic, keyword=Empty, atomic=Empty, atomic path=game.types.board.RegionTypeDynamic.Empty
gd~~ NotEmpty name=NotEmpty type=Constant (game.types.board.RegionTypeDynamic.NotEmpty) => <regionTypeDynamic>, pack=game.types.board, label=NotEmpty, cls=game.types.board.RegionTypeDynamic, keyword=NotEmpty, atomic=NotEmpty, atomic path=game.types.board.RegionTypeDynamic.NotEmpty
gd~~ Own name=Own type=Constant (game.types.board.RegionTypeDynamic.Own) => <regionTypeDynamic>, pack=game.types.board, label=Own, cls=game.types.board.RegionTypeDynamic, keyword=Own, atomic=Own, atomic path=game.types.board.RegionTypeDynamic.Own
gd~~ NotOwn name=NotOwn type=Constant (game.types.board.RegionTypeDynamic.NotOwn) => <regionTypeDynamic>, pack=game.types.board, label=NotOwn, cls=game.types.board.RegionTypeDynamic, keyword=NotOwn, atomic=NotOwn, atomic path=game.types.board.RegionTypeDynamic.NotOwn
gd~~ Enemy name=Enemy type=Constant (game.types.board.RegionTypeDynamic.Enemy) => <regionTypeDynamic>, pack=game.types.board, label=Enemy, cls=game.types.board.RegionTypeDynamic, keyword=Enemy, atomic=Enemy, atomic path=game.types.board.RegionTypeDynamic.Enemy
gd~~ NotEnemy name=NotEnemy type=Constant (game.types.board.RegionTypeDynamic.NotEnemy) => <regionTypeDynamic>, pack=game.types.board, label=NotEnemy, cls=game.types.board.RegionTypeDynamic, keyword=NotEnemy, atomic=NotEnemy, atomic path=game.types.board.RegionTypeDynamic.NotEnemy
gd~~ Rows name=Rows type=Constant (game.types.board.RegionTypeStatic.Rows) => <regionTypeStatic>, pack=game.types.board, label=Rows, cls=game.types.board.RegionTypeStatic, keyword=Rows, atomic=Rows, atomic path=game.types.board.RegionTypeStatic.Rows
gd~~ Columns name=Columns type=Constant (game.types.board.RegionTypeStatic.Columns) => <regionTypeStatic>, pack=game.types.board, label=Columns, cls=game.types.board.RegionTypeStatic, keyword=Columns, atomic=Columns, atomic path=game.types.board.RegionTypeStatic.Columns
gd~~ AllDirections name=AllDirections type=Constant (game.types.board.RegionTypeStatic.AllDirections) => <regionTypeStatic>, pack=game.types.board, label=AllDirections, cls=game.types.board.RegionTypeStatic, keyword=AllDirections, atomic=AllDirections, atomic path=game.types.board.RegionTypeStatic.AllDirections
gd~~ HintRegions name=HintRegions type=Constant (game.types.board.RegionTypeStatic.HintRegions) => <regionTypeStatic>, pack=game.types.board, label=HintRegions, cls=game.types.board.RegionTypeStatic, keyword=HintRegions, atomic=HintRegions, atomic path=game.types.board.RegionTypeStatic.HintRegions
gd~~ Layers name=Layers type=Constant (game.types.board.RegionTypeStatic.Layers) => <regionTypeStatic>, pack=game.types.board, label=Layers, cls=game.types.board.RegionTypeStatic, keyword=Layers, atomic=Layers, atomic path=game.types.board.RegionTypeStatic.Layers
gd~~ Diagonals name=Diagonals type=Constant (game.types.board.RegionTypeStatic.Diagonals) => <regionTypeStatic>, pack=game.types.board, label=Diagonals, cls=game.types.board.RegionTypeStatic, keyword=Diagonals, atomic=Diagonals, atomic path=game.types.board.RegionTypeStatic.Diagonals
gd~~ SubGrids name=SubGrids type=Constant (game.types.board.RegionTypeStatic.SubGrids) => <regionTypeStatic>, pack=game.types.board, label=SubGrids, cls=game.types.board.RegionTypeStatic, keyword=SubGrids, atomic=SubGrids, atomic path=game.types.board.RegionTypeStatic.SubGrids
gd~~ Regions name=Regions type=Constant (game.types.board.RegionTypeStatic.Regions) => <regionTypeStatic>, pack=game.types.board, label=Regions, cls=game.types.board.RegionTypeStatic, keyword=Regions, atomic=Regions, atomic path=game.types.board.RegionTypeStatic.Regions
gd~~ Vertices name=Vertices type=Constant (game.types.board.RegionTypeStatic.Vertices) => <regionTypeStatic>, pack=game.types.board, label=Vertices, cls=game.types.board.RegionTypeStatic, keyword=Vertices, atomic=Vertices, atomic path=game.types.board.RegionTypeStatic.Vertices
gd~~ Corners name=Corners type=Constant (game.types.board.RegionTypeStatic.Corners) => <regionTypeStatic>, pack=game.types.board, label=Corners, cls=game.types.board.RegionTypeStatic, keyword=Corners, atomic=Corners, atomic path=game.types.board.RegionTypeStatic.Corners
gd~~ Sides name=Sides type=Constant (game.types.board.RegionTypeStatic.Sides) => <regionTypeStatic>, pack=game.types.board, label=Sides, cls=game.types.board.RegionTypeStatic, keyword=Sides, atomic=Sides, atomic path=game.types.board.RegionTypeStatic.Sides
gd~~ SidesNoCorners name=SidesNoCorners type=Constant (game.types.board.RegionTypeStatic.SidesNoCorners) => <regionTypeStatic>, pack=game.types.board, label=SidesNoCorners, cls=game.types.board.RegionTypeStatic, keyword=SidesNoCorners, atomic=SidesNoCorners, atomic path=game.types.board.RegionTypeStatic.SidesNoCorners
gd~~ AllSites name=AllSites type=Constant (game.types.board.RegionTypeStatic.AllSites) => <regionTypeStatic>, pack=game.types.board, label=AllSites, cls=game.types.board.RegionTypeStatic, keyword=AllSites, atomic=AllSites, atomic path=game.types.board.RegionTypeStatic.AllSites
gd~~ Touching name=Touching type=Constant (game.types.board.RegionTypeStatic.Touching) => <regionTypeStatic>, pack=game.types.board, label=Touching, cls=game.types.board.RegionTypeStatic, keyword=Touching, atomic=Touching, atomic path=game.types.board.RegionTypeStatic.Touching
gd~~ Orthogonal name=Orthogonal type=Constant (game.types.board.RelationType.Orthogonal) => <relationType>, pack=game.types.board, label=Orthogonal, cls=game.types.board.RelationType, keyword=Orthogonal, atomic=Orthogonal, atomic path=game.types.board.RelationType.Orthogonal
gd~~ Diagonal name=Diagonal type=Constant (game.types.board.RelationType.Diagonal) => <relationType>, pack=game.types.board, label=Diagonal, cls=game.types.board.RelationType, keyword=Diagonal, atomic=Diagonal, atomic path=game.types.board.RelationType.Diagonal
gd~~ OffDiagonal name=OffDiagonal type=Constant (game.types.board.RelationType.OffDiagonal) => <relationType>, pack=game.types.board, label=OffDiagonal, cls=game.types.board.RelationType, keyword=OffDiagonal, atomic=OffDiagonal, atomic path=game.types.board.RelationType.OffDiagonal
gd~~ Adjacent name=Adjacent type=Constant (game.types.board.RelationType.Adjacent) => <relationType>, pack=game.types.board, label=Adjacent, cls=game.types.board.RelationType, keyword=Adjacent, atomic=Adjacent, atomic path=game.types.board.RelationType.Adjacent
gd~~ All name=All type=Constant (game.types.board.RelationType.All) => <relationType>, pack=game.types.board, label=All, cls=game.types.board.RelationType, keyword=All, atomic=All, atomic path=game.types.board.RelationType.All
gd~~ NoShape name=NoShape type=Constant (game.types.board.ShapeType.NoShape) => <shapeType>, pack=game.types.board, label=NoShape, cls=game.types.board.ShapeType, keyword=NoShape, atomic=NoShape, atomic path=game.types.board.ShapeType.NoShape
gd~~ Custom name=Custom type=Constant (game.types.board.ShapeType.Custom) => <shapeType>, pack=game.types.board, label=Custom, cls=game.types.board.ShapeType, keyword=Custom, atomic=Custom, atomic path=game.types.board.ShapeType.Custom
gd~~ Square name=Square type=Constant (game.types.board.ShapeType.Square) => <shapeType>, pack=game.types.board, label=Square, cls=game.types.board.ShapeType, keyword=Square, atomic=Square, atomic path=game.types.board.ShapeType.Square
gd~~ Rectangle name=Rectangle type=Constant (game.types.board.ShapeType.Rectangle) => <shapeType>, pack=game.types.board, label=Rectangle, cls=game.types.board.ShapeType, keyword=Rectangle, atomic=Rectangle, atomic path=game.types.board.ShapeType.Rectangle
gd~~ Triangle name=Triangle type=Constant (game.types.board.ShapeType.Triangle) => <shapeType>, pack=game.types.board, label=Triangle, cls=game.types.board.ShapeType, keyword=Triangle, atomic=Triangle, atomic path=game.types.board.ShapeType.Triangle
gd~~ Hexagon name=Hexagon type=Constant (game.types.board.ShapeType.Hexagon) => <shapeType>, pack=game.types.board, label=Hexagon, cls=game.types.board.ShapeType, keyword=Hexagon, atomic=Hexagon, atomic path=game.types.board.ShapeType.Hexagon
gd~~ Cross name=Cross type=Constant (game.types.board.ShapeType.Cross) => <shapeType>, pack=game.types.board, label=Cross, cls=game.types.board.ShapeType, keyword=Cross, atomic=Cross, atomic path=game.types.board.ShapeType.Cross
gd~~ Diamond name=Diamond type=Constant (game.types.board.ShapeType.Diamond) => <shapeType>, pack=game.types.board, label=Diamond, cls=game.types.board.ShapeType, keyword=Diamond, atomic=Diamond, atomic path=game.types.board.ShapeType.Diamond
gd~~ Prism name=Prism type=Constant (game.types.board.ShapeType.Prism) => <shapeType>, pack=game.types.board, label=Prism, cls=game.types.board.ShapeType, keyword=Prism, atomic=Prism, atomic path=game.types.board.ShapeType.Prism
gd~~ Quadrilateral name=Quadrilateral type=Constant (game.types.board.ShapeType.Quadrilateral) => <shapeType>, pack=game.types.board, label=Quadrilateral, cls=game.types.board.ShapeType, keyword=Quadrilateral, atomic=Quadrilateral, atomic path=game.types.board.ShapeType.Quadrilateral
gd~~ Rhombus name=Rhombus type=Constant (game.types.board.ShapeType.Rhombus) => <shapeType>, pack=game.types.board, label=Rhombus, cls=game.types.board.ShapeType, keyword=Rhombus, atomic=Rhombus, atomic path=game.types.board.ShapeType.Rhombus
gd~~ Wheel name=Wheel type=Constant (game.types.board.ShapeType.Wheel) => <shapeType>, pack=game.types.board, label=Wheel, cls=game.types.board.ShapeType, keyword=Wheel, atomic=Wheel, atomic path=game.types.board.ShapeType.Wheel
gd~~ Circle name=Circle type=Constant (game.types.board.ShapeType.Circle) => <shapeType>, pack=game.types.board, label=Circle, cls=game.types.board.ShapeType, keyword=Circle, atomic=Circle, atomic path=game.types.board.ShapeType.Circle
gd~~ Spiral name=Spiral type=Constant (game.types.board.ShapeType.Spiral) => <shapeType>, pack=game.types.board, label=Spiral, cls=game.types.board.ShapeType, keyword=Spiral, atomic=Spiral, atomic path=game.types.board.ShapeType.Spiral
gd~~ Wedge name=Wedge type=Constant (game.types.board.ShapeType.Wedge) => <shapeType>, pack=game.types.board, label=Wedge, cls=game.types.board.ShapeType, keyword=Wedge, atomic=Wedge, atomic path=game.types.board.ShapeType.Wedge
gd~~ Star name=Star type=Constant (game.types.board.ShapeType.Star) => <shapeType>, pack=game.types.board, label=Star, cls=game.types.board.ShapeType, keyword=Star, atomic=Star, atomic path=game.types.board.ShapeType.Star
gd~~ Limping name=Limping type=Constant (game.types.board.ShapeType.Limping) => <shapeType>, pack=game.types.board, label=Limping, cls=game.types.board.ShapeType, keyword=Limping, atomic=Limping, atomic path=game.types.board.ShapeType.Limping
gd~~ Regular name=Regular type=Constant (game.types.board.ShapeType.Regular) => <shapeType>, pack=game.types.board, label=Regular, cls=game.types.board.ShapeType, keyword=Regular, atomic=Regular, atomic path=game.types.board.ShapeType.Regular
gd~~ Polygon name=Polygon type=Constant (game.types.board.ShapeType.Polygon) => <shapeType>, pack=game.types.board, label=Polygon, cls=game.types.board.ShapeType, keyword=Polygon, atomic=Polygon, atomic path=game.types.board.ShapeType.Polygon
gd~~ Vertex name=Vertex type=Constant (game.types.board.SiteType.Vertex) => <siteType>, pack=game.types.board, label=Vertex, cls=game.types.board.SiteType, keyword=Vertex, atomic=Vertex, atomic path=game.types.board.SiteType.Vertex
gd~~ Edge name=Edge type=Constant (game.types.board.SiteType.Edge) => <siteType>, pack=game.types.board, label=Edge, cls=game.types.board.SiteType, keyword=Edge, atomic=Edge, atomic path=game.types.board.SiteType.Edge
gd~~ Cell name=Cell type=Constant (game.types.board.SiteType.Cell) => <siteType>, pack=game.types.board, label=Cell, cls=game.types.board.SiteType, keyword=Cell, atomic=Cell, atomic path=game.types.board.SiteType.Cell
gd~~ F name=F type=Constant (game.types.board.StepType.F) => <stepType>, pack=game.types.board, label=F, cls=game.types.board.StepType, keyword=F, atomic=F, atomic path=game.types.board.StepType.F
gd~~ L name=L type=Constant (game.types.board.StepType.L) => <stepType>, pack=game.types.board, label=L, cls=game.types.board.StepType, keyword=L, atomic=L, atomic path=game.types.board.StepType.L
gd~~ R name=R type=Constant (game.types.board.StepType.R) => <stepType>, pack=game.types.board, label=R, cls=game.types.board.StepType, keyword=R, atomic=R, atomic path=game.types.board.StepType.R
gd~~ None name=None type=Constant (game.types.board.StoreType.None) => <storeType>, pack=game.types.board, label=None, cls=game.types.board.StoreType, keyword=None, atomic=None, atomic path=game.types.board.StoreType.None
gd~~ Outer name=Outer type=Constant (game.types.board.StoreType.Outer) => <storeType>, pack=game.types.board, label=Outer, cls=game.types.board.StoreType, keyword=Outer, atomic=Outer, atomic path=game.types.board.StoreType.Outer
gd~~ Inner name=Inner type=Constant (game.types.board.StoreType.Inner) => <storeType>, pack=game.types.board, label=Inner, cls=game.types.board.StoreType, keyword=Inner, atomic=Inner, atomic path=game.types.board.StoreType.Inner
gd~~ Square name=Square type=Constant (game.types.board.TilingBoardlessType.Square) => <tilingBoardlessType>, pack=game.types.board, label=Square, cls=game.types.board.TilingBoardlessType, keyword=Square, atomic=Square, atomic path=game.types.board.TilingBoardlessType.Square
gd~~ Triangular name=Triangular type=Constant (game.types.board.TilingBoardlessType.Triangular) => <tilingBoardlessType>, pack=game.types.board, label=Triangular, cls=game.types.board.TilingBoardlessType, keyword=Triangular, atomic=Triangular, atomic path=game.types.board.TilingBoardlessType.Triangular
gd~~ Hexagonal name=Hexagonal type=Constant (game.types.board.TilingBoardlessType.Hexagonal) => <tilingBoardlessType>, pack=game.types.board, label=Hexagonal, cls=game.types.board.TilingBoardlessType, keyword=Hexagonal, atomic=Hexagonal, atomic path=game.types.board.TilingBoardlessType.Hexagonal
~~~~ Off name=Off type=Constant (game.types.board.TrackStepType.Off) => <trackStepType>, pack=game.types.board, label=Off, cls=game.types.board.TrackStepType, keyword=Off, atomic=Off, atomic path=game.types.board.TrackStepType.Off
~~~~ End name=End type=Constant (game.types.board.TrackStepType.End) => <trackStepType>, pack=game.types.board, label=End, cls=game.types.board.TrackStepType, keyword=End, atomic=End, atomic path=game.types.board.TrackStepType.End
~~~~ Repeat name=Repeat type=Constant (game.types.board.TrackStepType.Repeat) => <trackStepType>, pack=game.types.board, label=Repeat, cls=game.types.board.TrackStepType, keyword=Repeat, atomic=Repeat, atomic path=game.types.board.TrackStepType.Repeat
gd~~ Track name=Track type=Constant (game.types.board.TrackType.Track) => <trackType>, pack=game.types.board, label=Track, cls=game.types.board.TrackType, keyword=Track, atomic=Track, atomic path=game.types.board.TrackType.Track
gd~~ Joker name=Joker type=Constant (game.types.component.CardType.Joker) => <cardType>, pack=game.types.component, label=Joker, cls=game.types.component.CardType, keyword=Joker, atomic=Joker, atomic path=game.types.component.CardType.Joker
gd~~ Ace name=Ace type=Constant (game.types.component.CardType.Ace) => <cardType>, pack=game.types.component, label=Ace, cls=game.types.component.CardType, keyword=Ace, atomic=Ace, atomic path=game.types.component.CardType.Ace
gd~~ Two name=Two type=Constant (game.types.component.CardType.Two) => <cardType>, pack=game.types.component, label=Two, cls=game.types.component.CardType, keyword=Two, atomic=Two, atomic path=game.types.component.CardType.Two
gd~~ Three name=Three type=Constant (game.types.component.CardType.Three) => <cardType>, pack=game.types.component, label=Three, cls=game.types.component.CardType, keyword=Three, atomic=Three, atomic path=game.types.component.CardType.Three
gd~~ Four name=Four type=Constant (game.types.component.CardType.Four) => <cardType>, pack=game.types.component, label=Four, cls=game.types.component.CardType, keyword=Four, atomic=Four, atomic path=game.types.component.CardType.Four
gd~~ Five name=Five type=Constant (game.types.component.CardType.Five) => <cardType>, pack=game.types.component, label=Five, cls=game.types.component.CardType, keyword=Five, atomic=Five, atomic path=game.types.component.CardType.Five
gd~~ Six name=Six type=Constant (game.types.component.CardType.Six) => <cardType>, pack=game.types.component, label=Six, cls=game.types.component.CardType, keyword=Six, atomic=Six, atomic path=game.types.component.CardType.Six
gd~~ Seven name=Seven type=Constant (game.types.component.CardType.Seven) => <cardType>, pack=game.types.component, label=Seven, cls=game.types.component.CardType, keyword=Seven, atomic=Seven, atomic path=game.types.component.CardType.Seven
gd~~ Eight name=Eight type=Constant (game.types.component.CardType.Eight) => <cardType>, pack=game.types.component, label=Eight, cls=game.types.component.CardType, keyword=Eight, atomic=Eight, atomic path=game.types.component.CardType.Eight
gd~~ Nine name=Nine type=Constant (game.types.component.CardType.Nine) => <cardType>, pack=game.types.component, label=Nine, cls=game.types.component.CardType, keyword=Nine, atomic=Nine, atomic path=game.types.component.CardType.Nine
gd~~ Ten name=Ten type=Constant (game.types.component.CardType.Ten) => <cardType>, pack=game.types.component, label=Ten, cls=game.types.component.CardType, keyword=Ten, atomic=Ten, atomic path=game.types.component.CardType.Ten
gd~~ Jack name=Jack type=Constant (game.types.component.CardType.Jack) => <cardType>, pack=game.types.component, label=Jack, cls=game.types.component.CardType, keyword=Jack, atomic=Jack, atomic path=game.types.component.CardType.Jack
gd~~ Queen name=Queen type=Constant (game.types.component.CardType.Queen) => <cardType>, pack=game.types.component, label=Queen, cls=game.types.component.CardType, keyword=Queen, atomic=Queen, atomic path=game.types.component.CardType.Queen
gd~~ King name=King type=Constant (game.types.component.CardType.King) => <cardType>, pack=game.types.component, label=King, cls=game.types.component.CardType, keyword=King, atomic=King, atomic path=game.types.component.CardType.King
gd~~ Dominoes name=Dominoes type=Constant (game.types.component.DealableType.Dominoes) => <dealableType>, pack=game.types.component, label=Dominoes, cls=game.types.component.DealableType, keyword=Dominoes, atomic=Dominoes, atomic path=game.types.component.DealableType.Dominoes
gd~~ Cards name=Cards type=Constant (game.types.component.DealableType.Cards) => <dealableType>, pack=game.types.component, label=Cards, cls=game.types.component.DealableType, keyword=Cards, atomic=Cards, atomic path=game.types.component.DealableType.Cards
~~~~ Clubs name=Clubs type=Constant (game.types.component.SuitType.Clubs) => <suitType>, pack=game.types.component, label=Clubs, cls=game.types.component.SuitType, keyword=Clubs, atomic=Clubs, atomic path=game.types.component.SuitType.Clubs
~~~~ Spades name=Spades type=Constant (game.types.component.SuitType.Spades) => <suitType>, pack=game.types.component, label=Spades, cls=game.types.component.SuitType, keyword=Spades, atomic=Spades, atomic path=game.types.component.SuitType.Spades
~~~~ Diamonds name=Diamonds type=Constant (game.types.component.SuitType.Diamonds) => <suitType>, pack=game.types.component, label=Diamonds, cls=game.types.component.SuitType, keyword=Diamonds, atomic=Diamonds, atomic path=game.types.component.SuitType.Diamonds
~~~~ Hearts name=Hearts type=Constant (game.types.component.SuitType.Hearts) => <suitType>, pack=game.types.component, label=Hearts, cls=game.types.component.SuitType, keyword=Hearts, atomic=Hearts, atomic path=game.types.component.SuitType.Hearts
gd~~ PyramidalDrop name=PyramidalDrop type=Constant (game.types.play.GravityType.PyramidalDrop) => <gravityType>, pack=game.types.play, label=PyramidalDrop, cls=game.types.play.GravityType, keyword=PyramidalDrop, atomic=PyramidalDrop, atomic path=game.types.play.GravityType.PyramidalDrop
gd~~ Alternating name=Alternating type=Constant (game.types.play.ModeType.Alternating) => <modeType>, pack=game.types.play, label=Alternating, cls=game.types.play.ModeType, keyword=Alternating, atomic=Alternating, atomic path=game.types.play.ModeType.Alternating
gd~~ Simultaneous name=Simultaneous type=Constant (game.types.play.ModeType.Simultaneous) => <modeType>, pack=game.types.play, label=Simultaneous, cls=game.types.play.ModeType, keyword=Simultaneous, atomic=Simultaneous, atomic path=game.types.play.ModeType.Simultaneous
gd~~ Simulation name=Simulation type=Constant (game.types.play.ModeType.Simulation) => <modeType>, pack=game.types.play, label=Simulation, cls=game.types.play.ModeType, keyword=Simulation, atomic=Simulation, atomic path=game.types.play.ModeType.Simulation
gd~~ Draw name=Draw type=Constant (game.types.play.PassEndType.Draw) => <passEndType>, pack=game.types.play, label=Draw, cls=game.types.play.PassEndType, keyword=Draw, atomic=Draw, atomic path=game.types.play.PassEndType.Draw
gd~~ NoEnd name=NoEnd type=Constant (game.types.play.PassEndType.NoEnd) => <passEndType>, pack=game.types.play, label=NoEnd, cls=game.types.play.PassEndType, keyword=NoEnd, atomic=NoEnd, atomic path=game.types.play.PassEndType.NoEnd
gd~~ SupportMultiple name=SupportMultiple type=Constant (game.types.play.PinType.SupportMultiple) => <pinType>, pack=game.types.play, label=SupportMultiple, cls=game.types.play.PinType, keyword=SupportMultiple, atomic=SupportMultiple, atomic path=game.types.play.PinType.SupportMultiple
gd~~ Mover name=Mover type=Constant (game.types.play.PrevType.Mover) => <prevType>, pack=game.types.play, label=Mover, cls=game.types.play.PrevType, keyword=Mover, atomic=Mover, atomic path=game.types.play.PrevType.Mover
gd~~ MoverLastTurn name=MoverLastTurn type=Constant (game.types.play.PrevType.MoverLastTurn) => <prevType>, pack=game.types.play, label=MoverLastTurn, cls=game.types.play.PrevType, keyword=MoverLastTurn, atomic=MoverLastTurn, atomic path=game.types.play.PrevType.MoverLastTurn
gd~~ SituationalInTurn name=SituationalInTurn type=Constant (game.types.play.RepetitionType.SituationalInTurn) => <repetitionType>, pack=game.types.play, label=SituationalInTurn, cls=game.types.play.RepetitionType, keyword=SituationalInTurn, atomic=SituationalInTurn, atomic path=game.types.play.RepetitionType.SituationalInTurn
gd~~ PositionalInTurn name=PositionalInTurn type=Constant (game.types.play.RepetitionType.PositionalInTurn) => <repetitionType>, pack=game.types.play, label=PositionalInTurn, cls=game.types.play.RepetitionType, keyword=PositionalInTurn, atomic=PositionalInTurn, atomic path=game.types.play.RepetitionType.PositionalInTurn
gd~~ Positional name=Positional type=Constant (game.types.play.RepetitionType.Positional) => <repetitionType>, pack=game.types.play, label=Positional, cls=game.types.play.RepetitionType, keyword=Positional, atomic=Positional, atomic path=game.types.play.RepetitionType.Positional
gd~~ Situational name=Situational type=Constant (game.types.play.RepetitionType.Situational) => <repetitionType>, pack=game.types.play, label=Situational, cls=game.types.play.RepetitionType, keyword=Situational, atomic=Situational, atomic path=game.types.play.RepetitionType.Situational
gd~~ Win name=Win type=Constant (game.types.play.ResultType.Win) => <resultType>, pack=game.types.play, label=Win, cls=game.types.play.ResultType, keyword=Win, atomic=Win, atomic path=game.types.play.ResultType.Win
gd~~ Loss name=Loss type=Constant (game.types.play.ResultType.Loss) => <resultType>, pack=game.types.play, label=Loss, cls=game.types.play.ResultType, keyword=Loss, atomic=Loss, atomic path=game.types.play.ResultType.Loss
gd~~ Draw name=Draw type=Constant (game.types.play.ResultType.Draw) => <resultType>, pack=game.types.play, label=Draw, cls=game.types.play.ResultType, keyword=Draw, atomic=Draw, atomic path=game.types.play.ResultType.Draw
gd~~ Tie name=Tie type=Constant (game.types.play.ResultType.Tie) => <resultType>, pack=game.types.play, label=Tie, cls=game.types.play.ResultType, keyword=Tie, atomic=Tie, atomic path=game.types.play.ResultType.Tie
gd~~ Abandon name=Abandon type=Constant (game.types.play.ResultType.Abandon) => <resultType>, pack=game.types.play, label=Abandon, cls=game.types.play.ResultType, keyword=Abandon, atomic=Abandon, atomic path=game.types.play.ResultType.Abandon
gd~~ Crash name=Crash type=Constant (game.types.play.ResultType.Crash) => <resultType>, pack=game.types.play, label=Crash, cls=game.types.play.ResultType, keyword=Crash, atomic=Crash, atomic path=game.types.play.ResultType.Crash
gd~~ Neutral name=Neutral type=Constant (game.types.play.RoleType.Neutral) => <roleType>, pack=game.types.play, label=Neutral, cls=game.types.play.RoleType, keyword=Neutral, atomic=Neutral, atomic path=game.types.play.RoleType.Neutral
gd~~ P1 name=P1 type=Constant (game.types.play.RoleType.P1) => <roleType>, pack=game.types.play, label=P1, cls=game.types.play.RoleType, keyword=P1, atomic=P1, atomic path=game.types.play.RoleType.P1
gd~~ P2 name=P2 type=Constant (game.types.play.RoleType.P2) => <roleType>, pack=game.types.play, label=P2, cls=game.types.play.RoleType, keyword=P2, atomic=P2, atomic path=game.types.play.RoleType.P2
gd~~ P3 name=P3 type=Constant (game.types.play.RoleType.P3) => <roleType>, pack=game.types.play, label=P3, cls=game.types.play.RoleType, keyword=P3, atomic=P3, atomic path=game.types.play.RoleType.P3
gd~~ P4 name=P4 type=Constant (game.types.play.RoleType.P4) => <roleType>, pack=game.types.play, label=P4, cls=game.types.play.RoleType, keyword=P4, atomic=P4, atomic path=game.types.play.RoleType.P4
gd~~ P5 name=P5 type=Constant (game.types.play.RoleType.P5) => <roleType>, pack=game.types.play, label=P5, cls=game.types.play.RoleType, keyword=P5, atomic=P5, atomic path=game.types.play.RoleType.P5
gd~~ P6 name=P6 type=Constant (game.types.play.RoleType.P6) => <roleType>, pack=game.types.play, label=P6, cls=game.types.play.RoleType, keyword=P6, atomic=P6, atomic path=game.types.play.RoleType.P6
gd~~ P7 name=P7 type=Constant (game.types.play.RoleType.P7) => <roleType>, pack=game.types.play, label=P7, cls=game.types.play.RoleType, keyword=P7, atomic=P7, atomic path=game.types.play.RoleType.P7
gd~~ P8 name=P8 type=Constant (game.types.play.RoleType.P8) => <roleType>, pack=game.types.play, label=P8, cls=game.types.play.RoleType, keyword=P8, atomic=P8, atomic path=game.types.play.RoleType.P8
gd~~ P9 name=P9 type=Constant (game.types.play.RoleType.P9) => <roleType>, pack=game.types.play, label=P9, cls=game.types.play.RoleType, keyword=P9, atomic=P9, atomic path=game.types.play.RoleType.P9
gd~~ P10 name=P10 type=Constant (game.types.play.RoleType.P10) => <roleType>, pack=game.types.play, label=P10, cls=game.types.play.RoleType, keyword=P10, atomic=P10, atomic path=game.types.play.RoleType.P10
gd~~ P11 name=P11 type=Constant (game.types.play.RoleType.P11) => <roleType>, pack=game.types.play, label=P11, cls=game.types.play.RoleType, keyword=P11, atomic=P11, atomic path=game.types.play.RoleType.P11
gd~~ P12 name=P12 type=Constant (game.types.play.RoleType.P12) => <roleType>, pack=game.types.play, label=P12, cls=game.types.play.RoleType, keyword=P12, atomic=P12, atomic path=game.types.play.RoleType.P12
gd~~ P13 name=P13 type=Constant (game.types.play.RoleType.P13) => <roleType>, pack=game.types.play, label=P13, cls=game.types.play.RoleType, keyword=P13, atomic=P13, atomic path=game.types.play.RoleType.P13
gd~~ P14 name=P14 type=Constant (game.types.play.RoleType.P14) => <roleType>, pack=game.types.play, label=P14, cls=game.types.play.RoleType, keyword=P14, atomic=P14, atomic path=game.types.play.RoleType.P14
gd~~ P15 name=P15 type=Constant (game.types.play.RoleType.P15) => <roleType>, pack=game.types.play, label=P15, cls=game.types.play.RoleType, keyword=P15, atomic=P15, atomic path=game.types.play.RoleType.P15
gd~~ P16 name=P16 type=Constant (game.types.play.RoleType.P16) => <roleType>, pack=game.types.play, label=P16, cls=game.types.play.RoleType, keyword=P16, atomic=P16, atomic path=game.types.play.RoleType.P16
gd~~ Team1 name=Team1 type=Constant (game.types.play.RoleType.Team1) => <roleType>, pack=game.types.play, label=Team1, cls=game.types.play.RoleType, keyword=Team1, atomic=Team1, atomic path=game.types.play.RoleType.Team1
gd~~ Team2 name=Team2 type=Constant (game.types.play.RoleType.Team2) => <roleType>, pack=game.types.play, label=Team2, cls=game.types.play.RoleType, keyword=Team2, atomic=Team2, atomic path=game.types.play.RoleType.Team2
gd~~ Team3 name=Team3 type=Constant (game.types.play.RoleType.Team3) => <roleType>, pack=game.types.play, label=Team3, cls=game.types.play.RoleType, keyword=Team3, atomic=Team3, atomic path=game.types.play.RoleType.Team3
gd~~ Team4 name=Team4 type=Constant (game.types.play.RoleType.Team4) => <roleType>, pack=game.types.play, label=Team4, cls=game.types.play.RoleType, keyword=Team4, atomic=Team4, atomic path=game.types.play.RoleType.Team4
gd~~ Team5 name=Team5 type=Constant (game.types.play.RoleType.Team5) => <roleType>, pack=game.types.play, label=Team5, cls=game.types.play.RoleType, keyword=Team5, atomic=Team5, atomic path=game.types.play.RoleType.Team5
gd~~ Team6 name=Team6 type=Constant (game.types.play.RoleType.Team6) => <roleType>, pack=game.types.play, label=Team6, cls=game.types.play.RoleType, keyword=Team6, atomic=Team6, atomic path=game.types.play.RoleType.Team6
gd~~ Team7 name=Team7 type=Constant (game.types.play.RoleType.Team7) => <roleType>, pack=game.types.play, label=Team7, cls=game.types.play.RoleType, keyword=Team7, atomic=Team7, atomic path=game.types.play.RoleType.Team7
gd~~ Team8 name=Team8 type=Constant (game.types.play.RoleType.Team8) => <roleType>, pack=game.types.play, label=Team8, cls=game.types.play.RoleType, keyword=Team8, atomic=Team8, atomic path=game.types.play.RoleType.Team8
gd~~ Team9 name=Team9 type=Constant (game.types.play.RoleType.Team9) => <roleType>, pack=game.types.play, label=Team9, cls=game.types.play.RoleType, keyword=Team9, atomic=Team9, atomic path=game.types.play.RoleType.Team9
gd~~ Team10 name=Team10 type=Constant (game.types.play.RoleType.Team10) => <roleType>, pack=game.types.play, label=Team10, cls=game.types.play.RoleType, keyword=Team10, atomic=Team10, atomic path=game.types.play.RoleType.Team10
gd~~ Team11 name=Team11 type=Constant (game.types.play.RoleType.Team11) => <roleType>, pack=game.types.play, label=Team11, cls=game.types.play.RoleType, keyword=Team11, atomic=Team11, atomic path=game.types.play.RoleType.Team11
gd~~ Team12 name=Team12 type=Constant (game.types.play.RoleType.Team12) => <roleType>, pack=game.types.play, label=Team12, cls=game.types.play.RoleType, keyword=Team12, atomic=Team12, atomic path=game.types.play.RoleType.Team12
gd~~ Team13 name=Team13 type=Constant (game.types.play.RoleType.Team13) => <roleType>, pack=game.types.play, label=Team13, cls=game.types.play.RoleType, keyword=Team13, atomic=Team13, atomic path=game.types.play.RoleType.Team13
gd~~ Team14 name=Team14 type=Constant (game.types.play.RoleType.Team14) => <roleType>, pack=game.types.play, label=Team14, cls=game.types.play.RoleType, keyword=Team14, atomic=Team14, atomic path=game.types.play.RoleType.Team14
gd~~ Team15 name=Team15 type=Constant (game.types.play.RoleType.Team15) => <roleType>, pack=game.types.play, label=Team15, cls=game.types.play.RoleType, keyword=Team15, atomic=Team15, atomic path=game.types.play.RoleType.Team15
gd~~ Team16 name=Team16 type=Constant (game.types.play.RoleType.Team16) => <roleType>, pack=game.types.play, label=Team16, cls=game.types.play.RoleType, keyword=Team16, atomic=Team16, atomic path=game.types.play.RoleType.Team16
gd~~ TeamMover name=TeamMover type=Constant (game.types.play.RoleType.TeamMover) => <roleType>, pack=game.types.play, label=TeamMover, cls=game.types.play.RoleType, keyword=TeamMover, atomic=TeamMover, atomic path=game.types.play.RoleType.TeamMover
gd~~ Each name=Each type=Constant (game.types.play.RoleType.Each) => <roleType>, pack=game.types.play, label=Each, cls=game.types.play.RoleType, keyword=Each, atomic=Each, atomic path=game.types.play.RoleType.Each
gd~~ Shared name=Shared type=Constant (game.types.play.RoleType.Shared) => <roleType>, pack=game.types.play, label=Shared, cls=game.types.play.RoleType, keyword=Shared, atomic=Shared, atomic path=game.types.play.RoleType.Shared
gd~~ All name=All type=Constant (game.types.play.RoleType.All) => <roleType>, pack=game.types.play, label=All, cls=game.types.play.RoleType, keyword=All, atomic=All, atomic path=game.types.play.RoleType.All
gd~~ Mover name=Mover type=Constant (game.types.play.RoleType.Mover) => <roleType>, pack=game.types.play, label=Mover, cls=game.types.play.RoleType, keyword=Mover, atomic=Mover, atomic path=game.types.play.RoleType.Mover
gd~~ Next name=Next type=Constant (game.types.play.RoleType.Next) => <roleType>, pack=game.types.play, label=Next, cls=game.types.play.RoleType, keyword=Next, atomic=Next, atomic path=game.types.play.RoleType.Next
gd~~ Prev name=Prev type=Constant (game.types.play.RoleType.Prev) => <roleType>, pack=game.types.play, label=Prev, cls=game.types.play.RoleType, keyword=Prev, atomic=Prev, atomic path=game.types.play.RoleType.Prev
gd~~ NonMover name=NonMover type=Constant (game.types.play.RoleType.NonMover) => <roleType>, pack=game.types.play, label=NonMover, cls=game.types.play.RoleType, keyword=NonMover, atomic=NonMover, atomic path=game.types.play.RoleType.NonMover
gd~~ Enemy name=Enemy type=Constant (game.types.play.RoleType.Enemy) => <roleType>, pack=game.types.play, label=Enemy, cls=game.types.play.RoleType, keyword=Enemy, atomic=Enemy, atomic path=game.types.play.RoleType.Enemy
gd~~ Friend name=Friend type=Constant (game.types.play.RoleType.Friend) => <roleType>, pack=game.types.play, label=Friend, cls=game.types.play.RoleType, keyword=Friend, atomic=Friend, atomic path=game.types.play.RoleType.Friend
gd~~ Ally name=Ally type=Constant (game.types.play.RoleType.Ally) => <roleType>, pack=game.types.play, label=Ally, cls=game.types.play.RoleType, keyword=Ally, atomic=Ally, atomic path=game.types.play.RoleType.Ally
gd~~ Player name=Player type=Constant (game.types.play.RoleType.Player) => <roleType>, pack=game.types.play, label=Player, cls=game.types.play.RoleType, keyword=Player, atomic=Player, atomic path=game.types.play.RoleType.Player
gd~~ StartOfTurn name=StartOfTurn type=Constant (game.types.play.WhenType.StartOfTurn) => <whenType>, pack=game.types.play, label=StartOfTurn, cls=game.types.play.WhenType, keyword=StartOfTurn, atomic=StartOfTurn, atomic path=game.types.play.WhenType.StartOfTurn
gd~~ EndOfTurn name=EndOfTurn type=Constant (game.types.play.WhenType.EndOfTurn) => <whenType>, pack=game.types.play, label=EndOfTurn, cls=game.types.play.WhenType, keyword=EndOfTurn, atomic=EndOfTurn, atomic path=game.types.play.WhenType.EndOfTurn
gd~~ All name=All type=Constant (game.util.directions.AbsoluteDirection.All) => <absoluteDirection>, pack=game.util.directions, label=All, cls=game.util.directions.AbsoluteDirection, keyword=All, atomic=All, atomic path=game.util.directions.AbsoluteDirection.All
gd~~ Angled name=Angled type=Constant (game.util.directions.AbsoluteDirection.Angled) => <absoluteDirection>, pack=game.util.directions, label=Angled, cls=game.util.directions.AbsoluteDirection, keyword=Angled, atomic=Angled, atomic path=game.util.directions.AbsoluteDirection.Angled
gd~~ Adjacent name=Adjacent type=Constant (game.util.directions.AbsoluteDirection.Adjacent) => <absoluteDirection>, pack=game.util.directions, label=Adjacent, cls=game.util.directions.AbsoluteDirection, keyword=Adjacent, atomic=Adjacent, atomic path=game.util.directions.AbsoluteDirection.Adjacent
gd~~ Axial name=Axial type=Constant (game.util.directions.AbsoluteDirection.Axial) => <absoluteDirection>, pack=game.util.directions, label=Axial, cls=game.util.directions.AbsoluteDirection, keyword=Axial, atomic=Axial, atomic path=game.util.directions.AbsoluteDirection.Axial
gd~~ Orthogonal name=Orthogonal type=Constant (game.util.directions.AbsoluteDirection.Orthogonal) => <absoluteDirection>, pack=game.util.directions, label=Orthogonal, cls=game.util.directions.AbsoluteDirection, keyword=Orthogonal, atomic=Orthogonal, atomic path=game.util.directions.AbsoluteDirection.Orthogonal
gd~~ Diagonal name=Diagonal type=Constant (game.util.directions.AbsoluteDirection.Diagonal) => <absoluteDirection>, pack=game.util.directions, label=Diagonal, cls=game.util.directions.AbsoluteDirection, keyword=Diagonal, atomic=Diagonal, atomic path=game.util.directions.AbsoluteDirection.Diagonal
gd~~ OffDiagonal name=OffDiagonal type=Constant (game.util.directions.AbsoluteDirection.OffDiagonal) => <absoluteDirection>, pack=game.util.directions, label=OffDiagonal, cls=game.util.directions.AbsoluteDirection, keyword=OffDiagonal, atomic=OffDiagonal, atomic path=game.util.directions.AbsoluteDirection.OffDiagonal
gd~~ SameLayer name=SameLayer type=Constant (game.util.directions.AbsoluteDirection.SameLayer) => <absoluteDirection>, pack=game.util.directions, label=SameLayer, cls=game.util.directions.AbsoluteDirection, keyword=SameLayer, atomic=SameLayer, atomic path=game.util.directions.AbsoluteDirection.SameLayer
gd~~ Upward name=Upward type=Constant (game.util.directions.AbsoluteDirection.Upward) => <absoluteDirection>, pack=game.util.directions, label=Upward, cls=game.util.directions.AbsoluteDirection, keyword=Upward, atomic=Upward, atomic path=game.util.directions.AbsoluteDirection.Upward
gd~~ Downward name=Downward type=Constant (game.util.directions.AbsoluteDirection.Downward) => <absoluteDirection>, pack=game.util.directions, label=Downward, cls=game.util.directions.AbsoluteDirection, keyword=Downward, atomic=Downward, atomic path=game.util.directions.AbsoluteDirection.Downward
gd~~ Rotational name=Rotational type=Constant (game.util.directions.AbsoluteDirection.Rotational) => <absoluteDirection>, pack=game.util.directions, label=Rotational, cls=game.util.directions.AbsoluteDirection, keyword=Rotational, atomic=Rotational, atomic path=game.util.directions.AbsoluteDirection.Rotational
gd~~ Base name=Base type=Constant (game.util.directions.AbsoluteDirection.Base) => <absoluteDirection>, pack=game.util.directions, label=Base, cls=game.util.directions.AbsoluteDirection, keyword=Base, atomic=Base, atomic path=game.util.directions.AbsoluteDirection.Base
gd~~ Support name=Support type=Constant (game.util.directions.AbsoluteDirection.Support) => <absoluteDirection>, pack=game.util.directions, label=Support, cls=game.util.directions.AbsoluteDirection, keyword=Support, atomic=Support, atomic path=game.util.directions.AbsoluteDirection.Support
gd~~ N name=N type=Constant (game.util.directions.AbsoluteDirection.N) => <absoluteDirection>, pack=game.util.directions, label=N, cls=game.util.directions.AbsoluteDirection, keyword=N, atomic=N, atomic path=game.util.directions.AbsoluteDirection.N
gd~~ E name=E type=Constant (game.util.directions.AbsoluteDirection.E) => <absoluteDirection>, pack=game.util.directions, label=E, cls=game.util.directions.AbsoluteDirection, keyword=E, atomic=E, atomic path=game.util.directions.AbsoluteDirection.E
gd~~ S name=S type=Constant (game.util.directions.AbsoluteDirection.S) => <absoluteDirection>, pack=game.util.directions, label=S, cls=game.util.directions.AbsoluteDirection, keyword=S, atomic=S, atomic path=game.util.directions.AbsoluteDirection.S
gd~~ W name=W type=Constant (game.util.directions.AbsoluteDirection.W) => <absoluteDirection>, pack=game.util.directions, label=W, cls=game.util.directions.AbsoluteDirection, keyword=W, atomic=W, atomic path=game.util.directions.AbsoluteDirection.W
gd~~ NE name=NE type=Constant (game.util.directions.AbsoluteDirection.NE) => <absoluteDirection>, pack=game.util.directions, label=NE, cls=game.util.directions.AbsoluteDirection, keyword=NE, atomic=NE, atomic path=game.util.directions.AbsoluteDirection.NE
gd~~ SE name=SE type=Constant (game.util.directions.AbsoluteDirection.SE) => <absoluteDirection>, pack=game.util.directions, label=SE, cls=game.util.directions.AbsoluteDirection, keyword=SE, atomic=SE, atomic path=game.util.directions.AbsoluteDirection.SE
gd~~ NW name=NW type=Constant (game.util.directions.AbsoluteDirection.NW) => <absoluteDirection>, pack=game.util.directions, label=NW, cls=game.util.directions.AbsoluteDirection, keyword=NW, atomic=NW, atomic path=game.util.directions.AbsoluteDirection.NW
gd~~ SW name=SW type=Constant (game.util.directions.AbsoluteDirection.SW) => <absoluteDirection>, pack=game.util.directions, label=SW, cls=game.util.directions.AbsoluteDirection, keyword=SW, atomic=SW, atomic path=game.util.directions.AbsoluteDirection.SW
gd~~ NNW name=NNW type=Constant (game.util.directions.AbsoluteDirection.NNW) => <absoluteDirection>, pack=game.util.directions, label=NNW, cls=game.util.directions.AbsoluteDirection, keyword=NNW, atomic=NNW, atomic path=game.util.directions.AbsoluteDirection.NNW
gd~~ WNW name=WNW type=Constant (game.util.directions.AbsoluteDirection.WNW) => <absoluteDirection>, pack=game.util.directions, label=WNW, cls=game.util.directions.AbsoluteDirection, keyword=WNW, atomic=WNW, atomic path=game.util.directions.AbsoluteDirection.WNW
gd~~ WSW name=WSW type=Constant (game.util.directions.AbsoluteDirection.WSW) => <absoluteDirection>, pack=game.util.directions, label=WSW, cls=game.util.directions.AbsoluteDirection, keyword=WSW, atomic=WSW, atomic path=game.util.directions.AbsoluteDirection.WSW
gd~~ SSW name=SSW type=Constant (game.util.directions.AbsoluteDirection.SSW) => <absoluteDirection>, pack=game.util.directions, label=SSW, cls=game.util.directions.AbsoluteDirection, keyword=SSW, atomic=SSW, atomic path=game.util.directions.AbsoluteDirection.SSW
gd~~ SSE name=SSE type=Constant (game.util.directions.AbsoluteDirection.SSE) => <absoluteDirection>, pack=game.util.directions, label=SSE, cls=game.util.directions.AbsoluteDirection, keyword=SSE, atomic=SSE, atomic path=game.util.directions.AbsoluteDirection.SSE
gd~~ ESE name=ESE type=Constant (game.util.directions.AbsoluteDirection.ESE) => <absoluteDirection>, pack=game.util.directions, label=ESE, cls=game.util.directions.AbsoluteDirection, keyword=ESE, atomic=ESE, atomic path=game.util.directions.AbsoluteDirection.ESE
gd~~ ENE name=ENE type=Constant (game.util.directions.AbsoluteDirection.ENE) => <absoluteDirection>, pack=game.util.directions, label=ENE, cls=game.util.directions.AbsoluteDirection, keyword=ENE, atomic=ENE, atomic path=game.util.directions.AbsoluteDirection.ENE
gd~~ NNE name=NNE type=Constant (game.util.directions.AbsoluteDirection.NNE) => <absoluteDirection>, pack=game.util.directions, label=NNE, cls=game.util.directions.AbsoluteDirection, keyword=NNE, atomic=NNE, atomic path=game.util.directions.AbsoluteDirection.NNE
gd~~ CW name=CW type=Constant (game.util.directions.AbsoluteDirection.CW) => <absoluteDirection>, pack=game.util.directions, label=CW, cls=game.util.directions.AbsoluteDirection, keyword=CW, atomic=CW, atomic path=game.util.directions.AbsoluteDirection.CW
gd~~ CCW name=CCW type=Constant (game.util.directions.AbsoluteDirection.CCW) => <absoluteDirection>, pack=game.util.directions, label=CCW, cls=game.util.directions.AbsoluteDirection, keyword=CCW, atomic=CCW, atomic path=game.util.directions.AbsoluteDirection.CCW
gd~~ In name=In type=Constant (game.util.directions.AbsoluteDirection.In) => <absoluteDirection>, pack=game.util.directions, label=In, cls=game.util.directions.AbsoluteDirection, keyword=In, atomic=In, atomic path=game.util.directions.AbsoluteDirection.In
gd~~ Out name=Out type=Constant (game.util.directions.AbsoluteDirection.Out) => <absoluteDirection>, pack=game.util.directions, label=Out, cls=game.util.directions.AbsoluteDirection, keyword=Out, atomic=Out, atomic path=game.util.directions.AbsoluteDirection.Out
gd~~ U name=U type=Constant (game.util.directions.AbsoluteDirection.U) => <absoluteDirection>, pack=game.util.directions, label=U, cls=game.util.directions.AbsoluteDirection, keyword=U, atomic=U, atomic path=game.util.directions.AbsoluteDirection.U
gd~~ UN name=UN type=Constant (game.util.directions.AbsoluteDirection.UN) => <absoluteDirection>, pack=game.util.directions, label=UN, cls=game.util.directions.AbsoluteDirection, keyword=UN, atomic=UN, atomic path=game.util.directions.AbsoluteDirection.UN
gd~~ UNE name=UNE type=Constant (game.util.directions.AbsoluteDirection.UNE) => <absoluteDirection>, pack=game.util.directions, label=UNE, cls=game.util.directions.AbsoluteDirection, keyword=UNE, atomic=UNE, atomic path=game.util.directions.AbsoluteDirection.UNE
gd~~ UE name=UE type=Constant (game.util.directions.AbsoluteDirection.UE) => <absoluteDirection>, pack=game.util.directions, label=UE, cls=game.util.directions.AbsoluteDirection, keyword=UE, atomic=UE, atomic path=game.util.directions.AbsoluteDirection.UE
gd~~ USE name=USE type=Constant (game.util.directions.AbsoluteDirection.USE) => <absoluteDirection>, pack=game.util.directions, label=USE, cls=game.util.directions.AbsoluteDirection, keyword=USE, atomic=USE, atomic path=game.util.directions.AbsoluteDirection.USE
gd~~ US name=US type=Constant (game.util.directions.AbsoluteDirection.US) => <absoluteDirection>, pack=game.util.directions, label=US, cls=game.util.directions.AbsoluteDirection, keyword=US, atomic=US, atomic path=game.util.directions.AbsoluteDirection.US
gd~~ USW name=USW type=Constant (game.util.directions.AbsoluteDirection.USW) => <absoluteDirection>, pack=game.util.directions, label=USW, cls=game.util.directions.AbsoluteDirection, keyword=USW, atomic=USW, atomic path=game.util.directions.AbsoluteDirection.USW
gd~~ UW name=UW type=Constant (game.util.directions.AbsoluteDirection.UW) => <absoluteDirection>, pack=game.util.directions, label=UW, cls=game.util.directions.AbsoluteDirection, keyword=UW, atomic=UW, atomic path=game.util.directions.AbsoluteDirection.UW
gd~~ UNW name=UNW type=Constant (game.util.directions.AbsoluteDirection.UNW) => <absoluteDirection>, pack=game.util.directions, label=UNW, cls=game.util.directions.AbsoluteDirection, keyword=UNW, atomic=UNW, atomic path=game.util.directions.AbsoluteDirection.UNW
gd~~ D name=D type=Constant (game.util.directions.AbsoluteDirection.D) => <absoluteDirection>, pack=game.util.directions, label=D, cls=game.util.directions.AbsoluteDirection, keyword=D, atomic=D, atomic path=game.util.directions.AbsoluteDirection.D
gd~~ DN name=DN type=Constant (game.util.directions.AbsoluteDirection.DN) => <absoluteDirection>, pack=game.util.directions, label=DN, cls=game.util.directions.AbsoluteDirection, keyword=DN, atomic=DN, atomic path=game.util.directions.AbsoluteDirection.DN
gd~~ DNE name=DNE type=Constant (game.util.directions.AbsoluteDirection.DNE) => <absoluteDirection>, pack=game.util.directions, label=DNE, cls=game.util.directions.AbsoluteDirection, keyword=DNE, atomic=DNE, atomic path=game.util.directions.AbsoluteDirection.DNE
gd~~ DE name=DE type=Constant (game.util.directions.AbsoluteDirection.DE) => <absoluteDirection>, pack=game.util.directions, label=DE, cls=game.util.directions.AbsoluteDirection, keyword=DE, atomic=DE, atomic path=game.util.directions.AbsoluteDirection.DE
gd~~ DSE name=DSE type=Constant (game.util.directions.AbsoluteDirection.DSE) => <absoluteDirection>, pack=game.util.directions, label=DSE, cls=game.util.directions.AbsoluteDirection, keyword=DSE, atomic=DSE, atomic path=game.util.directions.AbsoluteDirection.DSE
gd~~ DS name=DS type=Constant (game.util.directions.AbsoluteDirection.DS) => <absoluteDirection>, pack=game.util.directions, label=DS, cls=game.util.directions.AbsoluteDirection, keyword=DS, atomic=DS, atomic path=game.util.directions.AbsoluteDirection.DS
gd~~ DSW name=DSW type=Constant (game.util.directions.AbsoluteDirection.DSW) => <absoluteDirection>, pack=game.util.directions, label=DSW, cls=game.util.directions.AbsoluteDirection, keyword=DSW, atomic=DSW, atomic path=game.util.directions.AbsoluteDirection.DSW
gd~~ DW name=DW type=Constant (game.util.directions.AbsoluteDirection.DW) => <absoluteDirection>, pack=game.util.directions, label=DW, cls=game.util.directions.AbsoluteDirection, keyword=DW, atomic=DW, atomic path=game.util.directions.AbsoluteDirection.DW
gd~~ DNW name=DNW type=Constant (game.util.directions.AbsoluteDirection.DNW) => <absoluteDirection>, pack=game.util.directions, label=DNW, cls=game.util.directions.AbsoluteDirection, keyword=DNW, atomic=DNW, atomic path=game.util.directions.AbsoluteDirection.DNW
gd~~ N name=N type=Constant (game.util.directions.CompassDirection.N) => <compassDirection>, pack=game.util.directions, label=N, cls=game.util.directions.CompassDirection, keyword=N, atomic=N, atomic path=game.util.directions.CompassDirection.N
gd~~ NNE name=NNE type=Constant (game.util.directions.CompassDirection.NNE) => <compassDirection>, pack=game.util.directions, label=NNE, cls=game.util.directions.CompassDirection, keyword=NNE, atomic=NNE, atomic path=game.util.directions.CompassDirection.NNE
gd~~ NE name=NE type=Constant (game.util.directions.CompassDirection.NE) => <compassDirection>, pack=game.util.directions, label=NE, cls=game.util.directions.CompassDirection, keyword=NE, atomic=NE, atomic path=game.util.directions.CompassDirection.NE
gd~~ ENE name=ENE type=Constant (game.util.directions.CompassDirection.ENE) => <compassDirection>, pack=game.util.directions, label=ENE, cls=game.util.directions.CompassDirection, keyword=ENE, atomic=ENE, atomic path=game.util.directions.CompassDirection.ENE
gd~~ E name=E type=Constant (game.util.directions.CompassDirection.E) => <compassDirection>, pack=game.util.directions, label=E, cls=game.util.directions.CompassDirection, keyword=E, atomic=E, atomic path=game.util.directions.CompassDirection.E
gd~~ ESE name=ESE type=Constant (game.util.directions.CompassDirection.ESE) => <compassDirection>, pack=game.util.directions, label=ESE, cls=game.util.directions.CompassDirection, keyword=ESE, atomic=ESE, atomic path=game.util.directions.CompassDirection.ESE
gd~~ SE name=SE type=Constant (game.util.directions.CompassDirection.SE) => <compassDirection>, pack=game.util.directions, label=SE, cls=game.util.directions.CompassDirection, keyword=SE, atomic=SE, atomic path=game.util.directions.CompassDirection.SE
gd~~ SSE name=SSE type=Constant (game.util.directions.CompassDirection.SSE) => <compassDirection>, pack=game.util.directions, label=SSE, cls=game.util.directions.CompassDirection, keyword=SSE, atomic=SSE, atomic path=game.util.directions.CompassDirection.SSE
gd~~ S name=S type=Constant (game.util.directions.CompassDirection.S) => <compassDirection>, pack=game.util.directions, label=S, cls=game.util.directions.CompassDirection, keyword=S, atomic=S, atomic path=game.util.directions.CompassDirection.S
gd~~ SSW name=SSW type=Constant (game.util.directions.CompassDirection.SSW) => <compassDirection>, pack=game.util.directions, label=SSW, cls=game.util.directions.CompassDirection, keyword=SSW, atomic=SSW, atomic path=game.util.directions.CompassDirection.SSW
gd~~ SW name=SW type=Constant (game.util.directions.CompassDirection.SW) => <compassDirection>, pack=game.util.directions, label=SW, cls=game.util.directions.CompassDirection, keyword=SW, atomic=SW, atomic path=game.util.directions.CompassDirection.SW
gd~~ WSW name=WSW type=Constant (game.util.directions.CompassDirection.WSW) => <compassDirection>, pack=game.util.directions, label=WSW, cls=game.util.directions.CompassDirection, keyword=WSW, atomic=WSW, atomic path=game.util.directions.CompassDirection.WSW
gd~~ W name=W type=Constant (game.util.directions.CompassDirection.W) => <compassDirection>, pack=game.util.directions, label=W, cls=game.util.directions.CompassDirection, keyword=W, atomic=W, atomic path=game.util.directions.CompassDirection.W
gd~~ WNW name=WNW type=Constant (game.util.directions.CompassDirection.WNW) => <compassDirection>, pack=game.util.directions, label=WNW, cls=game.util.directions.CompassDirection, keyword=WNW, atomic=WNW, atomic path=game.util.directions.CompassDirection.WNW
gd~~ NW name=NW type=Constant (game.util.directions.CompassDirection.NW) => <compassDirection>, pack=game.util.directions, label=NW, cls=game.util.directions.CompassDirection, keyword=NW, atomic=NW, atomic path=game.util.directions.CompassDirection.NW
gd~~ NNW name=NNW type=Constant (game.util.directions.CompassDirection.NNW) => <compassDirection>, pack=game.util.directions, label=NNW, cls=game.util.directions.CompassDirection, keyword=NNW, atomic=NNW, atomic path=game.util.directions.CompassDirection.NNW
~~~~ N name=N type=Constant (game.util.directions.DirectionUniqueName.N) => <directionUniqueName>, pack=game.util.directions, label=N, cls=game.util.directions.DirectionUniqueName, keyword=N, atomic=N, atomic path=game.util.directions.DirectionUniqueName.N
~~~~ NNE name=NNE type=Constant (game.util.directions.DirectionUniqueName.NNE) => <directionUniqueName>, pack=game.util.directions, label=NNE, cls=game.util.directions.DirectionUniqueName, keyword=NNE, atomic=NNE, atomic path=game.util.directions.DirectionUniqueName.NNE
~~~~ NE name=NE type=Constant (game.util.directions.DirectionUniqueName.NE) => <directionUniqueName>, pack=game.util.directions, label=NE, cls=game.util.directions.DirectionUniqueName, keyword=NE, atomic=NE, atomic path=game.util.directions.DirectionUniqueName.NE
~~~~ E name=E type=Constant (game.util.directions.DirectionUniqueName.E) => <directionUniqueName>, pack=game.util.directions, label=E, cls=game.util.directions.DirectionUniqueName, keyword=E, atomic=E, atomic path=game.util.directions.DirectionUniqueName.E
~~~~ SSE name=SSE type=Constant (game.util.directions.DirectionUniqueName.SSE) => <directionUniqueName>, pack=game.util.directions, label=SSE, cls=game.util.directions.DirectionUniqueName, keyword=SSE, atomic=SSE, atomic path=game.util.directions.DirectionUniqueName.SSE
~~~~ SE name=SE type=Constant (game.util.directions.DirectionUniqueName.SE) => <directionUniqueName>, pack=game.util.directions, label=SE, cls=game.util.directions.DirectionUniqueName, keyword=SE, atomic=SE, atomic path=game.util.directions.DirectionUniqueName.SE
~~~~ S name=S type=Constant (game.util.directions.DirectionUniqueName.S) => <directionUniqueName>, pack=game.util.directions, label=S, cls=game.util.directions.DirectionUniqueName, keyword=S, atomic=S, atomic path=game.util.directions.DirectionUniqueName.S
~~~~ SSW name=SSW type=Constant (game.util.directions.DirectionUniqueName.SSW) => <directionUniqueName>, pack=game.util.directions, label=SSW, cls=game.util.directions.DirectionUniqueName, keyword=SSW, atomic=SSW, atomic path=game.util.directions.DirectionUniqueName.SSW
~~~~ SW name=SW type=Constant (game.util.directions.DirectionUniqueName.SW) => <directionUniqueName>, pack=game.util.directions, label=SW, cls=game.util.directions.DirectionUniqueName, keyword=SW, atomic=SW, atomic path=game.util.directions.DirectionUniqueName.SW
~~~~ W name=W type=Constant (game.util.directions.DirectionUniqueName.W) => <directionUniqueName>, pack=game.util.directions, label=W, cls=game.util.directions.DirectionUniqueName, keyword=W, atomic=W, atomic path=game.util.directions.DirectionUniqueName.W
~~~~ NW name=NW type=Constant (game.util.directions.DirectionUniqueName.NW) => <directionUniqueName>, pack=game.util.directions, label=NW, cls=game.util.directions.DirectionUniqueName, keyword=NW, atomic=NW, atomic path=game.util.directions.DirectionUniqueName.NW
~~~~ NNW name=NNW type=Constant (game.util.directions.DirectionUniqueName.NNW) => <directionUniqueName>, pack=game.util.directions, label=NNW, cls=game.util.directions.DirectionUniqueName, keyword=NNW, atomic=NNW, atomic path=game.util.directions.DirectionUniqueName.NNW
~~~~ WNW name=WNW type=Constant (game.util.directions.DirectionUniqueName.WNW) => <directionUniqueName>, pack=game.util.directions, label=WNW, cls=game.util.directions.DirectionUniqueName, keyword=WNW, atomic=WNW, atomic path=game.util.directions.DirectionUniqueName.WNW
~~~~ ENE name=ENE type=Constant (game.util.directions.DirectionUniqueName.ENE) => <directionUniqueName>, pack=game.util.directions, label=ENE, cls=game.util.directions.DirectionUniqueName, keyword=ENE, atomic=ENE, atomic path=game.util.directions.DirectionUniqueName.ENE
~~~~ ESE name=ESE type=Constant (game.util.directions.DirectionUniqueName.ESE) => <directionUniqueName>, pack=game.util.directions, label=ESE, cls=game.util.directions.DirectionUniqueName, keyword=ESE, atomic=ESE, atomic path=game.util.directions.DirectionUniqueName.ESE
~~~~ WSW name=WSW type=Constant (game.util.directions.DirectionUniqueName.WSW) => <directionUniqueName>, pack=game.util.directions, label=WSW, cls=game.util.directions.DirectionUniqueName, keyword=WSW, atomic=WSW, atomic path=game.util.directions.DirectionUniqueName.WSW
~~~~ CW name=CW type=Constant (game.util.directions.DirectionUniqueName.CW) => <directionUniqueName>, pack=game.util.directions, label=CW, cls=game.util.directions.DirectionUniqueName, keyword=CW, atomic=CW, atomic path=game.util.directions.DirectionUniqueName.CW
~~~~ Out name=Out type=Constant (game.util.directions.DirectionUniqueName.Out) => <directionUniqueName>, pack=game.util.directions, label=Out, cls=game.util.directions.DirectionUniqueName, keyword=Out, atomic=Out, atomic path=game.util.directions.DirectionUniqueName.Out
~~~~ CCW name=CCW type=Constant (game.util.directions.DirectionUniqueName.CCW) => <directionUniqueName>, pack=game.util.directions, label=CCW, cls=game.util.directions.DirectionUniqueName, keyword=CCW, atomic=CCW, atomic path=game.util.directions.DirectionUniqueName.CCW
~~~~ In name=In type=Constant (game.util.directions.DirectionUniqueName.In) => <directionUniqueName>, pack=game.util.directions, label=In, cls=game.util.directions.DirectionUniqueName, keyword=In, atomic=In, atomic path=game.util.directions.DirectionUniqueName.In
~~~~ UNW name=UNW type=Constant (game.util.directions.DirectionUniqueName.UNW) => <directionUniqueName>, pack=game.util.directions, label=UNW, cls=game.util.directions.DirectionUniqueName, keyword=UNW, atomic=UNW, atomic path=game.util.directions.DirectionUniqueName.UNW
~~~~ UNE name=UNE type=Constant (game.util.directions.DirectionUniqueName.UNE) => <directionUniqueName>, pack=game.util.directions, label=UNE, cls=game.util.directions.DirectionUniqueName, keyword=UNE, atomic=UNE, atomic path=game.util.directions.DirectionUniqueName.UNE
~~~~ USE name=USE type=Constant (game.util.directions.DirectionUniqueName.USE) => <directionUniqueName>, pack=game.util.directions, label=USE, cls=game.util.directions.DirectionUniqueName, keyword=USE, atomic=USE, atomic path=game.util.directions.DirectionUniqueName.USE
~~~~ USW name=USW type=Constant (game.util.directions.DirectionUniqueName.USW) => <directionUniqueName>, pack=game.util.directions, label=USW, cls=game.util.directions.DirectionUniqueName, keyword=USW, atomic=USW, atomic path=game.util.directions.DirectionUniqueName.USW
~~~~ DNW name=DNW type=Constant (game.util.directions.DirectionUniqueName.DNW) => <directionUniqueName>, pack=game.util.directions, label=DNW, cls=game.util.directions.DirectionUniqueName, keyword=DNW, atomic=DNW, atomic path=game.util.directions.DirectionUniqueName.DNW
~~~~ DNE name=DNE type=Constant (game.util.directions.DirectionUniqueName.DNE) => <directionUniqueName>, pack=game.util.directions, label=DNE, cls=game.util.directions.DirectionUniqueName, keyword=DNE, atomic=DNE, atomic path=game.util.directions.DirectionUniqueName.DNE
~~~~ DSE name=DSE type=Constant (game.util.directions.DirectionUniqueName.DSE) => <directionUniqueName>, pack=game.util.directions, label=DSE, cls=game.util.directions.DirectionUniqueName, keyword=DSE, atomic=DSE, atomic path=game.util.directions.DirectionUniqueName.DSE
~~~~ DSW name=DSW type=Constant (game.util.directions.DirectionUniqueName.DSW) => <directionUniqueName>, pack=game.util.directions, label=DSW, cls=game.util.directions.DirectionUniqueName, keyword=DSW, atomic=DSW, atomic path=game.util.directions.DirectionUniqueName.DSW
~~~~ U name=U type=Constant (game.util.directions.DirectionUniqueName.U) => <directionUniqueName>, pack=game.util.directions, label=U, cls=game.util.directions.DirectionUniqueName, keyword=U, atomic=U, atomic path=game.util.directions.DirectionUniqueName.U
~~~~ UN name=UN type=Constant (game.util.directions.DirectionUniqueName.UN) => <directionUniqueName>, pack=game.util.directions, label=UN, cls=game.util.directions.DirectionUniqueName, keyword=UN, atomic=UN, atomic path=game.util.directions.DirectionUniqueName.UN
~~~~ UW name=UW type=Constant (game.util.directions.DirectionUniqueName.UW) => <directionUniqueName>, pack=game.util.directions, label=UW, cls=game.util.directions.DirectionUniqueName, keyword=UW, atomic=UW, atomic path=game.util.directions.DirectionUniqueName.UW
~~~~ UE name=UE type=Constant (game.util.directions.DirectionUniqueName.UE) => <directionUniqueName>, pack=game.util.directions, label=UE, cls=game.util.directions.DirectionUniqueName, keyword=UE, atomic=UE, atomic path=game.util.directions.DirectionUniqueName.UE
~~~~ US name=US type=Constant (game.util.directions.DirectionUniqueName.US) => <directionUniqueName>, pack=game.util.directions, label=US, cls=game.util.directions.DirectionUniqueName, keyword=US, atomic=US, atomic path=game.util.directions.DirectionUniqueName.US
~~~~ D name=D type=Constant (game.util.directions.DirectionUniqueName.D) => <directionUniqueName>, pack=game.util.directions, label=D, cls=game.util.directions.DirectionUniqueName, keyword=D, atomic=D, atomic path=game.util.directions.DirectionUniqueName.D
~~~~ DN name=DN type=Constant (game.util.directions.DirectionUniqueName.DN) => <directionUniqueName>, pack=game.util.directions, label=DN, cls=game.util.directions.DirectionUniqueName, keyword=DN, atomic=DN, atomic path=game.util.directions.DirectionUniqueName.DN
~~~~ DW name=DW type=Constant (game.util.directions.DirectionUniqueName.DW) => <directionUniqueName>, pack=game.util.directions, label=DW, cls=game.util.directions.DirectionUniqueName, keyword=DW, atomic=DW, atomic path=game.util.directions.DirectionUniqueName.DW
~~~~ DE name=DE type=Constant (game.util.directions.DirectionUniqueName.DE) => <directionUniqueName>, pack=game.util.directions, label=DE, cls=game.util.directions.DirectionUniqueName, keyword=DE, atomic=DE, atomic path=game.util.directions.DirectionUniqueName.DE
~~~~ DS name=DS type=Constant (game.util.directions.DirectionUniqueName.DS) => <directionUniqueName>, pack=game.util.directions, label=DS, cls=game.util.directions.DirectionUniqueName, keyword=DS, atomic=DS, atomic path=game.util.directions.DirectionUniqueName.DS
gd~~ Forward name=Forward type=Constant (game.util.directions.RelativeDirection.Forward) => <relativeDirection>, pack=game.util.directions, label=Forward, cls=game.util.directions.RelativeDirection, keyword=Forward, atomic=Forward, atomic path=game.util.directions.RelativeDirection.Forward
gd~~ Backward name=Backward type=Constant (game.util.directions.RelativeDirection.Backward) => <relativeDirection>, pack=game.util.directions, label=Backward, cls=game.util.directions.RelativeDirection, keyword=Backward, atomic=Backward, atomic path=game.util.directions.RelativeDirection.Backward
gd~~ Rightward name=Rightward type=Constant (game.util.directions.RelativeDirection.Rightward) => <relativeDirection>, pack=game.util.directions, label=Rightward, cls=game.util.directions.RelativeDirection, keyword=Rightward, atomic=Rightward, atomic path=game.util.directions.RelativeDirection.Rightward
gd~~ Leftward name=Leftward type=Constant (game.util.directions.RelativeDirection.Leftward) => <relativeDirection>, pack=game.util.directions, label=Leftward, cls=game.util.directions.RelativeDirection, keyword=Leftward, atomic=Leftward, atomic path=game.util.directions.RelativeDirection.Leftward
gd~~ Forwards name=Forwards type=Constant (game.util.directions.RelativeDirection.Forwards) => <relativeDirection>, pack=game.util.directions, label=Forwards, cls=game.util.directions.RelativeDirection, keyword=Forwards, atomic=Forwards, atomic path=game.util.directions.RelativeDirection.Forwards
gd~~ Backwards name=Backwards type=Constant (game.util.directions.RelativeDirection.Backwards) => <relativeDirection>, pack=game.util.directions, label=Backwards, cls=game.util.directions.RelativeDirection, keyword=Backwards, atomic=Backwards, atomic path=game.util.directions.RelativeDirection.Backwards
gd~~ Rightwards name=Rightwards type=Constant (game.util.directions.RelativeDirection.Rightwards) => <relativeDirection>, pack=game.util.directions, label=Rightwards, cls=game.util.directions.RelativeDirection, keyword=Rightwards, atomic=Rightwards, atomic path=game.util.directions.RelativeDirection.Rightwards
gd~~ Leftwards name=Leftwards type=Constant (game.util.directions.RelativeDirection.Leftwards) => <relativeDirection>, pack=game.util.directions, label=Leftwards, cls=game.util.directions.RelativeDirection, keyword=Leftwards, atomic=Leftwards, atomic path=game.util.directions.RelativeDirection.Leftwards
gd~~ FL name=FL type=Constant (game.util.directions.RelativeDirection.FL) => <relativeDirection>, pack=game.util.directions, label=FL, cls=game.util.directions.RelativeDirection, keyword=FL, atomic=FL, atomic path=game.util.directions.RelativeDirection.FL
gd~~ FLL name=FLL type=Constant (game.util.directions.RelativeDirection.FLL) => <relativeDirection>, pack=game.util.directions, label=FLL, cls=game.util.directions.RelativeDirection, keyword=FLL, atomic=FLL, atomic path=game.util.directions.RelativeDirection.FLL
gd~~ FLLL name=FLLL type=Constant (game.util.directions.RelativeDirection.FLLL) => <relativeDirection>, pack=game.util.directions, label=FLLL, cls=game.util.directions.RelativeDirection, keyword=FLLL, atomic=FLLL, atomic path=game.util.directions.RelativeDirection.FLLL
gd~~ BL name=BL type=Constant (game.util.directions.RelativeDirection.BL) => <relativeDirection>, pack=game.util.directions, label=BL, cls=game.util.directions.RelativeDirection, keyword=BL, atomic=BL, atomic path=game.util.directions.RelativeDirection.BL
gd~~ BLL name=BLL type=Constant (game.util.directions.RelativeDirection.BLL) => <relativeDirection>, pack=game.util.directions, label=BLL, cls=game.util.directions.RelativeDirection, keyword=BLL, atomic=BLL, atomic path=game.util.directions.RelativeDirection.BLL
gd~~ BLLL name=BLLL type=Constant (game.util.directions.RelativeDirection.BLLL) => <relativeDirection>, pack=game.util.directions, label=BLLL, cls=game.util.directions.RelativeDirection, keyword=BLLL, atomic=BLLL, atomic path=game.util.directions.RelativeDirection.BLLL
gd~~ FR name=FR type=Constant (game.util.directions.RelativeDirection.FR) => <relativeDirection>, pack=game.util.directions, label=FR, cls=game.util.directions.RelativeDirection, keyword=FR, atomic=FR, atomic path=game.util.directions.RelativeDirection.FR
gd~~ FRR name=FRR type=Constant (game.util.directions.RelativeDirection.FRR) => <relativeDirection>, pack=game.util.directions, label=FRR, cls=game.util.directions.RelativeDirection, keyword=FRR, atomic=FRR, atomic path=game.util.directions.RelativeDirection.FRR
gd~~ FRRR name=FRRR type=Constant (game.util.directions.RelativeDirection.FRRR) => <relativeDirection>, pack=game.util.directions, label=FRRR, cls=game.util.directions.RelativeDirection, keyword=FRRR, atomic=FRRR, atomic path=game.util.directions.RelativeDirection.FRRR
gd~~ BR name=BR type=Constant (game.util.directions.RelativeDirection.BR) => <relativeDirection>, pack=game.util.directions, label=BR, cls=game.util.directions.RelativeDirection, keyword=BR, atomic=BR, atomic path=game.util.directions.RelativeDirection.BR
gd~~ BRR name=BRR type=Constant (game.util.directions.RelativeDirection.BRR) => <relativeDirection>, pack=game.util.directions, label=BRR, cls=game.util.directions.RelativeDirection, keyword=BRR, atomic=BRR, atomic path=game.util.directions.RelativeDirection.BRR
gd~~ BRRR name=BRRR type=Constant (game.util.directions.RelativeDirection.BRRR) => <relativeDirection>, pack=game.util.directions, label=BRRR, cls=game.util.directions.RelativeDirection, keyword=BRRR, atomic=BRRR, atomic path=game.util.directions.RelativeDirection.BRRR
gd~~ SameDirection name=SameDirection type=Constant (game.util.directions.RelativeDirection.SameDirection) => <relativeDirection>, pack=game.util.directions, label=SameDirection, cls=game.util.directions.RelativeDirection, keyword=SameDirection, atomic=SameDirection, atomic path=game.util.directions.RelativeDirection.SameDirection
gd~~ OppositeDirection name=OppositeDirection type=Constant (game.util.directions.RelativeDirection.OppositeDirection) => <relativeDirection>, pack=game.util.directions, label=OppositeDirection, cls=game.util.directions.RelativeDirection, keyword=OppositeDirection, atomic=OppositeDirection, atomic path=game.util.directions.RelativeDirection.OppositeDirection
gd~~ Out name=Out type=Constant (game.util.directions.RotationalDirection.Out) => <rotationalDirection>, pack=game.util.directions, label=Out, cls=game.util.directions.RotationalDirection, keyword=Out, atomic=Out, atomic path=game.util.directions.RotationalDirection.Out
gd~~ CW name=CW type=Constant (game.util.directions.RotationalDirection.CW) => <rotationalDirection>, pack=game.util.directions, label=CW, cls=game.util.directions.RotationalDirection, keyword=CW, atomic=CW, atomic path=game.util.directions.RotationalDirection.CW
gd~~ In name=In type=Constant (game.util.directions.RotationalDirection.In) => <rotationalDirection>, pack=game.util.directions, label=In, cls=game.util.directions.RotationalDirection, keyword=In, atomic=In, atomic path=game.util.directions.RotationalDirection.In
gd~~ CCW name=CCW type=Constant (game.util.directions.RotationalDirection.CCW) => <rotationalDirection>, pack=game.util.directions, label=CCW, cls=game.util.directions.RotationalDirection, keyword=CCW, atomic=CCW, atomic path=game.util.directions.RotationalDirection.CCW
gd~~ D name=D type=Constant (game.util.directions.SpatialDirection.D) => <spatialDirection>, pack=game.util.directions, label=D, cls=game.util.directions.SpatialDirection, keyword=D, atomic=D, atomic path=game.util.directions.SpatialDirection.D
gd~~ DN name=DN type=Constant (game.util.directions.SpatialDirection.DN) => <spatialDirection>, pack=game.util.directions, label=DN, cls=game.util.directions.SpatialDirection, keyword=DN, atomic=DN, atomic path=game.util.directions.SpatialDirection.DN
gd~~ DNE name=DNE type=Constant (game.util.directions.SpatialDirection.DNE) => <spatialDirection>, pack=game.util.directions, label=DNE, cls=game.util.directions.SpatialDirection, keyword=DNE, atomic=DNE, atomic path=game.util.directions.SpatialDirection.DNE
gd~~ DE name=DE type=Constant (game.util.directions.SpatialDirection.DE) => <spatialDirection>, pack=game.util.directions, label=DE, cls=game.util.directions.SpatialDirection, keyword=DE, atomic=DE, atomic path=game.util.directions.SpatialDirection.DE
gd~~ DSE name=DSE type=Constant (game.util.directions.SpatialDirection.DSE) => <spatialDirection>, pack=game.util.directions, label=DSE, cls=game.util.directions.SpatialDirection, keyword=DSE, atomic=DSE, atomic path=game.util.directions.SpatialDirection.DSE
gd~~ DS name=DS type=Constant (game.util.directions.SpatialDirection.DS) => <spatialDirection>, pack=game.util.directions, label=DS, cls=game.util.directions.SpatialDirection, keyword=DS, atomic=DS, atomic path=game.util.directions.SpatialDirection.DS
gd~~ DSW name=DSW type=Constant (game.util.directions.SpatialDirection.DSW) => <spatialDirection>, pack=game.util.directions, label=DSW, cls=game.util.directions.SpatialDirection, keyword=DSW, atomic=DSW, atomic path=game.util.directions.SpatialDirection.DSW
gd~~ DW name=DW type=Constant (game.util.directions.SpatialDirection.DW) => <spatialDirection>, pack=game.util.directions, label=DW, cls=game.util.directions.SpatialDirection, keyword=DW, atomic=DW, atomic path=game.util.directions.SpatialDirection.DW
gd~~ DNW name=DNW type=Constant (game.util.directions.SpatialDirection.DNW) => <spatialDirection>, pack=game.util.directions, label=DNW, cls=game.util.directions.SpatialDirection, keyword=DNW, atomic=DNW, atomic path=game.util.directions.SpatialDirection.DNW
gd~~ U name=U type=Constant (game.util.directions.SpatialDirection.U) => <spatialDirection>, pack=game.util.directions, label=U, cls=game.util.directions.SpatialDirection, keyword=U, atomic=U, atomic path=game.util.directions.SpatialDirection.U
gd~~ UN name=UN type=Constant (game.util.directions.SpatialDirection.UN) => <spatialDirection>, pack=game.util.directions, label=UN, cls=game.util.directions.SpatialDirection, keyword=UN, atomic=UN, atomic path=game.util.directions.SpatialDirection.UN
gd~~ UNE name=UNE type=Constant (game.util.directions.SpatialDirection.UNE) => <spatialDirection>, pack=game.util.directions, label=UNE, cls=game.util.directions.SpatialDirection, keyword=UNE, atomic=UNE, atomic path=game.util.directions.SpatialDirection.UNE
gd~~ UE name=UE type=Constant (game.util.directions.SpatialDirection.UE) => <spatialDirection>, pack=game.util.directions, label=UE, cls=game.util.directions.SpatialDirection, keyword=UE, atomic=UE, atomic path=game.util.directions.SpatialDirection.UE
gd~~ USE name=USE type=Constant (game.util.directions.SpatialDirection.USE) => <spatialDirection>, pack=game.util.directions, label=USE, cls=game.util.directions.SpatialDirection, keyword=USE, atomic=USE, atomic path=game.util.directions.SpatialDirection.USE
gd~~ US name=US type=Constant (game.util.directions.SpatialDirection.US) => <spatialDirection>, pack=game.util.directions, label=US, cls=game.util.directions.SpatialDirection, keyword=US, atomic=US, atomic path=game.util.directions.SpatialDirection.US
gd~~ USW name=USW type=Constant (game.util.directions.SpatialDirection.USW) => <spatialDirection>, pack=game.util.directions, label=USW, cls=game.util.directions.SpatialDirection, keyword=USW, atomic=USW, atomic path=game.util.directions.SpatialDirection.USW
gd~~ UW name=UW type=Constant (game.util.directions.SpatialDirection.UW) => <spatialDirection>, pack=game.util.directions, label=UW, cls=game.util.directions.SpatialDirection, keyword=UW, atomic=UW, atomic path=game.util.directions.SpatialDirection.UW
gd~~ UNW name=UNW type=Constant (game.util.directions.SpatialDirection.UNW) => <spatialDirection>, pack=game.util.directions, label=UNW, cls=game.util.directions.SpatialDirection, keyword=UNW, atomic=UNW, atomic path=game.util.directions.SpatialDirection.UNW
gd~~ FromBottom name=FromBottom type=Constant (game.util.directions.StackDirection.FromBottom) => <stackDirection>, pack=game.util.directions, label=FromBottom, cls=game.util.directions.StackDirection, keyword=FromBottom, atomic=FromBottom, atomic path=game.util.directions.StackDirection.FromBottom
gd~~ FromTop name=FromTop type=Constant (game.util.directions.StackDirection.FromTop) => <stackDirection>, pack=game.util.directions, label=FromTop, cls=game.util.directions.StackDirection, keyword=FromTop, atomic=FromTop, atomic path=game.util.directions.StackDirection.FromTop
g~m~ Checkered name=Checkered type=Constant (metadata.graphics.board.BoardBooleanType.Checkered) => <boardBooleanType>, pack=metadata.graphics.board, label=Checkered, cls=metadata.graphics.board.BoardBooleanType, keyword=Checkered, atomic=Checkered, atomic path=metadata.graphics.board.BoardBooleanType.Checkered
g~m~ Colour name=Colour type=Constant (metadata.graphics.board.BoardColourType.Colour) => <boardColourType>, pack=metadata.graphics.board, label=Colour, cls=metadata.graphics.board.BoardColourType, keyword=Colour, atomic=Colour, atomic path=metadata.graphics.board.BoardColourType.Colour
g~m~ Curvature name=Curvature type=Constant (metadata.graphics.board.BoardCurvatureType.Curvature) => <boardCurvatureType>, pack=metadata.graphics.board, label=Curvature, cls=metadata.graphics.board.BoardCurvatureType, keyword=Curvature, atomic=Curvature, atomic path=metadata.graphics.board.BoardCurvatureType.Curvature
g~m~ Placement name=Placement type=Constant (metadata.graphics.board.BoardPlacementType.Placement) => <boardPlacementType>, pack=metadata.graphics.board, label=Placement, cls=metadata.graphics.board.BoardPlacementType, keyword=Placement, atomic=Placement, atomic path=metadata.graphics.board.BoardPlacementType.Placement
g~m~ StyleThickness name=StyleThickness type=Constant (metadata.graphics.board.BoardStyleThicknessType.StyleThickness) => <boardStyleThicknessType>, pack=metadata.graphics.board, label=StyleThickness, cls=metadata.graphics.board.BoardStyleThicknessType, keyword=StyleThickness, atomic=StyleThickness, atomic path=metadata.graphics.board.BoardStyleThicknessType.StyleThickness
g~m~ Style name=Style type=Constant (metadata.graphics.board.BoardStyleType.Style) => <boardStyleType>, pack=metadata.graphics.board, label=Style, cls=metadata.graphics.board.BoardStyleType, keyword=Style, atomic=Style, atomic path=metadata.graphics.board.BoardStyleType.Style
g~m~ Placement name=Placement type=Constant (metadata.graphics.hand.HandPlacementType.Placement) => <handPlacementType>, pack=metadata.graphics.hand, label=Placement, cls=metadata.graphics.hand.HandPlacementType, keyword=Placement, atomic=Placement, atomic path=metadata.graphics.hand.HandPlacementType.Placement
~~m~ Board name=Board type=Constant (metadata.graphics.no.NoBooleanType.Board) => <noBooleanType>, pack=metadata.graphics.no, label=Board, cls=metadata.graphics.no.NoBooleanType, keyword=Board, atomic=Board, atomic path=metadata.graphics.no.NoBooleanType.Board
~~m~ Animation name=Animation type=Constant (metadata.graphics.no.NoBooleanType.Animation) => <noBooleanType>, pack=metadata.graphics.no, label=Animation, cls=metadata.graphics.no.NoBooleanType, keyword=Animation, atomic=Animation, atomic path=metadata.graphics.no.NoBooleanType.Animation
~~m~ Sunken name=Sunken type=Constant (metadata.graphics.no.NoBooleanType.Sunken) => <noBooleanType>, pack=metadata.graphics.no, label=Sunken, cls=metadata.graphics.no.NoBooleanType, keyword=Sunken, atomic=Sunken, atomic path=metadata.graphics.no.NoBooleanType.Sunken
~~m~ HandScale name=HandScale type=Constant (metadata.graphics.no.NoBooleanType.HandScale) => <noBooleanType>, pack=metadata.graphics.no, label=HandScale, cls=metadata.graphics.no.NoBooleanType, keyword=HandScale, atomic=HandScale, atomic path=metadata.graphics.no.NoBooleanType.HandScale
~~m~ Curves name=Curves type=Constant (metadata.graphics.no.NoBooleanType.Curves) => <noBooleanType>, pack=metadata.graphics.no, label=Curves, cls=metadata.graphics.no.NoBooleanType, keyword=Curves, atomic=Curves, atomic path=metadata.graphics.no.NoBooleanType.Curves
~~m~ MaskedColour name=MaskedColour type=Constant (metadata.graphics.no.NoBooleanType.MaskedColour) => <noBooleanType>, pack=metadata.graphics.no, label=MaskedColour, cls=metadata.graphics.no.NoBooleanType, keyword=MaskedColour, atomic=MaskedColour, atomic path=metadata.graphics.no.NoBooleanType.MaskedColour
~~m~ DicePips name=DicePips type=Constant (metadata.graphics.no.NoBooleanType.DicePips) => <noBooleanType>, pack=metadata.graphics.no, label=DicePips, cls=metadata.graphics.no.NoBooleanType, keyword=DicePips, atomic=DicePips, atomic path=metadata.graphics.no.NoBooleanType.DicePips
g~m~ Colour name=Colour type=Constant (metadata.graphics.piece.PieceColourType.Colour) => <pieceColourType>, pack=metadata.graphics.piece, label=Colour, cls=metadata.graphics.piece.PieceColourType, keyword=Colour, atomic=Colour, atomic path=metadata.graphics.piece.PieceColourType.Colour
g~m~ Families name=Families type=Constant (metadata.graphics.piece.PieceFamiliesType.Families) => <pieceFamiliesType>, pack=metadata.graphics.piece, label=Families, cls=metadata.graphics.piece.PieceFamiliesType, keyword=Families, atomic=Families, atomic path=metadata.graphics.piece.PieceFamiliesType.Families
~~m~ Background name=Background type=Constant (metadata.graphics.piece.PieceGroundType.Background) => <pieceGroundType>, pack=metadata.graphics.piece, label=Background, cls=metadata.graphics.piece.PieceGroundType, keyword=Background, atomic=Background, atomic path=metadata.graphics.piece.PieceGroundType.Background
~~m~ Foreground name=Foreground type=Constant (metadata.graphics.piece.PieceGroundType.Foreground) => <pieceGroundType>, pack=metadata.graphics.piece, label=Foreground, cls=metadata.graphics.piece.PieceGroundType, keyword=Foreground, atomic=Foreground, atomic path=metadata.graphics.piece.PieceGroundType.Foreground
~~m~ Hidden name=Hidden type=Constant (metadata.graphics.piece.PieceGroundType.Hidden) => <pieceGroundType>, pack=metadata.graphics.piece, label=Hidden, cls=metadata.graphics.piece.PieceGroundType, keyword=Hidden, atomic=Hidden, atomic path=metadata.graphics.piece.PieceGroundType.Hidden
~~m~ Rename name=Rename type=Constant (metadata.graphics.piece.PieceNameType.Rename) => <pieceNameType>, pack=metadata.graphics.piece, label=Rename, cls=metadata.graphics.piece.PieceNameType, keyword=Rename, atomic=Rename, atomic path=metadata.graphics.piece.PieceNameType.Rename
~~m~ ExtendName name=ExtendName type=Constant (metadata.graphics.piece.PieceNameType.ExtendName) => <pieceNameType>, pack=metadata.graphics.piece, label=ExtendName, cls=metadata.graphics.piece.PieceNameType, keyword=ExtendName, atomic=ExtendName, atomic path=metadata.graphics.piece.PieceNameType.ExtendName
~~m~ AddStateToName name=AddStateToName type=Constant (metadata.graphics.piece.PieceNameType.AddStateToName) => <pieceNameType>, pack=metadata.graphics.piece, label=AddStateToName, cls=metadata.graphics.piece.PieceNameType, keyword=AddStateToName, atomic=AddStateToName, atomic path=metadata.graphics.piece.PieceNameType.AddStateToName
~~m~ Hidden name=Hidden type=Constant (metadata.graphics.piece.PieceNameType.Hidden) => <pieceNameType>, pack=metadata.graphics.piece, label=Hidden, cls=metadata.graphics.piece.PieceNameType, keyword=Hidden, atomic=Hidden, atomic path=metadata.graphics.piece.PieceNameType.Hidden
~~m~ Reflect name=Reflect type=Constant (metadata.graphics.piece.PieceReflectType.Reflect) => <pieceReflectType>, pack=metadata.graphics.piece, label=Reflect, cls=metadata.graphics.piece.PieceReflectType, keyword=Reflect, atomic=Reflect, atomic path=metadata.graphics.piece.PieceReflectType.Reflect
g~m~ Rotate name=Rotate type=Constant (metadata.graphics.piece.PieceRotateType.Rotate) => <pieceRotateType>, pack=metadata.graphics.piece, label=Rotate, cls=metadata.graphics.piece.PieceRotateType, keyword=Rotate, atomic=Rotate, atomic path=metadata.graphics.piece.PieceRotateType.Rotate
~~m~ ByValue name=ByValue type=Constant (metadata.graphics.piece.PieceScaleByType.ByValue) => <pieceScaleByType>, pack=metadata.graphics.piece, label=ByValue, cls=metadata.graphics.piece.PieceScaleByType, keyword=ByValue, atomic=ByValue, atomic path=metadata.graphics.piece.PieceScaleByType.ByValue
g~m~ Scale name=Scale type=Constant (metadata.graphics.piece.PieceScaleType.Scale) => <pieceScaleType>, pack=metadata.graphics.piece, label=Scale, cls=metadata.graphics.piece.PieceScaleType, keyword=Scale, atomic=Scale, atomic path=metadata.graphics.piece.PieceScaleType.Scale
g~m~ Style name=Style type=Constant (metadata.graphics.piece.PieceStyleType.Style) => <pieceStyleType>, pack=metadata.graphics.piece, label=Style, cls=metadata.graphics.piece.PieceStyleType, keyword=Style, atomic=Style, atomic path=metadata.graphics.piece.PieceStyleType.Style
g~m~ Colour name=Colour type=Constant (metadata.graphics.player.PlayerColourType.Colour) => <playerColourType>, pack=metadata.graphics.player, label=Colour, cls=metadata.graphics.player.PlayerColourType, keyword=Colour, atomic=Colour, atomic path=metadata.graphics.player.PlayerColourType.Colour
g~m~ Name name=Name type=Constant (metadata.graphics.player.PlayerNameType.Name) => <playerNameType>, pack=metadata.graphics.player, label=Name, cls=metadata.graphics.player.PlayerNameType, keyword=Name, atomic=Name, atomic path=metadata.graphics.player.PlayerNameType.Name
g~m~ Colour name=Colour type=Constant (metadata.graphics.region.RegionColourType.Colour) => <regionColourType>, pack=metadata.graphics.region, label=Colour, cls=metadata.graphics.region.RegionColourType, keyword=Colour, atomic=Colour, atomic path=metadata.graphics.region.RegionColourType.Colour
~~m~ Pits name=Pits type=Constant (metadata.graphics.show.ShowBooleanType.Pits) => <showBooleanType>, pack=metadata.graphics.show, label=Pits, cls=metadata.graphics.show.ShowBooleanType, keyword=Pits, atomic=Pits, atomic path=metadata.graphics.show.ShowBooleanType.Pits
~~m~ PlayerHoles name=PlayerHoles type=Constant (metadata.graphics.show.ShowBooleanType.PlayerHoles) => <showBooleanType>, pack=metadata.graphics.show, label=PlayerHoles, cls=metadata.graphics.show.ShowBooleanType, keyword=PlayerHoles, atomic=PlayerHoles, atomic path=metadata.graphics.show.ShowBooleanType.PlayerHoles
~~m~ LocalStateHoles name=LocalStateHoles type=Constant (metadata.graphics.show.ShowBooleanType.LocalStateHoles) => <showBooleanType>, pack=metadata.graphics.show, label=LocalStateHoles, cls=metadata.graphics.show.ShowBooleanType, keyword=LocalStateHoles, atomic=LocalStateHoles, atomic path=metadata.graphics.show.ShowBooleanType.LocalStateHoles
~~m~ RegionOwner name=RegionOwner type=Constant (metadata.graphics.show.ShowBooleanType.RegionOwner) => <showBooleanType>, pack=metadata.graphics.show, label=RegionOwner, cls=metadata.graphics.show.ShowBooleanType, keyword=RegionOwner, atomic=RegionOwner, atomic path=metadata.graphics.show.ShowBooleanType.RegionOwner
~~m~ Cost name=Cost type=Constant (metadata.graphics.show.ShowBooleanType.Cost) => <showBooleanType>, pack=metadata.graphics.show, label=Cost, cls=metadata.graphics.show.ShowBooleanType, keyword=Cost, atomic=Cost, atomic path=metadata.graphics.show.ShowBooleanType.Cost
~~m~ Hints name=Hints type=Constant (metadata.graphics.show.ShowBooleanType.Hints) => <showBooleanType>, pack=metadata.graphics.show, label=Hints, cls=metadata.graphics.show.ShowBooleanType, keyword=Hints, atomic=Hints, atomic path=metadata.graphics.show.ShowBooleanType.Hints
~~m~ EdgeDirections name=EdgeDirections type=Constant (metadata.graphics.show.ShowBooleanType.EdgeDirections) => <showBooleanType>, pack=metadata.graphics.show, label=EdgeDirections, cls=metadata.graphics.show.ShowBooleanType, keyword=EdgeDirections, atomic=EdgeDirections, atomic path=metadata.graphics.show.ShowBooleanType.EdgeDirections
~~m~ PossibleMoves name=PossibleMoves type=Constant (metadata.graphics.show.ShowBooleanType.PossibleMoves) => <showBooleanType>, pack=metadata.graphics.show, label=PossibleMoves, cls=metadata.graphics.show.ShowBooleanType, keyword=PossibleMoves, atomic=PossibleMoves, atomic path=metadata.graphics.show.ShowBooleanType.PossibleMoves
~~m~ CurvedEdges name=CurvedEdges type=Constant (metadata.graphics.show.ShowBooleanType.CurvedEdges) => <showBooleanType>, pack=metadata.graphics.show, label=CurvedEdges, cls=metadata.graphics.show.ShowBooleanType, keyword=CurvedEdges, atomic=CurvedEdges, atomic path=metadata.graphics.show.ShowBooleanType.CurvedEdges
~~m~ StraightEdges name=StraightEdges type=Constant (metadata.graphics.show.ShowBooleanType.StraightEdges) => <showBooleanType>, pack=metadata.graphics.show, label=StraightEdges, cls=metadata.graphics.show.ShowBooleanType, keyword=StraightEdges, atomic=StraightEdges, atomic path=metadata.graphics.show.ShowBooleanType.StraightEdges
g~m~ Check name=Check type=Constant (metadata.graphics.show.ShowCheckType.Check) => <showCheckType>, pack=metadata.graphics.show, label=Check, cls=metadata.graphics.show.ShowCheckType, keyword=Check, atomic=Check, atomic path=metadata.graphics.show.ShowCheckType.Check
~~m~ State name=State type=Constant (metadata.graphics.show.ShowComponentDataType.State) => <showComponentDataType>, pack=metadata.graphics.show, label=State, cls=metadata.graphics.show.ShowComponentDataType, keyword=State, atomic=State, atomic path=metadata.graphics.show.ShowComponentDataType.State
~~m~ Value name=Value type=Constant (metadata.graphics.show.ShowComponentDataType.Value) => <showComponentDataType>, pack=metadata.graphics.show, label=Value, cls=metadata.graphics.show.ShowComponentDataType, keyword=Value, atomic=Value, atomic path=metadata.graphics.show.ShowComponentDataType.Value
g~m~ Piece name=Piece type=Constant (metadata.graphics.show.ShowComponentType.Piece) => <showComponentType>, pack=metadata.graphics.show, label=Piece, cls=metadata.graphics.show.ShowComponentType, keyword=Piece, atomic=Piece, atomic path=metadata.graphics.show.ShowComponentType.Piece
g~m~ Edges name=Edges type=Constant (metadata.graphics.show.ShowEdgeType.Edges) => <showEdgeType>, pack=metadata.graphics.show, label=Edges, cls=metadata.graphics.show.ShowEdgeType, keyword=Edges, atomic=Edges, atomic path=metadata.graphics.show.ShowEdgeType.Edges
g~m~ Line name=Line type=Constant (metadata.graphics.show.ShowLineType.Line) => <showLineType>, pack=metadata.graphics.show, label=Line, cls=metadata.graphics.show.ShowLineType, keyword=Line, atomic=Line, atomic path=metadata.graphics.show.ShowLineType.Line
g~m~ Score name=Score type=Constant (metadata.graphics.show.ShowScoreType.Score) => <showScoreType>, pack=metadata.graphics.show, label=Score, cls=metadata.graphics.show.ShowScoreType, keyword=Score, atomic=Score, atomic path=metadata.graphics.show.ShowScoreType.Score
~~m~ AsHoles name=AsHoles type=Constant (metadata.graphics.show.ShowSiteDataType.AsHoles) => <showSiteDataType>, pack=metadata.graphics.show, label=AsHoles, cls=metadata.graphics.show.ShowSiteDataType, keyword=AsHoles, atomic=AsHoles, atomic path=metadata.graphics.show.ShowSiteDataType.AsHoles
~~m~ SiteIndex name=SiteIndex type=Constant (metadata.graphics.show.ShowSiteDataType.SiteIndex) => <showSiteDataType>, pack=metadata.graphics.show, label=SiteIndex, cls=metadata.graphics.show.ShowSiteDataType, keyword=SiteIndex, atomic=SiteIndex, atomic path=metadata.graphics.show.ShowSiteDataType.SiteIndex
~~m~ Sites name=Sites type=Constant (metadata.graphics.show.ShowSiteType.Sites) => <showSiteType>, pack=metadata.graphics.show, label=Sites, cls=metadata.graphics.show.ShowSiteType, keyword=Sites, atomic=Sites, atomic path=metadata.graphics.show.ShowSiteType.Sites
~~m~ Cell name=Cell type=Constant (metadata.graphics.show.ShowSiteType.Cell) => <showSiteType>, pack=metadata.graphics.show, label=Cell, cls=metadata.graphics.show.ShowSiteType, keyword=Cell, atomic=Cell, atomic path=metadata.graphics.show.ShowSiteType.Cell
g~m~ Symbol name=Symbol type=Constant (metadata.graphics.show.ShowSymbolType.Symbol) => <showSymbolType>, pack=metadata.graphics.show, label=Symbol, cls=metadata.graphics.show.ShowSymbolType, keyword=Symbol, atomic=Symbol, atomic path=metadata.graphics.show.ShowSymbolType.Symbol
~~m~ InnerEdges name=InnerEdges type=Constant (metadata.graphics.util.BoardGraphicsType.InnerEdges) => <boardGraphicsType>, pack=metadata.graphics.util, label=InnerEdges, cls=metadata.graphics.util.BoardGraphicsType, keyword=InnerEdges, atomic=InnerEdges, atomic path=metadata.graphics.util.BoardGraphicsType.InnerEdges
~~m~ OuterEdges name=OuterEdges type=Constant (metadata.graphics.util.BoardGraphicsType.OuterEdges) => <boardGraphicsType>, pack=metadata.graphics.util, label=OuterEdges, cls=metadata.graphics.util.BoardGraphicsType, keyword=OuterEdges, atomic=OuterEdges, atomic path=metadata.graphics.util.BoardGraphicsType.OuterEdges
~~m~ Phase0 name=Phase0 type=Constant (metadata.graphics.util.BoardGraphicsType.Phase0) => <boardGraphicsType>, pack=metadata.graphics.util, label=Phase0, cls=metadata.graphics.util.BoardGraphicsType, keyword=Phase0, atomic=Phase0, atomic path=metadata.graphics.util.BoardGraphicsType.Phase0
~~m~ Phase1 name=Phase1 type=Constant (metadata.graphics.util.BoardGraphicsType.Phase1) => <boardGraphicsType>, pack=metadata.graphics.util, label=Phase1, cls=metadata.graphics.util.BoardGraphicsType, keyword=Phase1, atomic=Phase1, atomic path=metadata.graphics.util.BoardGraphicsType.Phase1
~~m~ Phase2 name=Phase2 type=Constant (metadata.graphics.util.BoardGraphicsType.Phase2) => <boardGraphicsType>, pack=metadata.graphics.util, label=Phase2, cls=metadata.graphics.util.BoardGraphicsType, keyword=Phase2, atomic=Phase2, atomic path=metadata.graphics.util.BoardGraphicsType.Phase2
~~m~ Phase3 name=Phase3 type=Constant (metadata.graphics.util.BoardGraphicsType.Phase3) => <boardGraphicsType>, pack=metadata.graphics.util, label=Phase3, cls=metadata.graphics.util.BoardGraphicsType, keyword=Phase3, atomic=Phase3, atomic path=metadata.graphics.util.BoardGraphicsType.Phase3
~~m~ Phase4 name=Phase4 type=Constant (metadata.graphics.util.BoardGraphicsType.Phase4) => <boardGraphicsType>, pack=metadata.graphics.util, label=Phase4, cls=metadata.graphics.util.BoardGraphicsType, keyword=Phase4, atomic=Phase4, atomic path=metadata.graphics.util.BoardGraphicsType.Phase4
~~m~ Phase5 name=Phase5 type=Constant (metadata.graphics.util.BoardGraphicsType.Phase5) => <boardGraphicsType>, pack=metadata.graphics.util, label=Phase5, cls=metadata.graphics.util.BoardGraphicsType, keyword=Phase5, atomic=Phase5, atomic path=metadata.graphics.util.BoardGraphicsType.Phase5
~~m~ Symbols name=Symbols type=Constant (metadata.graphics.util.BoardGraphicsType.Symbols) => <boardGraphicsType>, pack=metadata.graphics.util, label=Symbols, cls=metadata.graphics.util.BoardGraphicsType, keyword=Symbols, atomic=Symbols, atomic path=metadata.graphics.util.BoardGraphicsType.Symbols
~~m~ InnerVertices name=InnerVertices type=Constant (metadata.graphics.util.BoardGraphicsType.InnerVertices) => <boardGraphicsType>, pack=metadata.graphics.util, label=InnerVertices, cls=metadata.graphics.util.BoardGraphicsType, keyword=InnerVertices, atomic=InnerVertices, atomic path=metadata.graphics.util.BoardGraphicsType.InnerVertices
~~m~ OuterVertices name=OuterVertices type=Constant (metadata.graphics.util.BoardGraphicsType.OuterVertices) => <boardGraphicsType>, pack=metadata.graphics.util, label=OuterVertices, cls=metadata.graphics.util.BoardGraphicsType, keyword=OuterVertices, atomic=OuterVertices, atomic path=metadata.graphics.util.BoardGraphicsType.OuterVertices
~~m~ Piece name=Piece type=Constant (metadata.graphics.util.ComponentStyleType.Piece) => <componentStyleType>, pack=metadata.graphics.util, label=Piece, cls=metadata.graphics.util.ComponentStyleType, keyword=Piece, atomic=Piece, atomic path=metadata.graphics.util.ComponentStyleType.Piece
~~m~ Text name=Text type=Constant (metadata.graphics.util.ComponentStyleType.Text) => <componentStyleType>, pack=metadata.graphics.util, label=Text, cls=metadata.graphics.util.ComponentStyleType, keyword=Text, atomic=Text, atomic path=metadata.graphics.util.ComponentStyleType.Text
~~m~ Tile name=Tile type=Constant (metadata.graphics.util.ComponentStyleType.Tile) => <componentStyleType>, pack=metadata.graphics.util, label=Tile, cls=metadata.graphics.util.ComponentStyleType, keyword=Tile, atomic=Tile, atomic path=metadata.graphics.util.ComponentStyleType.Tile
~~m~ Card name=Card type=Constant (metadata.graphics.util.ComponentStyleType.Card) => <componentStyleType>, pack=metadata.graphics.util, label=Card, cls=metadata.graphics.util.ComponentStyleType, keyword=Card, atomic=Card, atomic path=metadata.graphics.util.ComponentStyleType.Card
~~m~ Die name=Die type=Constant (metadata.graphics.util.ComponentStyleType.Die) => <componentStyleType>, pack=metadata.graphics.util, label=Die, cls=metadata.graphics.util.ComponentStyleType, keyword=Die, atomic=Die, atomic path=metadata.graphics.util.ComponentStyleType.Die
~~m~ Domino name=Domino type=Constant (metadata.graphics.util.ComponentStyleType.Domino) => <componentStyleType>, pack=metadata.graphics.util, label=Domino, cls=metadata.graphics.util.ComponentStyleType, keyword=Domino, atomic=Domino, atomic path=metadata.graphics.util.ComponentStyleType.Domino
~~m~ LargePiece name=LargePiece type=Constant (metadata.graphics.util.ComponentStyleType.LargePiece) => <componentStyleType>, pack=metadata.graphics.util, label=LargePiece, cls=metadata.graphics.util.ComponentStyleType, keyword=LargePiece, atomic=LargePiece, atomic path=metadata.graphics.util.ComponentStyleType.LargePiece
~~m~ ExtendedShogi name=ExtendedShogi type=Constant (metadata.graphics.util.ComponentStyleType.ExtendedShogi) => <componentStyleType>, pack=metadata.graphics.util, label=ExtendedShogi, cls=metadata.graphics.util.ComponentStyleType, keyword=ExtendedShogi, atomic=ExtendedShogi, atomic path=metadata.graphics.util.ComponentStyleType.ExtendedShogi
~~m~ ExtendedXiangqi name=ExtendedXiangqi type=Constant (metadata.graphics.util.ComponentStyleType.ExtendedXiangqi) => <componentStyleType>, pack=metadata.graphics.util, label=ExtendedXiangqi, cls=metadata.graphics.util.ComponentStyleType, keyword=ExtendedXiangqi, atomic=ExtendedXiangqi, atomic path=metadata.graphics.util.ComponentStyleType.ExtendedXiangqi
~~m~ NativeAmericanDice name=NativeAmericanDice type=Constant (metadata.graphics.util.ComponentStyleType.NativeAmericanDice) => <componentStyleType>, pack=metadata.graphics.util, label=NativeAmericanDice, cls=metadata.graphics.util.ComponentStyleType, keyword=NativeAmericanDice, atomic=NativeAmericanDice, atomic path=metadata.graphics.util.ComponentStyleType.NativeAmericanDice
~~m~ Board name=Board type=Constant (metadata.graphics.util.ContainerStyleType.Board) => <containerStyleType>, pack=metadata.graphics.util, label=Board, cls=metadata.graphics.util.ContainerStyleType, keyword=Board, atomic=Board, atomic path=metadata.graphics.util.ContainerStyleType.Board
~~m~ Hand name=Hand type=Constant (metadata.graphics.util.ContainerStyleType.Hand) => <containerStyleType>, pack=metadata.graphics.util, label=Hand, cls=metadata.graphics.util.ContainerStyleType, keyword=Hand, atomic=Hand, atomic path=metadata.graphics.util.ContainerStyleType.Hand
~~m~ Deck name=Deck type=Constant (metadata.graphics.util.ContainerStyleType.Deck) => <containerStyleType>, pack=metadata.graphics.util, label=Deck, cls=metadata.graphics.util.ContainerStyleType, keyword=Deck, atomic=Deck, atomic path=metadata.graphics.util.ContainerStyleType.Deck
~~m~ Dice name=Dice type=Constant (metadata.graphics.util.ContainerStyleType.Dice) => <containerStyleType>, pack=metadata.graphics.util, label=Dice, cls=metadata.graphics.util.ContainerStyleType, keyword=Dice, atomic=Dice, atomic path=metadata.graphics.util.ContainerStyleType.Dice
~~m~ Boardless name=Boardless type=Constant (metadata.graphics.util.ContainerStyleType.Boardless) => <containerStyleType>, pack=metadata.graphics.util, label=Boardless, cls=metadata.graphics.util.ContainerStyleType, keyword=Boardless, atomic=Boardless, atomic path=metadata.graphics.util.ContainerStyleType.Boardless
~~m~ ConnectiveGoal name=ConnectiveGoal type=Constant (metadata.graphics.util.ContainerStyleType.ConnectiveGoal) => <containerStyleType>, pack=metadata.graphics.util, label=ConnectiveGoal, cls=metadata.graphics.util.ContainerStyleType, keyword=ConnectiveGoal, atomic=ConnectiveGoal, atomic path=metadata.graphics.util.ContainerStyleType.ConnectiveGoal
~~m~ Mancala name=Mancala type=Constant (metadata.graphics.util.ContainerStyleType.Mancala) => <containerStyleType>, pack=metadata.graphics.util, label=Mancala, cls=metadata.graphics.util.ContainerStyleType, keyword=Mancala, atomic=Mancala, atomic path=metadata.graphics.util.ContainerStyleType.Mancala
~~m~ PenAndPaper name=PenAndPaper type=Constant (metadata.graphics.util.ContainerStyleType.PenAndPaper) => <containerStyleType>, pack=metadata.graphics.util, label=PenAndPaper, cls=metadata.graphics.util.ContainerStyleType, keyword=PenAndPaper, atomic=PenAndPaper, atomic path=metadata.graphics.util.ContainerStyleType.PenAndPaper
~~m~ Shibumi name=Shibumi type=Constant (metadata.graphics.util.ContainerStyleType.Shibumi) => <containerStyleType>, pack=metadata.graphics.util, label=Shibumi, cls=metadata.graphics.util.ContainerStyleType, keyword=Shibumi, atomic=Shibumi, atomic path=metadata.graphics.util.ContainerStyleType.Shibumi
~~m~ Spiral name=Spiral type=Constant (metadata.graphics.util.ContainerStyleType.Spiral) => <containerStyleType>, pack=metadata.graphics.util, label=Spiral, cls=metadata.graphics.util.ContainerStyleType, keyword=Spiral, atomic=Spiral, atomic path=metadata.graphics.util.ContainerStyleType.Spiral
~~m~ Isometric name=Isometric type=Constant (metadata.graphics.util.ContainerStyleType.Isometric) => <containerStyleType>, pack=metadata.graphics.util, label=Isometric, cls=metadata.graphics.util.ContainerStyleType, keyword=Isometric, atomic=Isometric, atomic path=metadata.graphics.util.ContainerStyleType.Isometric
~~m~ Puzzle name=Puzzle type=Constant (metadata.graphics.util.ContainerStyleType.Puzzle) => <containerStyleType>, pack=metadata.graphics.util, label=Puzzle, cls=metadata.graphics.util.ContainerStyleType, keyword=Puzzle, atomic=Puzzle, atomic path=metadata.graphics.util.ContainerStyleType.Puzzle
~~m~ Backgammon name=Backgammon type=Constant (metadata.graphics.util.ContainerStyleType.Backgammon) => <containerStyleType>, pack=metadata.graphics.util, label=Backgammon, cls=metadata.graphics.util.ContainerStyleType, keyword=Backgammon, atomic=Backgammon, atomic path=metadata.graphics.util.ContainerStyleType.Backgammon
~~m~ Chess name=Chess type=Constant (metadata.graphics.util.ContainerStyleType.Chess) => <containerStyleType>, pack=metadata.graphics.util, label=Chess, cls=metadata.graphics.util.ContainerStyleType, keyword=Chess, atomic=Chess, atomic path=metadata.graphics.util.ContainerStyleType.Chess
~~m~ Connect4 name=Connect4 type=Constant (metadata.graphics.util.ContainerStyleType.Connect4) => <containerStyleType>, pack=metadata.graphics.util, label=Connect4, cls=metadata.graphics.util.ContainerStyleType, keyword=Connect4, atomic=Connect4, atomic path=metadata.graphics.util.ContainerStyleType.Connect4
~~m~ Go name=Go type=Constant (metadata.graphics.util.ContainerStyleType.Go) => <containerStyleType>, pack=metadata.graphics.util, label=Go, cls=metadata.graphics.util.ContainerStyleType, keyword=Go, atomic=Go, atomic path=metadata.graphics.util.ContainerStyleType.Go
~~m~ Graph name=Graph type=Constant (metadata.graphics.util.ContainerStyleType.Graph) => <containerStyleType>, pack=metadata.graphics.util, label=Graph, cls=metadata.graphics.util.ContainerStyleType, keyword=Graph, atomic=Graph, atomic path=metadata.graphics.util.ContainerStyleType.Graph
~~m~ HoundsAndJackals name=HoundsAndJackals type=Constant (metadata.graphics.util.ContainerStyleType.HoundsAndJackals) => <containerStyleType>, pack=metadata.graphics.util, label=HoundsAndJackals, cls=metadata.graphics.util.ContainerStyleType, keyword=HoundsAndJackals, atomic=HoundsAndJackals, atomic path=metadata.graphics.util.ContainerStyleType.HoundsAndJackals
~~m~ Janggi name=Janggi type=Constant (metadata.graphics.util.ContainerStyleType.Janggi) => <containerStyleType>, pack=metadata.graphics.util, label=Janggi, cls=metadata.graphics.util.ContainerStyleType, keyword=Janggi, atomic=Janggi, atomic path=metadata.graphics.util.ContainerStyleType.Janggi
~~m~ Lasca name=Lasca type=Constant (metadata.graphics.util.ContainerStyleType.Lasca) => <containerStyleType>, pack=metadata.graphics.util, label=Lasca, cls=metadata.graphics.util.ContainerStyleType, keyword=Lasca, atomic=Lasca, atomic path=metadata.graphics.util.ContainerStyleType.Lasca
~~m~ Shogi name=Shogi type=Constant (metadata.graphics.util.ContainerStyleType.Shogi) => <containerStyleType>, pack=metadata.graphics.util, label=Shogi, cls=metadata.graphics.util.ContainerStyleType, keyword=Shogi, atomic=Shogi, atomic path=metadata.graphics.util.ContainerStyleType.Shogi
~~m~ SnakesAndLadders name=SnakesAndLadders type=Constant (metadata.graphics.util.ContainerStyleType.SnakesAndLadders) => <containerStyleType>, pack=metadata.graphics.util, label=SnakesAndLadders, cls=metadata.graphics.util.ContainerStyleType, keyword=SnakesAndLadders, atomic=SnakesAndLadders, atomic path=metadata.graphics.util.ContainerStyleType.SnakesAndLadders
~~m~ Surakarta name=Surakarta type=Constant (metadata.graphics.util.ContainerStyleType.Surakarta) => <containerStyleType>, pack=metadata.graphics.util, label=Surakarta, cls=metadata.graphics.util.ContainerStyleType, keyword=Surakarta, atomic=Surakarta, atomic path=metadata.graphics.util.ContainerStyleType.Surakarta
~~m~ Table name=Table type=Constant (metadata.graphics.util.ContainerStyleType.Table) => <containerStyleType>, pack=metadata.graphics.util, label=Table, cls=metadata.graphics.util.ContainerStyleType, keyword=Table, atomic=Table, atomic path=metadata.graphics.util.ContainerStyleType.Table
~~m~ Tafl name=Tafl type=Constant (metadata.graphics.util.ContainerStyleType.Tafl) => <containerStyleType>, pack=metadata.graphics.util, label=Tafl, cls=metadata.graphics.util.ContainerStyleType, keyword=Tafl, atomic=Tafl, atomic path=metadata.graphics.util.ContainerStyleType.Tafl
~~m~ Xiangqi name=Xiangqi type=Constant (metadata.graphics.util.ContainerStyleType.Xiangqi) => <containerStyleType>, pack=metadata.graphics.util, label=Xiangqi, cls=metadata.graphics.util.ContainerStyleType, keyword=Xiangqi, atomic=Xiangqi, atomic path=metadata.graphics.util.ContainerStyleType.Xiangqi
~~m~ UltimateTicTacToe name=UltimateTicTacToe type=Constant (metadata.graphics.util.ContainerStyleType.UltimateTicTacToe) => <containerStyleType>, pack=metadata.graphics.util, label=UltimateTicTacToe, cls=metadata.graphics.util.ContainerStyleType, keyword=UltimateTicTacToe, atomic=UltimateTicTacToe, atomic path=metadata.graphics.util.ContainerStyleType.UltimateTicTacToe
~~m~ Futoshiki name=Futoshiki type=Constant (metadata.graphics.util.ContainerStyleType.Futoshiki) => <containerStyleType>, pack=metadata.graphics.util, label=Futoshiki, cls=metadata.graphics.util.ContainerStyleType, keyword=Futoshiki, atomic=Futoshiki, atomic path=metadata.graphics.util.ContainerStyleType.Futoshiki
~~m~ Hashi name=Hashi type=Constant (metadata.graphics.util.ContainerStyleType.Hashi) => <containerStyleType>, pack=metadata.graphics.util, label=Hashi, cls=metadata.graphics.util.ContainerStyleType, keyword=Hashi, atomic=Hashi, atomic path=metadata.graphics.util.ContainerStyleType.Hashi
~~m~ Kakuro name=Kakuro type=Constant (metadata.graphics.util.ContainerStyleType.Kakuro) => <containerStyleType>, pack=metadata.graphics.util, label=Kakuro, cls=metadata.graphics.util.ContainerStyleType, keyword=Kakuro, atomic=Kakuro, atomic path=metadata.graphics.util.ContainerStyleType.Kakuro
~~m~ Sudoku name=Sudoku type=Constant (metadata.graphics.util.ContainerStyleType.Sudoku) => <containerStyleType>, pack=metadata.graphics.util, label=Sudoku, cls=metadata.graphics.util.ContainerStyleType, keyword=Sudoku, atomic=Sudoku, atomic path=metadata.graphics.util.ContainerStyleType.Sudoku
~~m~ BasicController name=BasicController type=Constant (metadata.graphics.util.ControllerType.BasicController) => <controllerType>, pack=metadata.graphics.util, label=BasicController, cls=metadata.graphics.util.ControllerType, keyword=BasicController, atomic=BasicController, atomic path=metadata.graphics.util.ControllerType.BasicController
~~m~ PyramidalController name=PyramidalController type=Constant (metadata.graphics.util.ControllerType.PyramidalController) => <controllerType>, pack=metadata.graphics.util, label=PyramidalController, cls=metadata.graphics.util.ControllerType, keyword=PyramidalController, atomic=PyramidalController, atomic path=metadata.graphics.util.ControllerType.PyramidalController
~~m~ Spline name=Spline type=Constant (metadata.graphics.util.CurveType.Spline) => <curveType>, pack=metadata.graphics.util, label=Spline, cls=metadata.graphics.util.CurveType, keyword=Spline, atomic=Spline, atomic path=metadata.graphics.util.CurveType.Spline
~~m~ Bezier name=Bezier type=Constant (metadata.graphics.util.CurveType.Bezier) => <curveType>, pack=metadata.graphics.util, label=Bezier, cls=metadata.graphics.util.CurveType, keyword=Bezier, atomic=Bezier, atomic path=metadata.graphics.util.CurveType.Bezier
~~m~ All name=All type=Constant (metadata.graphics.util.EdgeType.All) => <edgeType>, pack=metadata.graphics.util, label=All, cls=metadata.graphics.util.EdgeType, keyword=All, atomic=All, atomic path=metadata.graphics.util.EdgeType.All
~~m~ Inner name=Inner type=Constant (metadata.graphics.util.EdgeType.Inner) => <edgeType>, pack=metadata.graphics.util, label=Inner, cls=metadata.graphics.util.EdgeType, keyword=Inner, atomic=Inner, atomic path=metadata.graphics.util.EdgeType.Inner
~~m~ Outer name=Outer type=Constant (metadata.graphics.util.EdgeType.Outer) => <edgeType>, pack=metadata.graphics.util, label=Outer, cls=metadata.graphics.util.EdgeType, keyword=Outer, atomic=Outer, atomic path=metadata.graphics.util.EdgeType.Outer
~~m~ Interlayer name=Interlayer type=Constant (metadata.graphics.util.EdgeType.Interlayer) => <edgeType>, pack=metadata.graphics.util, label=Interlayer, cls=metadata.graphics.util.EdgeType, keyword=Interlayer, atomic=Interlayer, atomic path=metadata.graphics.util.EdgeType.Interlayer
~~m~ Square name=Square type=Constant (metadata.graphics.util.HoleType.Square) => <holeType>, pack=metadata.graphics.util, label=Square, cls=metadata.graphics.util.HoleType, keyword=Square, atomic=Square, atomic path=metadata.graphics.util.HoleType.Square
~~m~ Oval name=Oval type=Constant (metadata.graphics.util.HoleType.Oval) => <holeType>, pack=metadata.graphics.util, label=Oval, cls=metadata.graphics.util.HoleType, keyword=Oval, atomic=Oval, atomic path=metadata.graphics.util.HoleType.Oval
~~m~ Thin name=Thin type=Constant (metadata.graphics.util.LineStyle.Thin) => <lineStyle>, pack=metadata.graphics.util, label=Thin, cls=metadata.graphics.util.LineStyle, keyword=Thin, atomic=Thin, atomic path=metadata.graphics.util.LineStyle.Thin
~~m~ Thick name=Thick type=Constant (metadata.graphics.util.LineStyle.Thick) => <lineStyle>, pack=metadata.graphics.util, label=Thick, cls=metadata.graphics.util.LineStyle, keyword=Thick, atomic=Thick, atomic path=metadata.graphics.util.LineStyle.Thick
~~m~ ThinDotted name=ThinDotted type=Constant (metadata.graphics.util.LineStyle.ThinDotted) => <lineStyle>, pack=metadata.graphics.util, label=ThinDotted, cls=metadata.graphics.util.LineStyle, keyword=ThinDotted, atomic=ThinDotted, atomic path=metadata.graphics.util.LineStyle.ThinDotted
~~m~ ThickDotted name=ThickDotted type=Constant (metadata.graphics.util.LineStyle.ThickDotted) => <lineStyle>, pack=metadata.graphics.util, label=ThickDotted, cls=metadata.graphics.util.LineStyle, keyword=ThickDotted, atomic=ThickDotted, atomic path=metadata.graphics.util.LineStyle.ThickDotted
~~m~ ThinDashed name=ThinDashed type=Constant (metadata.graphics.util.LineStyle.ThinDashed) => <lineStyle>, pack=metadata.graphics.util, label=ThinDashed, cls=metadata.graphics.util.LineStyle, keyword=ThinDashed, atomic=ThinDashed, atomic path=metadata.graphics.util.LineStyle.ThinDashed
~~m~ ThickDashed name=ThickDashed type=Constant (metadata.graphics.util.LineStyle.ThickDashed) => <lineStyle>, pack=metadata.graphics.util, label=ThickDashed, cls=metadata.graphics.util.LineStyle, keyword=ThickDashed, atomic=ThickDashed, atomic path=metadata.graphics.util.LineStyle.ThickDashed
~~m~ Hidden name=Hidden type=Constant (metadata.graphics.util.LineStyle.Hidden) => <lineStyle>, pack=metadata.graphics.util, label=Hidden, cls=metadata.graphics.util.LineStyle, keyword=Hidden, atomic=Hidden, atomic path=metadata.graphics.util.LineStyle.Hidden
~~m~ Fill name=Fill type=Constant (metadata.graphics.util.PieceColourType.Fill) => <pieceColourType>, pack=metadata.graphics.util, label=Fill, cls=metadata.graphics.util.PieceColourType, keyword=Fill, atomic=Fill, atomic path=metadata.graphics.util.PieceColourType.Fill
~~m~ Edge name=Edge type=Constant (metadata.graphics.util.PieceColourType.Edge) => <pieceColourType>, pack=metadata.graphics.util, label=Edge, cls=metadata.graphics.util.PieceColourType, keyword=Edge, atomic=Edge, atomic path=metadata.graphics.util.PieceColourType.Edge
~~m~ Secondary name=Secondary type=Constant (metadata.graphics.util.PieceColourType.Secondary) => <pieceColourType>, pack=metadata.graphics.util, label=Secondary, cls=metadata.graphics.util.PieceColourType, keyword=Secondary, atomic=Secondary, atomic path=metadata.graphics.util.PieceColourType.Secondary
~~m~ Default name=Default type=Constant (metadata.graphics.util.PieceStackType.Default) => <pieceStackType>, pack=metadata.graphics.util, label=Default, cls=metadata.graphics.util.PieceStackType, keyword=Default, atomic=Default, atomic path=metadata.graphics.util.PieceStackType.Default
~~m~ Ground name=Ground type=Constant (metadata.graphics.util.PieceStackType.Ground) => <pieceStackType>, pack=metadata.graphics.util, label=Ground, cls=metadata.graphics.util.PieceStackType, keyword=Ground, atomic=Ground, atomic path=metadata.graphics.util.PieceStackType.Ground
~~m~ GroundDynamic name=GroundDynamic type=Constant (metadata.graphics.util.PieceStackType.GroundDynamic) => <pieceStackType>, pack=metadata.graphics.util, label=GroundDynamic, cls=metadata.graphics.util.PieceStackType, keyword=GroundDynamic, atomic=GroundDynamic, atomic path=metadata.graphics.util.PieceStackType.GroundDynamic
~~m~ Reverse name=Reverse type=Constant (metadata.graphics.util.PieceStackType.Reverse) => <pieceStackType>, pack=metadata.graphics.util, label=Reverse, cls=metadata.graphics.util.PieceStackType, keyword=Reverse, atomic=Reverse, atomic path=metadata.graphics.util.PieceStackType.Reverse
~~m~ Fan name=Fan type=Constant (metadata.graphics.util.PieceStackType.Fan) => <pieceStackType>, pack=metadata.graphics.util, label=Fan, cls=metadata.graphics.util.PieceStackType, keyword=Fan, atomic=Fan, atomic path=metadata.graphics.util.PieceStackType.Fan
~~m~ FanAlternating name=FanAlternating type=Constant (metadata.graphics.util.PieceStackType.FanAlternating) => <pieceStackType>, pack=metadata.graphics.util, label=FanAlternating, cls=metadata.graphics.util.PieceStackType, keyword=FanAlternating, atomic=FanAlternating, atomic path=metadata.graphics.util.PieceStackType.FanAlternating
~~m~ None name=None type=Constant (metadata.graphics.util.PieceStackType.None) => <pieceStackType>, pack=metadata.graphics.util, label=None, cls=metadata.graphics.util.PieceStackType, keyword=None, atomic=None, atomic path=metadata.graphics.util.PieceStackType.None
~~m~ Backgammon name=Backgammon type=Constant (metadata.graphics.util.PieceStackType.Backgammon) => <pieceStackType>, pack=metadata.graphics.util, label=Backgammon, cls=metadata.graphics.util.PieceStackType, keyword=Backgammon, atomic=Backgammon, atomic path=metadata.graphics.util.PieceStackType.Backgammon
~~m~ Count name=Count type=Constant (metadata.graphics.util.PieceStackType.Count) => <pieceStackType>, pack=metadata.graphics.util, label=Count, cls=metadata.graphics.util.PieceStackType, keyword=Count, atomic=Count, atomic path=metadata.graphics.util.PieceStackType.Count
~~m~ DefaultAndCount name=DefaultAndCount type=Constant (metadata.graphics.util.PieceStackType.DefaultAndCount) => <pieceStackType>, pack=metadata.graphics.util, label=DefaultAndCount, cls=metadata.graphics.util.PieceStackType, keyword=DefaultAndCount, atomic=DefaultAndCount, atomic path=metadata.graphics.util.PieceStackType.DefaultAndCount
~~m~ CountColoured name=CountColoured type=Constant (metadata.graphics.util.PieceStackType.CountColoured) => <pieceStackType>, pack=metadata.graphics.util, label=CountColoured, cls=metadata.graphics.util.PieceStackType, keyword=CountColoured, atomic=CountColoured, atomic path=metadata.graphics.util.PieceStackType.CountColoured
~~m~ Ring name=Ring type=Constant (metadata.graphics.util.PieceStackType.Ring) => <pieceStackType>, pack=metadata.graphics.util, label=Ring, cls=metadata.graphics.util.PieceStackType, keyword=Ring, atomic=Ring, atomic path=metadata.graphics.util.PieceStackType.Ring
~~m~ TowardsCenter name=TowardsCenter type=Constant (metadata.graphics.util.PieceStackType.TowardsCenter) => <pieceStackType>, pack=metadata.graphics.util, label=TowardsCenter, cls=metadata.graphics.util.PieceStackType, keyword=TowardsCenter, atomic=TowardsCenter, atomic path=metadata.graphics.util.PieceStackType.TowardsCenter
~~m~ Default name=Default type=Constant (metadata.graphics.util.PuzzleDrawHintType.Default) => <puzzleDrawHintType>, pack=metadata.graphics.util, label=Default, cls=metadata.graphics.util.PuzzleDrawHintType, keyword=Default, atomic=Default, atomic path=metadata.graphics.util.PuzzleDrawHintType.Default
~~m~ TopLeft name=TopLeft type=Constant (metadata.graphics.util.PuzzleDrawHintType.TopLeft) => <puzzleDrawHintType>, pack=metadata.graphics.util, label=TopLeft, cls=metadata.graphics.util.PuzzleDrawHintType, keyword=TopLeft, atomic=TopLeft, atomic path=metadata.graphics.util.PuzzleDrawHintType.TopLeft
~~m~ NextTo name=NextTo type=Constant (metadata.graphics.util.PuzzleDrawHintType.NextTo) => <puzzleDrawHintType>, pack=metadata.graphics.util, label=NextTo, cls=metadata.graphics.util.PuzzleDrawHintType, keyword=NextTo, atomic=NextTo, atomic path=metadata.graphics.util.PuzzleDrawHintType.NextTo
~~m~ None name=None type=Constant (metadata.graphics.util.PuzzleDrawHintType.None) => <puzzleDrawHintType>, pack=metadata.graphics.util, label=None, cls=metadata.graphics.util.PuzzleDrawHintType, keyword=None, atomic=None, atomic path=metadata.graphics.util.PuzzleDrawHintType.None
~~m~ Default name=Default type=Constant (metadata.graphics.util.PuzzleHintLocationType.Default) => <puzzleHintLocationType>, pack=metadata.graphics.util, label=Default, cls=metadata.graphics.util.PuzzleHintLocationType, keyword=Default, atomic=Default, atomic path=metadata.graphics.util.PuzzleHintLocationType.Default
~~m~ BetweenVertices name=BetweenVertices type=Constant (metadata.graphics.util.PuzzleHintLocationType.BetweenVertices) => <puzzleHintLocationType>, pack=metadata.graphics.util, label=BetweenVertices, cls=metadata.graphics.util.PuzzleHintLocationType, keyword=BetweenVertices, atomic=BetweenVertices, atomic path=metadata.graphics.util.PuzzleHintLocationType.BetweenVertices
~~m~ Scale name=Scale type=Constant (metadata.graphics.util.StackPropertyType.Scale) => <stackPropertyType>, pack=metadata.graphics.util, label=Scale, cls=metadata.graphics.util.StackPropertyType, keyword=Scale, atomic=Scale, atomic path=metadata.graphics.util.StackPropertyType.Scale
~~m~ Limit name=Limit type=Constant (metadata.graphics.util.StackPropertyType.Limit) => <stackPropertyType>, pack=metadata.graphics.util, label=Limit, cls=metadata.graphics.util.StackPropertyType, keyword=Limit, atomic=Limit, atomic path=metadata.graphics.util.StackPropertyType.Limit
~~m~ Type name=Type type=Constant (metadata.graphics.util.StackPropertyType.Type) => <stackPropertyType>, pack=metadata.graphics.util, label=Type, cls=metadata.graphics.util.StackPropertyType, keyword=Type, atomic=Type, atomic path=metadata.graphics.util.StackPropertyType.Type
~~m~ None name=None type=Constant (metadata.graphics.util.ValueLocationType.None) => <valueLocationType>, pack=metadata.graphics.util, label=None, cls=metadata.graphics.util.ValueLocationType, keyword=None, atomic=None, atomic path=metadata.graphics.util.ValueLocationType.None
~~m~ CornerLeft name=CornerLeft type=Constant (metadata.graphics.util.ValueLocationType.CornerLeft) => <valueLocationType>, pack=metadata.graphics.util, label=CornerLeft, cls=metadata.graphics.util.ValueLocationType, keyword=CornerLeft, atomic=CornerLeft, atomic path=metadata.graphics.util.ValueLocationType.CornerLeft
~~m~ CornerRight name=CornerRight type=Constant (metadata.graphics.util.ValueLocationType.CornerRight) => <valueLocationType>, pack=metadata.graphics.util, label=CornerRight, cls=metadata.graphics.util.ValueLocationType, keyword=CornerRight, atomic=CornerRight, atomic path=metadata.graphics.util.ValueLocationType.CornerRight
~~m~ Top name=Top type=Constant (metadata.graphics.util.ValueLocationType.Top) => <valueLocationType>, pack=metadata.graphics.util, label=Top, cls=metadata.graphics.util.ValueLocationType, keyword=Top, atomic=Top, atomic path=metadata.graphics.util.ValueLocationType.Top
~~m~ Middle name=Middle type=Constant (metadata.graphics.util.ValueLocationType.Middle) => <valueLocationType>, pack=metadata.graphics.util, label=Middle, cls=metadata.graphics.util.ValueLocationType, keyword=Middle, atomic=Middle, atomic path=metadata.graphics.util.ValueLocationType.Middle
~~m~ Always name=Always type=Constant (metadata.graphics.util.WhenScoreType.Always) => <whenScoreType>, pack=metadata.graphics.util, label=Always, cls=metadata.graphics.util.WhenScoreType, keyword=Always, atomic=Always, atomic path=metadata.graphics.util.WhenScoreType.Always
~~m~ Never name=Never type=Constant (metadata.graphics.util.WhenScoreType.Never) => <whenScoreType>, pack=metadata.graphics.util, label=Never, cls=metadata.graphics.util.WhenScoreType, keyword=Never, atomic=Never, atomic path=metadata.graphics.util.WhenScoreType.Never
~~m~ AtEnd name=AtEnd type=Constant (metadata.graphics.util.WhenScoreType.AtEnd) => <whenScoreType>, pack=metadata.graphics.util, label=AtEnd, cls=metadata.graphics.util.WhenScoreType, keyword=AtEnd, atomic=AtEnd, atomic path=metadata.graphics.util.WhenScoreType.AtEnd
~~m~ White name=White type=Constant (metadata.graphics.util.colour.UserColourType.White) => <userColourType>, pack=metadata.graphics.util.colour, label=White, cls=metadata.graphics.util.colour.UserColourType, keyword=White, atomic=White, atomic path=metadata.graphics.util.colour.UserColourType.White
~~m~ Black name=Black type=Constant (metadata.graphics.util.colour.UserColourType.Black) => <userColourType>, pack=metadata.graphics.util.colour, label=Black, cls=metadata.graphics.util.colour.UserColourType, keyword=Black, atomic=Black, atomic path=metadata.graphics.util.colour.UserColourType.Black
~~m~ Grey name=Grey type=Constant (metadata.graphics.util.colour.UserColourType.Grey) => <userColourType>, pack=metadata.graphics.util.colour, label=Grey, cls=metadata.graphics.util.colour.UserColourType, keyword=Grey, atomic=Grey, atomic path=metadata.graphics.util.colour.UserColourType.Grey
~~m~ LightGrey name=LightGrey type=Constant (metadata.graphics.util.colour.UserColourType.LightGrey) => <userColourType>, pack=metadata.graphics.util.colour, label=LightGrey, cls=metadata.graphics.util.colour.UserColourType, keyword=LightGrey, atomic=LightGrey, atomic path=metadata.graphics.util.colour.UserColourType.LightGrey
~~m~ VeryLightGrey name=VeryLightGrey type=Constant (metadata.graphics.util.colour.UserColourType.VeryLightGrey) => <userColourType>, pack=metadata.graphics.util.colour, label=VeryLightGrey, cls=metadata.graphics.util.colour.UserColourType, keyword=VeryLightGrey, atomic=VeryLightGrey, atomic path=metadata.graphics.util.colour.UserColourType.VeryLightGrey
~~m~ DarkGrey name=DarkGrey type=Constant (metadata.graphics.util.colour.UserColourType.DarkGrey) => <userColourType>, pack=metadata.graphics.util.colour, label=DarkGrey, cls=metadata.graphics.util.colour.UserColourType, keyword=DarkGrey, atomic=DarkGrey, atomic path=metadata.graphics.util.colour.UserColourType.DarkGrey
~~m~ VeryDarkGrey name=VeryDarkGrey type=Constant (metadata.graphics.util.colour.UserColourType.VeryDarkGrey) => <userColourType>, pack=metadata.graphics.util.colour, label=VeryDarkGrey, cls=metadata.graphics.util.colour.UserColourType, keyword=VeryDarkGrey, atomic=VeryDarkGrey, atomic path=metadata.graphics.util.colour.UserColourType.VeryDarkGrey
~~m~ Dark name=Dark type=Constant (metadata.graphics.util.colour.UserColourType.Dark) => <userColourType>, pack=metadata.graphics.util.colour, label=Dark, cls=metadata.graphics.util.colour.UserColourType, keyword=Dark, atomic=Dark, atomic path=metadata.graphics.util.colour.UserColourType.Dark
~~m~ Red name=Red type=Constant (metadata.graphics.util.colour.UserColourType.Red) => <userColourType>, pack=metadata.graphics.util.colour, label=Red, cls=metadata.graphics.util.colour.UserColourType, keyword=Red, atomic=Red, atomic path=metadata.graphics.util.colour.UserColourType.Red
~~m~ Green name=Green type=Constant (metadata.graphics.util.colour.UserColourType.Green) => <userColourType>, pack=metadata.graphics.util.colour, label=Green, cls=metadata.graphics.util.colour.UserColourType, keyword=Green, atomic=Green, atomic path=metadata.graphics.util.colour.UserColourType.Green
~~m~ Blue name=Blue type=Constant (metadata.graphics.util.colour.UserColourType.Blue) => <userColourType>, pack=metadata.graphics.util.colour, label=Blue, cls=metadata.graphics.util.colour.UserColourType, keyword=Blue, atomic=Blue, atomic path=metadata.graphics.util.colour.UserColourType.Blue
~~m~ Yellow name=Yellow type=Constant (metadata.graphics.util.colour.UserColourType.Yellow) => <userColourType>, pack=metadata.graphics.util.colour, label=Yellow, cls=metadata.graphics.util.colour.UserColourType, keyword=Yellow, atomic=Yellow, atomic path=metadata.graphics.util.colour.UserColourType.Yellow
~~m~ Pink name=Pink type=Constant (metadata.graphics.util.colour.UserColourType.Pink) => <userColourType>, pack=metadata.graphics.util.colour, label=Pink, cls=metadata.graphics.util.colour.UserColourType, keyword=Pink, atomic=Pink, atomic path=metadata.graphics.util.colour.UserColourType.Pink
~~m~ Cyan name=Cyan type=Constant (metadata.graphics.util.colour.UserColourType.Cyan) => <userColourType>, pack=metadata.graphics.util.colour, label=Cyan, cls=metadata.graphics.util.colour.UserColourType, keyword=Cyan, atomic=Cyan, atomic path=metadata.graphics.util.colour.UserColourType.Cyan
~~m~ Brown name=Brown type=Constant (metadata.graphics.util.colour.UserColourType.Brown) => <userColourType>, pack=metadata.graphics.util.colour, label=Brown, cls=metadata.graphics.util.colour.UserColourType, keyword=Brown, atomic=Brown, atomic path=metadata.graphics.util.colour.UserColourType.Brown
~~m~ DarkBrown name=DarkBrown type=Constant (metadata.graphics.util.colour.UserColourType.DarkBrown) => <userColourType>, pack=metadata.graphics.util.colour, label=DarkBrown, cls=metadata.graphics.util.colour.UserColourType, keyword=DarkBrown, atomic=DarkBrown, atomic path=metadata.graphics.util.colour.UserColourType.DarkBrown
~~m~ VeryDarkBrown name=VeryDarkBrown type=Constant (metadata.graphics.util.colour.UserColourType.VeryDarkBrown) => <userColourType>, pack=metadata.graphics.util.colour, label=VeryDarkBrown, cls=metadata.graphics.util.colour.UserColourType, keyword=VeryDarkBrown, atomic=VeryDarkBrown, atomic path=metadata.graphics.util.colour.UserColourType.VeryDarkBrown
~~m~ Purple name=Purple type=Constant (metadata.graphics.util.colour.UserColourType.Purple) => <userColourType>, pack=metadata.graphics.util.colour, label=Purple, cls=metadata.graphics.util.colour.UserColourType, keyword=Purple, atomic=Purple, atomic path=metadata.graphics.util.colour.UserColourType.Purple
~~m~ Magenta name=Magenta type=Constant (metadata.graphics.util.colour.UserColourType.Magenta) => <userColourType>, pack=metadata.graphics.util.colour, label=Magenta, cls=metadata.graphics.util.colour.UserColourType, keyword=Magenta, atomic=Magenta, atomic path=metadata.graphics.util.colour.UserColourType.Magenta
~~m~ Turquoise name=Turquoise type=Constant (metadata.graphics.util.colour.UserColourType.Turquoise) => <userColourType>, pack=metadata.graphics.util.colour, label=Turquoise, cls=metadata.graphics.util.colour.UserColourType, keyword=Turquoise, atomic=Turquoise, atomic path=metadata.graphics.util.colour.UserColourType.Turquoise
~~m~ Orange name=Orange type=Constant (metadata.graphics.util.colour.UserColourType.Orange) => <userColourType>, pack=metadata.graphics.util.colour, label=Orange, cls=metadata.graphics.util.colour.UserColourType, keyword=Orange, atomic=Orange, atomic path=metadata.graphics.util.colour.UserColourType.Orange
~~m~ LightOrange name=LightOrange type=Constant (metadata.graphics.util.colour.UserColourType.LightOrange) => <userColourType>, pack=metadata.graphics.util.colour, label=LightOrange, cls=metadata.graphics.util.colour.UserColourType, keyword=LightOrange, atomic=LightOrange, atomic path=metadata.graphics.util.colour.UserColourType.LightOrange
~~m~ LightRed name=LightRed type=Constant (metadata.graphics.util.colour.UserColourType.LightRed) => <userColourType>, pack=metadata.graphics.util.colour, label=LightRed, cls=metadata.graphics.util.colour.UserColourType, keyword=LightRed, atomic=LightRed, atomic path=metadata.graphics.util.colour.UserColourType.LightRed
~~m~ DarkRed name=DarkRed type=Constant (metadata.graphics.util.colour.UserColourType.DarkRed) => <userColourType>, pack=metadata.graphics.util.colour, label=DarkRed, cls=metadata.graphics.util.colour.UserColourType, keyword=DarkRed, atomic=DarkRed, atomic path=metadata.graphics.util.colour.UserColourType.DarkRed
~~m~ Burgundy name=Burgundy type=Constant (metadata.graphics.util.colour.UserColourType.Burgundy) => <userColourType>, pack=metadata.graphics.util.colour, label=Burgundy, cls=metadata.graphics.util.colour.UserColourType, keyword=Burgundy, atomic=Burgundy, atomic path=metadata.graphics.util.colour.UserColourType.Burgundy
~~m~ LightGreen name=LightGreen type=Constant (metadata.graphics.util.colour.UserColourType.LightGreen) => <userColourType>, pack=metadata.graphics.util.colour, label=LightGreen, cls=metadata.graphics.util.colour.UserColourType, keyword=LightGreen, atomic=LightGreen, atomic path=metadata.graphics.util.colour.UserColourType.LightGreen
~~m~ DarkGreen name=DarkGreen type=Constant (metadata.graphics.util.colour.UserColourType.DarkGreen) => <userColourType>, pack=metadata.graphics.util.colour, label=DarkGreen, cls=metadata.graphics.util.colour.UserColourType, keyword=DarkGreen, atomic=DarkGreen, atomic path=metadata.graphics.util.colour.UserColourType.DarkGreen
~~m~ LightBlue name=LightBlue type=Constant (metadata.graphics.util.colour.UserColourType.LightBlue) => <userColourType>, pack=metadata.graphics.util.colour, label=LightBlue, cls=metadata.graphics.util.colour.UserColourType, keyword=LightBlue, atomic=LightBlue, atomic path=metadata.graphics.util.colour.UserColourType.LightBlue
~~m~ VeryLightBlue name=VeryLightBlue type=Constant (metadata.graphics.util.colour.UserColourType.VeryLightBlue) => <userColourType>, pack=metadata.graphics.util.colour, label=VeryLightBlue, cls=metadata.graphics.util.colour.UserColourType, keyword=VeryLightBlue, atomic=VeryLightBlue, atomic path=metadata.graphics.util.colour.UserColourType.VeryLightBlue
~~m~ DarkBlue name=DarkBlue type=Constant (metadata.graphics.util.colour.UserColourType.DarkBlue) => <userColourType>, pack=metadata.graphics.util.colour, label=DarkBlue, cls=metadata.graphics.util.colour.UserColourType, keyword=DarkBlue, atomic=DarkBlue, atomic path=metadata.graphics.util.colour.UserColourType.DarkBlue
~~m~ IceBlue name=IceBlue type=Constant (metadata.graphics.util.colour.UserColourType.IceBlue) => <userColourType>, pack=metadata.graphics.util.colour, label=IceBlue, cls=metadata.graphics.util.colour.UserColourType, keyword=IceBlue, atomic=IceBlue, atomic path=metadata.graphics.util.colour.UserColourType.IceBlue
~~m~ Gold name=Gold type=Constant (metadata.graphics.util.colour.UserColourType.Gold) => <userColourType>, pack=metadata.graphics.util.colour, label=Gold, cls=metadata.graphics.util.colour.UserColourType, keyword=Gold, atomic=Gold, atomic path=metadata.graphics.util.colour.UserColourType.Gold
~~m~ Silver name=Silver type=Constant (metadata.graphics.util.colour.UserColourType.Silver) => <userColourType>, pack=metadata.graphics.util.colour, label=Silver, cls=metadata.graphics.util.colour.UserColourType, keyword=Silver, atomic=Silver, atomic path=metadata.graphics.util.colour.UserColourType.Silver
~~m~ Bronze name=Bronze type=Constant (metadata.graphics.util.colour.UserColourType.Bronze) => <userColourType>, pack=metadata.graphics.util.colour, label=Bronze, cls=metadata.graphics.util.colour.UserColourType, keyword=Bronze, atomic=Bronze, atomic path=metadata.graphics.util.colour.UserColourType.Bronze
~~m~ GunMetal name=GunMetal type=Constant (metadata.graphics.util.colour.UserColourType.GunMetal) => <userColourType>, pack=metadata.graphics.util.colour, label=GunMetal, cls=metadata.graphics.util.colour.UserColourType, keyword=GunMetal, atomic=GunMetal, atomic path=metadata.graphics.util.colour.UserColourType.GunMetal
~~m~ HumanLight name=HumanLight type=Constant (metadata.graphics.util.colour.UserColourType.HumanLight) => <userColourType>, pack=metadata.graphics.util.colour, label=HumanLight, cls=metadata.graphics.util.colour.UserColourType, keyword=HumanLight, atomic=HumanLight, atomic path=metadata.graphics.util.colour.UserColourType.HumanLight
~~m~ HumanDark name=HumanDark type=Constant (metadata.graphics.util.colour.UserColourType.HumanDark) => <userColourType>, pack=metadata.graphics.util.colour, label=HumanDark, cls=metadata.graphics.util.colour.UserColourType, keyword=HumanDark, atomic=HumanDark, atomic path=metadata.graphics.util.colour.UserColourType.HumanDark
~~m~ Cream name=Cream type=Constant (metadata.graphics.util.colour.UserColourType.Cream) => <userColourType>, pack=metadata.graphics.util.colour, label=Cream, cls=metadata.graphics.util.colour.UserColourType, keyword=Cream, atomic=Cream, atomic path=metadata.graphics.util.colour.UserColourType.Cream
~~m~ DeepPurple name=DeepPurple type=Constant (metadata.graphics.util.colour.UserColourType.DeepPurple) => <userColourType>, pack=metadata.graphics.util.colour, label=DeepPurple, cls=metadata.graphics.util.colour.UserColourType, keyword=DeepPurple, atomic=DeepPurple, atomic path=metadata.graphics.util.colour.UserColourType.DeepPurple
~~m~ PinkFloyd name=PinkFloyd type=Constant (metadata.graphics.util.colour.UserColourType.PinkFloyd) => <userColourType>, pack=metadata.graphics.util.colour, label=PinkFloyd, cls=metadata.graphics.util.colour.UserColourType, keyword=PinkFloyd, atomic=PinkFloyd, atomic path=metadata.graphics.util.colour.UserColourType.PinkFloyd
~~m~ BlackSabbath name=BlackSabbath type=Constant (metadata.graphics.util.colour.UserColourType.BlackSabbath) => <userColourType>, pack=metadata.graphics.util.colour, label=BlackSabbath, cls=metadata.graphics.util.colour.UserColourType, keyword=BlackSabbath, atomic=BlackSabbath, atomic path=metadata.graphics.util.colour.UserColourType.BlackSabbath
~~m~ KingCrimson name=KingCrimson type=Constant (metadata.graphics.util.colour.UserColourType.KingCrimson) => <userColourType>, pack=metadata.graphics.util.colour, label=KingCrimson, cls=metadata.graphics.util.colour.UserColourType, keyword=KingCrimson, atomic=KingCrimson, atomic path=metadata.graphics.util.colour.UserColourType.KingCrimson
~~m~ TangerineDream name=TangerineDream type=Constant (metadata.graphics.util.colour.UserColourType.TangerineDream) => <userColourType>, pack=metadata.graphics.util.colour, label=TangerineDream, cls=metadata.graphics.util.colour.UserColourType, keyword=TangerineDream, atomic=TangerineDream, atomic path=metadata.graphics.util.colour.UserColourType.TangerineDream
~~m~ BabyBlue name=BabyBlue type=Constant (metadata.graphics.util.colour.UserColourType.BabyBlue) => <userColourType>, pack=metadata.graphics.util.colour, label=BabyBlue, cls=metadata.graphics.util.colour.UserColourType, keyword=BabyBlue, atomic=BabyBlue, atomic path=metadata.graphics.util.colour.UserColourType.BabyBlue
~~m~ LightTan name=LightTan type=Constant (metadata.graphics.util.colour.UserColourType.LightTan) => <userColourType>, pack=metadata.graphics.util.colour, label=LightTan, cls=metadata.graphics.util.colour.UserColourType, keyword=LightTan, atomic=LightTan, atomic path=metadata.graphics.util.colour.UserColourType.LightTan
~~m~ Hidden name=Hidden type=Constant (metadata.graphics.util.colour.UserColourType.Hidden) => <userColourType>, pack=metadata.graphics.util.colour, label=Hidden, cls=metadata.graphics.util.colour.UserColourType, keyword=Hidden, atomic=Hidden, atomic path=metadata.graphics.util.colour.UserColourType.Hidden
g~~* <int>{<int>} name=int type=Structural (int) => <int>{<int>}, pack=game.functions.ints, label=int, cls=int, keyword=int, atomic=int, atomic path=int


++++++++++++++++++++ RULES +++++++++++++++++++++++
gdm <int>      ::= <%> | <dim.math.*> | <ints.math.*> | <dim.math.+> | 
               <ints.math.+> | <dim.math.-> | <ints.math.-> | <dim.math./> | 
               <ints.math./> | End | Infinity | Off | Undefined | 
               <dim.math.^> | <ints.math.^> | <dim.math.abs> | 
               <ints.math.abs> | <ahead> | <amount> | <arrayValue> | 
               <iterator.between> | <card.card> | <centrePoint> | <column> | 
               <coord> | <cost> | <count.count> | <counter> | <iterator.edge> | 
               <dice.face> | <iterator.from> | <handSite> | <iterator.hint> | 
               <board.id> | <ints.math.if> | int | <ints.last.last> | <layer> | 
               <level> | <mapEntry> | <matchScore> | <dim.math.max> | 
               <ints.math.max> | <dim.math.min> | <ints.math.min> | <mover> | 
               <next> | <nextPhase> | <pathExtent> | <board.phase> | <pips> | 
               <iterator.player> | <pot> | <prev> | <regionSite> | <rotation> | 
               <row> | <state.score> | <site> | <size> | <state> | 
               <iterator.to> | <toInt> | <topLevel> | <iterator.track> | 
               <trackSite> | <value> | <var> | <what> | <where> | <who> [int] 
gdm <boolean>  ::= <!=> | <<> | <<=> | <=> | <>> | <>=> | <booleans.all.all> | 
               <deductionPuzzle.all.all> | <math.and> | boolean | <can> | 
               <forAll> | <booleans.math.if> | <deductionPuzzle.is.is> | 
               <booleans.is.is> | <booleans.no.no> | <not> | <math.or> | 
               <toBool> | <was> | <xor> [boolean] 
gdm <float>    ::= <floats.math.*> | <floats.math.+> | <floats.math.-> | 
               <floats.math./> | <floats.math.^> | <floats.math.abs> | <cos> | 
               <exp> | float | <log> | <log10> | <floats.math.max> | 
               <floats.math.min> | <sin> | <sqrt> | <tan> | <toFloat> [float] 
gdm <int>      ::= int [java.lang.Integer] 
gdm <boolean>  ::= boolean [java.lang.Boolean] 
gdm <float>    ::= float [java.lang.Float] 
gdm <string>   ::= string [java.lang.String] 
~~~ <aPI>      ::=  [game.API] 
gd~ <game>     ::= (game <string>) | 
               (game <string> <players> [<mode>] <equipment> <rules.rules>) | 
               <match> [game.Game] 
gd~ <equipment> ::= (equipment {<item>}) [game.equipment.Equipment] 
g~~ <item>     ::= <component> | <container> | <dominoes> | <hints> | <map> | 
               <regions> [game.equipment.Item] 
gd~ <component.card> ::= (card <string> <roleType> <cardType> rank:<int> value:<int> trumpRank:<int> trumpValue:<int> suit:<int> [<moves>] [maxState:<int>] [maxCount:<int>] [maxValue:<int>]) [game.equipment.component.Card] 
gd~ <component> ::= (component <string> <roleType> {{<stepType>}} <directionFacing> <moves> <int> <int> <int>) 
               | <component.card> | <die> | <domino> | <component.piece> | 
               <tile> [game.equipment.component.Component] 
gd~ <die>      ::= (die <string> <roleType> numFaces:<int> [<directionFacing>] [<moves>]) [game.equipment.component.Die] 
gd~ <component.piece> ::= (piece <string> [<roleType>] [<directionFacing>] [<flips>] [<moves>] [maxState:<int>] [maxCount:<int>] [maxValue:<int>]) [game.equipment.component.Piece] 
gd~ <domino>   ::= (domino <string> <roleType> value:<int> value2:<int> [<moves>]) [game.equipment.component.tile.Domino] 
gd~ <path>     ::= (path from:<int> [slotsFrom:<int>] to:<int> [slotsTo:<int>] colour:<int>) [game.equipment.component.tile.Path] 
gd~ <tile>     ::= (tile <string> [<roleType>] [{<stepType>} | 
               {{<stepType>}}] [numSides:<int>] [slots:{<int>} | 
               slotsPerSide:<int>] [{<path>}] [<flips>] [<moves>] [maxState:<int>] [maxCount:<int>] [maxValue:<int>]) [game.equipment.component.tile.Tile] 
g~~ <container> ::= <container.board.board> | <deck> | <dice> | <other.hand> [game.equipment.container.Container] 
gd~ <container.board.board> ::= (board <graph> [<board.track> | 
               {<board.track>}] [<equipment.values> | 
               {<equipment.values>}] [use:<siteType>] [largeStack:<boolean>]) | 
               <boardless> | <mancalaBoard> | <surakartaBoard> [game.equipment.container.board.Board] 
gd~ <boardless> ::= (boardless <tilingBoardlessType> [<dim>] [largeStack:<boolean>]) [game.equipment.container.board.Boardless] 
gd~ <board.track> ::= (track <string> ({<int>} | <string> | 
               {<equipment.trackStep>}) [loop:<boolean>] [<int> | 
               <roleType>] [directed:<boolean>]) [game.equipment.container.board.Track] 
gd~ <mancalaBoard> ::= (mancalaBoard <int> <int> [store:<storeType>] [numStores:<int>] [largeStack:<boolean>] [<board.track> 
               | {<board.track>}]) [game.equipment.container.board.custom.MancalaBoard] 
gd~ <surakartaBoard> ::= (surakartaBoard <graph> [loops:<int>] [from:<int>] [largeStack:<boolean>]) [game.equipment.container.board.custom.SurakartaBoard] 
gd~ <deck>     ::= (deck [<roleType>] [cardsBySuit:<int>] [suits:<int>] [{<equipment.card>}]) [game.equipment.container.other.Deck] 
gd~ <dice>     ::= (dice [d:<int>] [faces:{<int>} | facesByDie:{{<int>}} | 
               from:<int>] [<roleType>] num:<int> [biased:{<int>}]) [game.equipment.container.other.Dice] 
gd~ <other.hand> ::= (hand <roleType> [size:<int>]) [game.equipment.container.other.Hand] 
gd~ <dominoes> ::= (dominoes [upTo:<int>]) [game.equipment.other.Dominoes] 
gd~ <hints>    ::= (hints [<string>] {<equipment.hint>} [<siteType>]) [game.equipment.other.Hints] 
gd~ <map>      ::= (map [<string>] {<int>} {<int>}) | (map [<string>] {<math.pair>}) [game.equipment.other.Map] 
gd~ <regions>  ::= (regions [<string>] [<roleType>] ({<int>} | <sites> | {<sites>} | 
               <regionTypeStatic> | {<regionTypeStatic>}) [<string>]) [game.equipment.other.Regions] 
~~~ <baseBooleanFunction> ::= <!=> | <<> | <<=> | <=> | <>> | <>=> | 
               <booleans.all.all> | <deductionPuzzle.all.all> | <math.and> | 
               <can> | <forAll> | <booleans.math.if> | 
               <deductionPuzzle.is.is> | <booleans.is.is> | <booleans.no.no> | 
               <not> | <math.or> | <toBool> | <was> | <xor> [game.functions.booleans.BaseBooleanFunction] 
g~~ <boolean>  ::=  [game.functions.booleans.BooleanFunction] 
gd~ <toBool>   ::= (toBool (<int> | <float>)) [game.functions.booleans.ToBool] 
gd~ <booleans.all.all> ::= (all Values <ints> if:<boolean>) | 
               (all <allSitesType> <sites> if:<boolean>) | 
               (all <allSimpleType>) | 
               (all Groups [<siteType>] [<direction>] [of:<boolean>] if:<boolean>) [game.functions.booleans.all.All] 
g~~ <allSimpleType> ::= DiceEqual | DiceUsed | Passed [game.functions.booleans.all.AllSimpleType] 
g~~ <allSitesType> ::= Different | Sites [game.functions.booleans.all.AllSitesType] 
gd~ <can>      ::= (can Move <moves>) [game.functions.booleans.can.Can] 
gd~ <forAll>   ::= (forAll <puzzleElementType> <boolean>) [game.functions.booleans.deductionPuzzle.ForAll] 
gd~ <deductionPuzzle.all.all> ::= (all Different [<siteType>] [<sites>] [except:<int> 
               | excepts:{<int>}]) [game.functions.booleans.deductionPuzzle.all.All] 
gd~ <deductionPuzzle.is.is> ::= (is Unique [<siteType>]) | 
               (is <isPuzzleRegionResultType> [<siteType>] [<sites>] [of:<int>] [<string>] <int>) 
               | (is Solved) [game.functions.booleans.deductionPuzzle.is.Is] 
g~~ <isPuzzleRegionResultType> ::= Count | Sum [game.functions.booleans.deductionPuzzle.is.IsPuzzleRegionResultType] 
gd~ <booleans.is.is> ::= (is <isSimpleType>) | (is Triggered <string> (<int> | 
               <roleType>)) | (is <isPlayerType> (<int> | <roleType>)) | 
               (is Crossing <int> <int>) | (is <isStringType> <string>) | 
               (is <isGraphType> <siteType>) | 
               (is <isAngleType> [<siteType>] at:<int> <boolean> <boolean>) | 
               (is Hidden [<hiddenData>] [<siteType>] at:<int> [level:<int>] (to:<moves.player> 
               | to:<roleType>)) | (is Repeat [<repetitionType>]) | 
               (is Pattern {<stepType>} [<siteType>] [from:<int>] [what:<int> | 
               whats:{<int>}]) | (is <isTreeType> (<moves.player> | 
               <roleType>)) | (is RegularGraph (<moves.player> | 
               <roleType>) [k:<int> | odd:<boolean> | even:<boolean>]) | 
               (is Line [<siteType>] <int> [<absoluteDirection>] [through:<int> 
               | throughAny:<sites>] [<roleType> | what:<int> | 
               whats:{<int>}] [exact:<boolean>] [contiguous:<boolean>] [if:<boolean>] [byLevel:<boolean>] [top:<boolean>]) 
               | (is Loop [<siteType>] [surround:<roleType> | 
               {<roleType>}] [<direction>] [<int>] [<int> | 
               <sites>] [path:<boolean>]) | 
               (is Path <siteType> [from:<int>] (<moves.player> | 
               <roleType>) length:<range> [closed:<boolean>]) | 
               (is <isSiteType> [<siteType>] <int>) | (is In [<int> | 
               {<int>}] (<sites> | <ints>)) | (is <isIntegerType> [<int>]) | 
               (is <isComponentType> [<int>] [<siteType>] [at:<int> | 
               in:<sites>] [<moves>]) | 
               (is <isConnectType> [<int>] [<siteType>] [at:<int>] [<direction>] ({<sites>} 
               | <roleType> | <regionTypeStatic>)) | (is Target [<int> | 
               <string>] {<int>} [<int> | {<int>}]) | 
               (is Related <relationType> [<siteType>] <int> (<int> | <sites>)) [game.functions.booleans.is.Is] 
g~~ <isAngleType> ::= Acute | Obtuse | Reflex | Right [game.functions.booleans.is.IsAngleType] 
g~~ <isComponentType> ::= Threatened | Within [game.functions.booleans.is.IsComponentType] 
g~~ <isConnectType> ::= Blocked | Connected [game.functions.booleans.is.IsConnectType] 
g~~ <isGraphType> ::= LastFrom | LastTo [game.functions.booleans.is.IsGraphType] 
g~~ <isIntegerType> ::= AnyDie | Even | Flat | Odd | PipsMatch | SidesMatch | Visited [game.functions.booleans.is.IsIntegerType] 
g~~ <isPlayerType> ::= Active | Enemy | Friend | Mover | Next | Prev [game.functions.booleans.is.IsPlayerType] 
g~~ <isSimpleType> ::= Cycle | Full | Pending [game.functions.booleans.is.IsSimpleType] 
g~~ <isSiteType> ::= Empty | Occupied [game.functions.booleans.is.IsSiteType] 
g~~ <isStringType> ::= Decided | Proposed [game.functions.booleans.is.IsStringType] 
g~~ <isTreeType> ::= CaterpillarTree | SpanningTree | Tree | TreeCentre [game.functions.booleans.is.IsTreeType] 
gd~ <math.and> ::= (and {<boolean>}) | (and <boolean> <boolean>) [game.functions.booleans.math.And] 
gd~ <=>        ::= (= <sites> <sites>) | (= <int> (<int> | <roleType>)) [game.functions.booleans.math.Equals] 
gd~ <>=>       ::= (>= <int> <int>) [game.functions.booleans.math.Ge] 
gd~ <>>        ::= (> <int> <int>) [game.functions.booleans.math.Gt] 
gd~ <booleans.math.if> ::= (if <boolean> <boolean> [<boolean>]) [game.functions.booleans.math.If] 
gd~ <<=>       ::= (<= <int> <int>) [game.functions.booleans.math.Le] 
gd~ <<>        ::= (< <int> <int>) [game.functions.booleans.math.Lt] 
gd~ <not>      ::= (not <boolean>) [game.functions.booleans.math.Not] 
gd~ <!=>       ::= (!= <sites> <sites>) | (!= <int> (<int> | <roleType>)) [game.functions.booleans.math.NotEqual] 
gd~ <math.or>  ::= (or {<boolean>}) | (or <boolean> <boolean>) [game.functions.booleans.math.Or] 
gd~ <xor>      ::= (xor <boolean> <boolean>) [game.functions.booleans.math.Xor] 
gd~ <booleans.no.no> ::= (no Moves <roleType>) | 
               (no Pieces [<siteType>] [<roleType> | 
               of:<int>] [<string>] [in:<sites>]) [game.functions.booleans.no.No] 
gd~ <was>      ::= (was Pass) [game.functions.booleans.was.Was] 
gd~ <dim>      ::= <dim.math.*> | <dim.math.+> | <dim.math.-> | <dim.math./> | 
               <dim.math.^> | <dim.math.abs> | int | <dim.math.max> | 
               <dim.math.min> [game.functions.dim.BaseDimFunction] 
g~~ <dim>      ::=  [game.functions.dim.DimFunction] 
gd~ <dim.math.abs> ::= (abs <dim>) [game.functions.dim.math.Abs] 
gd~ <dim.math.+> ::= (+ {<dim>}) | (+ <dim> <dim>) [game.functions.dim.math.Add] 
gd~ <dim.math./> ::= (/ <dim> <dim>) [game.functions.dim.math.Div] 
gd~ <dim.math.max> ::= (max <dim> <dim>) [game.functions.dim.math.Max] 
gd~ <dim.math.min> ::= (min <dim> <dim>) [game.functions.dim.math.Min] 
gd~ <dim.math.*> ::= (* {<dim>}) | (* <dim> <dim>) [game.functions.dim.math.Mul] 
gd~ <dim.math.^> ::= (^ <dim> <dim>) [game.functions.dim.math.Pow] 
gd~ <dim.math.-> ::= (- <dim> <dim>) [game.functions.dim.math.Sub] 
gd~ <directions.difference> ::= (difference <direction> <direction>) [game.functions.directions.Difference] 
gd~ <directions> ::= (directions (<absoluteDirection> | {<absoluteDirection>})) | 
               (directions [<relativeDirection> | 
               {<relativeDirection>}] [of:<relationType>] [bySite:<boolean>]) | 
               (directions <siteType> from:<int> to:<int>) | 
               (directions Random <direction> num:<int>) [game.functions.directions.Directions] 
~~~ <directions> ::= <directions.difference> | <directions> | <directions.if> | 
               <directions.union> [game.functions.directions.DirectionsFunction] 
gd~ <directions.if> ::= (if <boolean> <direction> <direction>) [game.functions.directions.If] 
gd~ <directions.union> ::= (union <direction> <direction>) [game.functions.directions.Union] 
~~~ <baseFloatFunction> ::= <floats.math.*> | <floats.math.+> | <floats.math.-> | 
               <floats.math./> | <floats.math.^> | <floats.math.abs> | <cos> | 
               <exp> | <log> | <log10> | <floats.math.max> | 
               <floats.math.min> | <sin> | <sqrt> | <tan> | <toFloat> [game.functions.floats.BaseFloatFunction] 
g~~ <float>    ::=  [game.functions.floats.FloatFunction] 
gd~ <toFloat>  ::= (toFloat (<boolean> | <int>)) [game.functions.floats.ToFloat] 
gd~ <floats.math.abs> ::= (abs <float>) [game.functions.floats.math.Abs] 
gd~ <floats.math.+> ::= (+ {<float>}) | (+ <float> <float>) [game.functions.floats.math.Add] 
gd~ <cos>      ::= (cos <float>) [game.functions.floats.math.Cos] 
gd~ <floats.math./> ::= (/ <float> <float>) [game.functions.floats.math.Div] 
gd~ <exp>      ::= (exp <float>) [game.functions.floats.math.Exp] 
gd~ <log>      ::= (log <float>) [game.functions.floats.math.Log] 
gd~ <log10>    ::= (log10 <float>) [game.functions.floats.math.Log10] 
gd~ <floats.math.max> ::= (max {<float>}) | (max <float> <float>) [game.functions.floats.math.Max] 
gd~ <floats.math.min> ::= (min {<float>}) | (min <float> <float>) [game.functions.floats.math.Min] 
gd~ <floats.math.*> ::= (* {<float>}) | (* <float> <float>) [game.functions.floats.math.Mul] 
gd~ <floats.math.^> ::= (^ <float> <float>) [game.functions.floats.math.Pow] 
gd~ <sin>      ::= (sin <float>) [game.functions.floats.math.Sin] 
gd~ <sqrt>     ::= (sqrt <float>) [game.functions.floats.math.Sqrt] 
gd~ <floats.math.-> ::= (- <float> <float>) [game.functions.floats.math.Sub] 
gd~ <tan>      ::= (tan <float>) [game.functions.floats.math.Tan] 
g~~ <graph>    ::=  [game.functions.graph.GraphFunction] 
g~~ <basis>    ::= <brick> | <celtic> | <concentric> | <hex> | <quadhex> | 
               <rectangle> | <spiral> | <square> | <tiling> | <tri> | <wedge> [game.functions.graph.generators.basis.Basis] 
gd~ <brick>    ::= (brick [<brickShapeType>] <dim> [<dim>] [trim:<boolean>]) [game.functions.graph.generators.basis.brick.Brick] 
g~~ <brickShapeType> ::= Diamond | Limping | Prism | Rectangle | Spiral | Square [game.functions.graph.generators.basis.brick.BrickShapeType] 
gd~ <celtic>   ::= (celtic (<poly> | {<dim>})) | (celtic <dim> [<dim>]) [game.functions.graph.generators.basis.celtic.Celtic] 
gd~ <hex>      ::= (hex (<poly> | {<dim>})) | (hex [<hexShapeType>] <dim> [<dim>]) [game.functions.graph.generators.basis.hex.Hex] 
g~~ <hexShapeType> ::= Diamond | Hexagon | Limping | NoShape | Prism | Rectangle | 
               Square | Star | Triangle [game.functions.graph.generators.basis.hex.HexShapeType] 
gd~ <quadhex>  ::= (quadhex <dim> [thirds:<boolean>]) [game.functions.graph.generators.basis.quadhex.Quadhex] 
g~~ <diagonalsType> ::= Alternating | Concentric | Implied | Radiating | Solid | 
               SolidNoSplit [game.functions.graph.generators.basis.square.DiagonalsType] 
gd~ <square>   ::= (square (<poly> | {<dim>}) [diagonals:<diagonalsType>]) | 
               (square [<squareShapeType>] <dim> [diagonals:<diagonalsType> | 
               pyramidal:<boolean>]) [game.functions.graph.generators.basis.square.Square] 
g~~ <squareShapeType> ::= Diamond | Limping | NoShape | Rectangle | Square [game.functions.graph.generators.basis.square.SquareShapeType] 
gd~ <tiling>   ::= (tiling <tilingType> (<poly> | {<dim>})) | 
               (tiling <tilingType> <dim> [<dim>]) [game.functions.graph.generators.basis.tiling.Tiling] 
g~~ <tilingType> ::= T31212 | T333333_33434 | T33336 | T33344 | T33434 | T3464 | 
               T3636 | T4612 | T488 [game.functions.graph.generators.basis.tiling.TilingType] 
~~~ <tiling3464ShapeType> ::= Custom | Diamond | Hexagon | Limping | Prism | 
               Rectangle | Square | Star | Triangle [game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType] 
gd~ <tri>      ::= (tri [<triShapeType>] <dim> [<dim>]) | (tri (<poly> | {<dim>})) [game.functions.graph.generators.basis.tri.Tri] 
g~~ <triShapeType> ::= Diamond | Hexagon | Limping | NoShape | Prism | Rectangle | 
               Square | Star | Triangle [game.functions.graph.generators.basis.tri.TriShapeType] 
gd~ <rectangle> ::= (rectangle <dim> [<dim>] [diagonals:<diagonalsType>]) [game.functions.graph.generators.shape.Rectangle] 
gd~ <regular>  ::= (regular <basisType> <shapeType> <dim> [<dim>]) | 
               (regular [Star] <dim>) [game.functions.graph.generators.shape.Regular] 
gd~ <repeat>   ::= (repeat <dim> <dim> step:{{<float>}} (<poly> | {<poly>})) [game.functions.graph.generators.shape.Repeat] 
gd~ <spiral>   ::= (spiral turns:<dim> sites:<dim> [clockwise:<boolean>]) [game.functions.graph.generators.shape.Spiral] 
gd~ <wedge>    ::= (wedge <dim> [<dim>]) [game.functions.graph.generators.shape.Wedge] 
gd~ <concentric> ::= (concentric (<concentricShapeType> | sides:<dim> | 
               {<dim>}) [rings:<dim>] [steps:<dim>] [midpoints:<boolean>] [joinMidpoints:<boolean>] [joinCorners:<boolean>] [stagger:<boolean>]) [game.functions.graph.generators.shape.concentric.Concentric] 
g~~ <concentricShapeType> ::= Hexagon | Square | Target | Triangle [game.functions.graph.generators.shape.concentric.ConcentricShapeType] 
gd~ <operators.add> ::= (add [<graph>] [vertices:{{<float>}}] [edges:{{{<float>}}} | 
               edges:{{<dim>}}] [edgesCurved:{{{<float>}}}] [cells:{{{<float>}}} 
               | cells:{{<dim>}}] [connect:<boolean>]) [game.functions.graph.operators.Add] 
gd~ <clip>     ::= (clip <graph> <poly>) [game.functions.graph.operators.Clip] 
gd~ <complete> ::= (complete <graph> [eachCell:<boolean>]) [game.functions.graph.operators.Complete] 
gd~ <dual>     ::= (dual <graph>) [game.functions.graph.operators.Dual] 
gd~ <hole>     ::= (hole <graph> <poly>) [game.functions.graph.operators.Hole] 
gd~ <intersect> ::= (intersect {<graph>}) | (intersect <graph> <graph>) [game.functions.graph.operators.Intersect] 
gd~ <keep>     ::= (keep <graph> <poly>) [game.functions.graph.operators.Keep] 
gd~ <layers>   ::= (layers <dim> <graph>) [game.functions.graph.operators.Layers] 
gd~ <makeFaces> ::= (makeFaces <graph>) [game.functions.graph.operators.MakeFaces] 
gd~ <merge>    ::= (merge {<graph>} [connect:<boolean>]) | 
               (merge <graph> <graph> [connect:<boolean>]) [game.functions.graph.operators.Merge] 
gd~ <recoordinate> ::= (recoordinate [<siteType>] [<siteType>] [<siteType>] <graph>) [game.functions.graph.operators.Recoordinate] 
gd~ <operators.remove> ::= (remove <graph> <poly> [trimEdges:<boolean>]) | 
               (remove <graph> [cells:{{{<float>}}} | 
               cells:{<dim>}] [edges:{{{<float>}}} | 
               edges:{{<dim>}}] [vertices:{{<float>}} | 
               vertices:{<dim>}] [trimEdges:<boolean>]) [game.functions.graph.operators.Remove] 
gd~ <renumber> ::= (renumber [<siteType>] [<siteType>] [<siteType>] <graph>) [game.functions.graph.operators.Renumber] 
gd~ <rotate>   ::= (rotate <float> <graph>) [game.functions.graph.operators.Rotate] 
gd~ <scale>    ::= (scale <float> [<float>] [<float>] <graph>) [game.functions.graph.operators.Scale] 
gd~ <shift>    ::= (shift <float> <float> [<float>] <graph>) [game.functions.graph.operators.Shift] 
gd~ <skew>     ::= (skew <float> <graph>) [game.functions.graph.operators.Skew] 
gd~ <splitCrossings> ::= (splitCrossings <graph>) [game.functions.graph.operators.SplitCrossings] 
gd~ <subdivide> ::= (subdivide <graph> [min:<dim>]) [game.functions.graph.operators.Subdivide] 
gd~ <trim>     ::= (trim <graph>) [game.functions.graph.operators.Trim] 
gd~ <operators.union> ::= (union {<graph>} [connect:<boolean>]) | 
               (union <graph> <graph> [connect:<boolean>]) [game.functions.graph.operators.Union] 
~~~ <baseIntArrayFunction> ::= <array> | <intArray.math.difference> | 
               <intArray.math.if> | <intArray.math.intersection> | 
               <intArray.players.players> | <results> | <rotations> | <sizes> | 
               <team> | <intArray.math.union> | <values.values> [game.functions.intArray.BaseIntArrayFunction] 
g~~ <ints>     ::=  [game.functions.intArray.IntArrayFunction] 
gd~ <array>    ::= (array {<int>}) | (array <sites>) [game.functions.intArray.array.Array] 
gd~ <team>     ::= (team) [game.functions.intArray.iteraror.Team] 
gd~ <intArray.math.difference> ::= (difference <ints> (<ints> | <int>)) [game.functions.intArray.math.Difference] 
gd~ <intArray.math.if> ::= (if <boolean> <ints> [<ints>]) [game.functions.intArray.math.If] 
gd~ <intArray.math.intersection> ::= (intersection {<ints>}) | 
               (intersection <ints> <ints>) [game.functions.intArray.math.Intersection] 
gd~ <results>  ::= (results (from:<int> | from:<sites>) (to:<int> | 
               to:<sites>) <int>) [game.functions.intArray.math.Results] 
gd~ <intArray.math.union> ::= (union {<ints>}) | (union <ints> <ints>) [game.functions.intArray.math.Union] 
gd~ <intArray.players.players> ::= (players <playersTeamType> [if:<boolean>]) | 
               (players <playersManyType> [of:<int>] [if:<boolean>]) [game.functions.intArray.players.Players] 
g~~ <playersManyType> ::= All | Ally | Enemy | Friend | NonMover [game.functions.intArray.players.PlayersManyType] 
g~~ <playersTeamType> ::= Team1 | Team10 | Team11 | Team12 | Team13 | Team14 | 
               Team15 | Team16 | Team2 | Team3 | Team4 | Team5 | Team6 | 
               Team7 | Team8 | Team9 [game.functions.intArray.players.PlayersTeamType] 
gd~ <sizes>    ::= (sizes Group [<siteType>] [<direction>] [<roleType> | of:<int> | 
               if:<boolean>] [min:<int>]) [game.functions.intArray.sizes.Sizes] 
gd~ <rotations> ::= (rotations (<absoluteDirection> | {<absoluteDirection>})) [game.functions.intArray.state.Rotations] 
gd~ <values.values> ::= (values Remembered [<string>]) [game.functions.intArray.values.Values] 
~~~ <baseIntFunction> ::= <%> | <ints.math.*> | <ints.math.+> | <ints.math.-> | 
               <ints.math./> | <ints.math.^> | <ints.math.abs> | <ahead> | 
               <amount> | <arrayValue> | <iterator.between> | <card.card> | 
               <centrePoint> | <column> | <coord> | <cost> | <count.count> | 
               <counter> | <iterator.edge> | <dice.face> | <iterator.from> | 
               <handSite> | <iterator.hint> | <board.id> | <ints.math.if> | 
               <ints.last.last> | <layer> | <level> | <mapEntry> | 
               <matchScore> | <ints.math.max> | <ints.math.min> | <mover> | 
               <next> | <nextPhase> | <pathExtent> | <board.phase> | <pips> | 
               <iterator.player> | <pot> | <prev> | <regionSite> | <rotation> | 
               <row> | <state.score> | <site> | <size> | <state> | 
               <iterator.to> | <toInt> | <topLevel> | <iterator.track> | 
               <trackSite> | <value> | <var> | <what> | <where> | <who> [game.functions.ints.BaseIntFunction] 
g~m <int>      ::=  [game.functions.ints.IntFunction] 
gd~ <toInt>    ::= (toInt (<boolean> | <float>)) [game.functions.ints.ToInt] 
gd~ <ahead>    ::= (ahead [<siteType>] <int> [steps:<int>] [<direction>]) [game.functions.ints.board.Ahead] 
gd~ <arrayValue> ::= (arrayValue <ints> index:<int>) [game.functions.ints.board.ArrayValue] 
gd~ <centrePoint> ::= (centrePoint [<siteType>]) [game.functions.ints.board.CentrePoint] 
gd~ <column>   ::= (column [<siteType>] of:<int>) [game.functions.ints.board.Column] 
gd~ <coord>    ::= (coord [<siteType>] row:<int> column:<int>) | 
               (coord [<siteType>] <string>) [game.functions.ints.board.Coord] 
gd~ <cost>     ::= (cost [<siteType>] (at:<int> | in:<sites>)) [game.functions.ints.board.Cost] 
gd~ <handSite> ::= (handSite (<int> | <roleType>) [<int>]) [game.functions.ints.board.HandSite] 
gd~ <board.id> ::= (id <string>) | (id [<string>] <roleType>) [game.functions.ints.board.Id] 
gd~ <layer>    ::= (layer of:<int> [<siteType>]) [game.functions.ints.board.Layer] 
gd~ <mapEntry> ::= (mapEntry [<string>] (<int> | <roleType>)) [game.functions.ints.board.MapEntry] 
gd~ <board.phase> ::= (phase [<siteType>] of:<int>) [game.functions.ints.board.Phase] 
gd~ <regionSite> ::= (regionSite <sites> index:<int>) [game.functions.ints.board.RegionSite] 
gd~ <row>      ::= (row [<siteType>] of:<int>) [game.functions.ints.board.Row] 
gd~ <where>    ::= (where Level <int> [<siteType>] at:<int> [fromTop:<boolean>]) | 
               (where Level <string> (<int> | 
               <roleType>) [state:<int>] [<siteType>] at:<int> [fromTop:<boolean>]) 
               | (where <int> [<siteType>]) | (where <string> (<int> | 
               <roleType>) [state:<int>] [<siteType>]) [game.functions.ints.board.where.Where] 
gd~ <card.card> ::= (card <cardSiteType> at:<int> [level:<int>]) | (card TrumpSuit) [game.functions.ints.card.Card] 
g~~ <cardSiteType> ::= Rank | Suit | TrumpRank | TrumpValue [game.functions.ints.card.CardSiteType] 
gd~ <count.count> ::= (count Groups [<siteType>] [<direction>] [if:<boolean>] [min:<int>]) 
               | (count <countComponentType> [<siteType>] [<roleType> | 
               of:<int>] [<string>] [in:<sites>] [if:<boolean>]) | 
               (count [<countSiteType>] [<siteType>] [in:<sites> | at:<int> | 
               <string>]) | (count <countSimpleType> [<siteType>]) | 
               (count Value <int> in:<ints>) | 
               (count Stack [<stackDirection>] [<siteType>] (at:<int> | 
               to:<sites>) [if:<boolean>] [stop:<boolean>]) | 
               (count StepsOnTrack [<roleType> | <moves.player> | 
               <string>] [<int>] [<int>]) | 
               (count Steps [<siteType>] [<relationType>] [<effect.step>] [newRotation:<int>] <int> (<int> 
               | <sites>)) | 
               (count Liberties [<siteType>] [at:<int>] [<direction>] [if:<boolean>]) [game.functions.ints.count.Count] 
g~~ <countComponentType> ::= Pieces | Pips [game.functions.ints.count.CountComponentType] 
g~~ <countSimpleType> ::= Active | Cells | Columns | Edges | LegalMoves | Moves | 
               MovesThisTurn | Phases | Players | Rows | Trials | Turns | 
               Vertices [game.functions.ints.count.CountSimpleType] 
g~~ <countSiteType> ::= Adjacent | Diagonal | Neighbours | Off | Orthogonal | Sites [game.functions.ints.count.CountSiteType] 
gd~ <dice.face> ::= (face <int>) [game.functions.ints.dice.Face] 
gd~ <iterator.between> ::= (between) [game.functions.ints.iterator.Between] 
gd~ <iterator.edge> ::= (edge) | (edge <int> <int>) [game.functions.ints.iterator.Edge] 
gd~ <iterator.from> ::= (from [at:<whenType>]) [game.functions.ints.iterator.From] 
gd~ <iterator.hint> ::= (hint [<siteType>] [at:<int>]) [game.functions.ints.iterator.Hint] 
gd~ <level>    ::= (level) [game.functions.ints.iterator.Level] 
gd~ <pips>     ::= (pips) [game.functions.ints.iterator.Pips] 
gd~ <iterator.player> ::= (player) [game.functions.ints.iterator.Player] 
gd~ <site>     ::= (site) [game.functions.ints.iterator.Site] 
gd~ <iterator.to> ::= (to) [game.functions.ints.iterator.To] 
gd~ <iterator.track> ::= (track) [game.functions.ints.iterator.Track] 
gd~ <ints.last.last> ::= (last <lastType> [afterConsequence:<boolean>]) [game.functions.ints.last.Last] 
g~~ <lastType> ::= From | LevelFrom | LevelTo | To [game.functions.ints.last.LastType] 
gd~ <matchScore> ::= (matchScore <roleType>) [game.functions.ints.match.MatchScore] 
gd~ <ints.math.abs> ::= (abs <int>) [game.functions.ints.math.Abs] 
gd~ <ints.math.+> ::= (+ ({<int>} | <ints>)) | (+ <int> <int>) [game.functions.ints.math.Add] 
gd~ <ints.math./> ::= (/ <int> <int>) [game.functions.ints.math.Div] 
gd~ <ints.math.if> ::= (if <boolean> <int> <int>) [game.functions.ints.math.If] 
gd~ <ints.math.max> ::= (max <ints>) | (max <int> <int>) [game.functions.ints.math.Max] 
gd~ <ints.math.min> ::= (min <ints>) | (min <int> <int>) [game.functions.ints.math.Min] 
gd~ <%>        ::= (% <int> <int>) [game.functions.ints.math.Mod] 
gd~ <ints.math.*> ::= (* ({<int>} | <ints>)) | (* <int> <int>) [game.functions.ints.math.Mul] 
gd~ <ints.math.^> ::= (^ <int> <int>) [game.functions.ints.math.Pow] 
gd~ <ints.math.-> ::= (- [<int>] <int>) [game.functions.ints.math.Sub] 
gd~ <size>     ::= (size Group [<siteType>] at:<int> [<direction>] [if:<boolean>]) | 
               (size LargePiece [<siteType>] (in:<sites> | at:<int>)) | 
               (size Stack [<siteType>] [in:<sites> | at:<int>]) | 
               (size Territory [<siteType>] (<roleType> | 
               <moves.player>) [<absoluteDirection>]) | (size Array <ints>) [game.functions.ints.size.Size] 
gd~ <topLevel> ::= (topLevel [<siteType>] at:<int>) [game.functions.ints.stacking.TopLevel] 
gd~ <amount>   ::= (amount (<roleType> | <moves.player>)) [game.functions.ints.state.Amount] 
gd~ <counter>  ::= (counter) [game.functions.ints.state.Counter] 
gd~ <mover>    ::= (mover) [game.functions.ints.state.Mover] 
gd~ <next>     ::= (next) [game.functions.ints.state.Next] 
gd~ <pot>      ::= (pot) [game.functions.ints.state.Pot] 
gd~ <prev>     ::= (prev [<prevType>]) [game.functions.ints.state.Prev] 
gd~ <rotation> ::= (rotation [<siteType>] at:<int> [level:<int>]) [game.functions.ints.state.Rotation] 
gd~ <state.score> ::= (score (<moves.player> | <roleType>)) [game.functions.ints.state.Score] 
gd~ <state>    ::= (state [<siteType>] at:<int> [level:<int>]) [game.functions.ints.state.State] 
gd~ <var>      ::= (var [<string>]) [game.functions.ints.state.Var] 
gd~ <what>     ::= (what [<siteType>] at:<int> [level:<int>]) [game.functions.ints.state.What] 
gd~ <who>      ::= (who [<siteType>] at:<int> [level:<int>]) [game.functions.ints.state.Who] 
gd~ <pathExtent> ::= (pathExtent [<int>] [<int> | <sites>]) [game.functions.ints.tile.PathExtent] 
gd~ <trackSite> ::= (trackSite EndSite [<moves.player> | <roleType>] [<string>]) | 
               (trackSite Move [from:<int>] [<roleType> | <moves.player> | 
               <string>] steps:<int>) | (trackSite FirstSite [<moves.player> | 
               <roleType>] [<string>] [from:<int>] [if:<boolean>]) [game.functions.ints.trackSite.TrackSite] 
gd~ <value>    ::= (value Piece [<siteType>] at:<int> [level:<int>]) | 
               (value Player (<int> | <roleType>)) | 
               (value <valueSimpleType>) | (value) | (value Random <range>) [game.functions.ints.value.Value] 
g~~ <valueSimpleType> ::= MoveLimit | Pending | TurnLimit [game.functions.ints.value.ValueSimpleType] 
gd~ <range>    ::= (range <int> [<int>]) | <exact> | <range.math.max> | 
               <range.math.min> [game.functions.range.Range] 
g~~ <range>    ::=  [game.functions.range.RangeFunction] 
gd~ <exact>    ::= (exact <int>) [game.functions.range.math.Exact] 
gd~ <range.math.max> ::= (max <int>) [game.functions.range.math.Max] 
gd~ <range.math.min> ::= (min <int>) [game.functions.range.math.Min] 
g~m <sites>    ::=  [game.functions.region.RegionFunction] 
gd~ <region.foreach.forEach> ::= (forEach of:<sites> <sites>) | 
               (forEach <sites> if:<boolean>) | (forEach Team <sites>) | 
               (forEach <ints> <sites>) | 
               (forEach Level [<siteType>] at:<int> [<stackDirection>] [if:<boolean>] [startAt:<int>]) [game.functions.region.foreach.ForEach] 
gd~ <region.last.last> ::= (last Between) [game.functions.region.last.Last] 
gd~ <region.math.difference> ::= (difference <sites> (<sites> | <int>)) [game.functions.region.math.Difference] 
gd~ <expand>   ::= (expand [<int> | <string>] (<sites> | 
               origin:<int>) [steps:<int>] [<absoluteDirection>] [<siteType>]) [game.functions.region.math.Expand] 
gd~ <region.math.if> ::= (if <boolean> <sites> [<sites>]) [game.functions.region.math.If] 
gd~ <region.math.intersection> ::= (intersection {<sites>}) | 
               (intersection <sites> <sites>) [game.functions.region.math.Intersection] 
gd~ <region.math.union> ::= (union {<sites>}) | (union <sites> <sites>) [game.functions.region.math.Union] 
g~~ <lineOfSightType> ::= Empty | Farthest | Piece [game.functions.region.sites.LineOfSightType] 
gd~ <sites>    ::= (sites <sitesSimpleType> [<siteType>]) | 
               (sites <sitesEdgeType>) | (sites Group [<siteType>] (at:<int> | 
               from:<sites>) [<direction>] [if:<boolean>]) | 
               (sites [<siteType>] [<int>] {{<stepType>}} [rotations:<boolean>]) 
               | (sites ({<int>} | <ints>)) | (sites <sitesMoveType> <moves>) | 
               (sites [<siteType>] {<string>}) | 
               (sites Hidden [<hiddenData>] [<siteType>] (to:<moves.player> | 
               to:<roleType>)) | 
               (sites Pattern {<stepType>} [<siteType>] [from:<int>] [what:<int> 
               | whats:{<int>}]) | 
               (sites Loop [inside:<boolean>] [<siteType>] [surround:<roleType> 
               | {<roleType>}] [<direction>] [<int>] [<int> | <sites>]) | 
               (sites) | (sites Crossing at:<int> [<moves.player> | 
               <roleType>]) | (sites Random [<sites>] [num:<int>]) | 
               (sites LargePiece [<siteType>] at:<int>) | 
               (sites Between [<direction>] [<siteType>] from:<int> [fromIncluded:<boolean>] to:<int> [toIncluded:<boolean>] [cond:<boolean>]) 
               | (sites Start <moves.piece>) | 
               (sites Occupied (by:<moves.player> | 
               by:<roleType>) [container:<int> | 
               container:<string>] [component:<int> | component:<string> | 
               components:{<string>}] [top:<boolean>] [on:<siteType>]) | 
               (sites Incident <siteType> of:<siteType> at:<int> [owner:<moves.player> 
               | <roleType>]) | (sites Around [<siteType>] (<int> | 
               <sites>) [<regionTypeDynamic>] [distance:<int>] [<absoluteDirection>] [if:<boolean>] [includeSelf:<boolean>]) 
               | (sites Direction (from:<int> | 
               from:<sites>) [<direction>] [included:<boolean>] [stop:<boolean>] [stopIncluded:<boolean>] [distance:<int>] [<siteType>]) 
               | 
               (sites LineOfSight [<lineOfSightType>] [<siteType>] [at:<int>] [<direction>]) 
               | (sites <sitesIndexType> [<siteType>] [<int>]) | 
               (sites Side [<siteType>] [<moves.player> | <roleType> | 
               <compassDirection>]) | 
               (sites Distance [<siteType>] [<relationType>] [<effect.step>] [newRotation:<int>] from:<int> <range>) 
               | (sites <sitesPlayerType> [<siteType>] [<moves.player> | 
               <roleType>] [<nonDecision>] [<string>]) | 
               (sites Track [<moves.player> | 
               <roleType>] [<string>] [from:<int>] [to:<int>]) | 
               (sites [<moves.player> | <roleType>] [<siteType>] [<string>]) | 
               (region <equipment.region>) | (region) | (region int) | 
               (region <string> <container.board.board> {<string>}) | 
               (region) | (region) | (region {int}) | (region) | 
               <region.math.difference> | <expand> | <region.foreach.forEach> | 
               <region.math.if> | <region.math.intersection> | 
               <region.last.last> | <region.math.union> [game.functions.region.sites.Sites] 
g~~ <sitesEdgeType> ::= Angled | Axial | Horizontal | Slash | Slosh | Vertical [game.functions.region.sites.SitesEdgeType] 
g~~ <sitesIndexType> ::= Cell | Column | Edge | Empty | Layer | Phase | Row | State [game.functions.region.sites.SitesIndexType] 
g~~ <sitesMoveType> ::= Between | From | To [game.functions.region.sites.SitesMoveType] 
g~~ <sitesPlayerType> ::= Hand | Winning [game.functions.region.sites.SitesPlayerType] 
g~~ <sitesSimpleType> ::= Board | Bottom | Centre | ConcaveCorners | ConvexCorners | 
               Corners | Hint | Inner | LastFrom | LastTo | Left | LineOfPlay | 
               Major | Minor | Outer | Pending | Perimeter | Playable | Right | 
               ToClear | Top [game.functions.region.sites.SitesSimpleType] 
~~~ <trackStepFunction> ::=  [game.functions.trackStep.TrackStepFunction] 
gd~ <games>    ::= (games (<subgame> | {<subgame>})) [game.match.Games] 
gd~ <match>    ::= (match <string>) | (match <string> [<players>] <games> <end>) [game.match.Match] 
gd~ <subgame>  ::= (subgame <string> [<string>] [next:<int>] [result:<int>]) [game.match.Subgame] 
gd~ <mode>     ::= (mode <modeType>) [game.mode.Mode] 
gd~ <players.player> ::= (player <directionFacing>) [game.players.Player] 
gd~ <players>  ::= (players <int>) | (players {<players.player>}) [game.players.Players] 
~~~ <rule>     ::=  [game.rules.Rule] 
gd~ <rules.rules> ::= (rules [<meta>] [<start>] [<play>] phases:{<phase.phase>} [<end>]) 
               | (rules [<meta>] [<start>] <play> <end>) [game.rules.Rules] 
gd~ <byScore>  ::= (byScore [{<end.score>}] [misere:<boolean>]) [game.rules.end.ByScore] 
gd~ <end>      ::= (end (<endRule> | {<endRule>})) [game.rules.end.End] 
g~~ <endRule>  ::= <end.forEach> | <end.if> [game.rules.end.EndRule] 
gd~ <end.forEach> ::= (forEach [<roleType> | Track] if:<boolean> <result>) [game.rules.end.ForEach] 
gd~ <end.if>   ::= (if <boolean> [<end.if> | {<end.if>}] [<result>]) [game.rules.end.If] 
gd~ <payoffs>  ::= (payoffs {<payoff>}) [game.rules.end.Payoffs] 
gd~ <result>   ::= (result <roleType> <resultType>) | <byScore> | <payoffs> [game.rules.end.Result] 
gd~ <automove> ::= (automove) [game.rules.meta.Automove] 
gd~ <gravity>  ::= (gravity [PyramidalDrop]) [game.rules.meta.Gravity] 
gd~ <meta>     ::= (meta ({<metaRule>} | <metaRule>)) [game.rules.meta.Meta] 
g~~ <metaRule> ::= <automove> | <gravity> | <meta.no.no> | <passEnd> | <pin> | 
               <meta.swap> [game.rules.meta.MetaRule] 
gd~ <passEnd>  ::= (passEnd <passEndType>) [game.rules.meta.PassEnd] 
gd~ <pin>      ::= (pin SupportMultiple) [game.rules.meta.Pin] 
gd~ <meta.swap> ::= (swap) [game.rules.meta.Swap] 
gd~ <meta.no.no> ::= (no Suicide) | (no Repeat [<repetitionType>]) [game.rules.meta.no.No] 
gd~ <nextPhase> ::= (nextPhase [<roleType> | <moves.player>] [<boolean>] [<string>]) [game.rules.phase.NextPhase] 
gd~ <phase.phase> ::= (phase <string> [<roleType>] [<mode>] <play> [<end>] [<nextPhase> 
               | {<nextPhase>}]) [game.rules.phase.Phase] 
gd~ <play>     ::= (play <moves>) [game.rules.play.Play] 
g~~ <moves>    ::= <effect.add> | <addScore> | <allCombinations> | <logical.and> | 
               <append> | <apply> | <attract> | <avoidStoredState> | <bet> | 
               <claim> | <custodial> | <effect.deal> | <decision> | 
               <directional> | <do> | <effect> | <enclose> | 
               <firstMoveOnTrack> | <flip> | <operators.foreach.forEach> | 
               <forget> | <fromTo> | <hop> | <logical.if> | <intervene> | 
               <leap> | <max.max> | <move> | <moveAgain> | <nonDecision> | 
               <note> | <operator> | <logical.or> | <pass> | <playCard> | 
               <priority> | <promote> | <propose> | <push> | <random> | 
               <remember> | <effect.remove> | <roll> | <satisfy> | <select> | 
               <seq> | <effect.set.set> | <shoot> | <slide> | <sow> | 
               <effect.step> | <surround> | <swap.swap> | <take> | <trigger> | 
               <vote> | <while> [game.rules.play.moves.Moves] 
g~~ <decision> ::= <move> [game.rules.play.moves.decision.Decision] 
gd~ <move>     ::= (move Step [<moves.from>] [<direction>] <moves.to> [stack:<boolean>] [<then>]) 
               | (move Set Rotation [<moves.to>] [{<int>} | 
               <int>] [previous:<boolean>] [next:<boolean>] [<then>]) | 
               (move Slide [<moves.from>] [<string>] [<direction>] [<moves.between>] [<moves.to>] [stack:<boolean>] [<then>]) 
               | 
               (move Shoot <moves.piece> [<moves.from>] [<absoluteDirection>] [<moves.between>] [<moves.to>] [<then>]) 
               | 
               (move Select <moves.from> [<moves.to>] [<roleType>] [<then>]) | 
               (move Swap Players (<int> <roleType>) (<int> <roleType>) [<then>]) 
               | (move Swap Pieces [<int>] [<int>] [<then>]) | 
               (move Remove [<siteType>] (<int> | 
               <sites>) [level:<int>] [at:<whenType>] [count:<int>] [<then>]) | 
               (move Set TrumpSuit (<int> | 
               <intArray.math.difference>) [<then>]) | 
               (move Set NextPlayer (<moves.player> | <ints>) [<then>]) | 
               (move Hop [<moves.from>] [<direction>] [<moves.between>] <moves.to> [stack:<boolean>] [<then>]) 
               | 
               (move <moves.from> <moves.to> [count:<int>] [copy:<boolean>] [stack:<boolean>] [<roleType>] [<then>]) 
               | (move Bet (<moves.player> | <roleType>) <range> [<then>]) | 
               (move <moveSiteType> [<moves.piece>] <moves.to> [count:<int>] [stack:<boolean>] [<then>]) 
               | (move <moveMessageType> (<string> | {<string>}) [<then>]) | 
               (move Promote [<siteType>] [<int>] <moves.piece> [<moves.player> 
               | <roleType>] [<then>]) | (move <moveSimpleType> [<then>]) | 
               (move Leap [<moves.from>] {{<stepType>}} [forward:<boolean>] [rotations:<boolean>] <moves.to> [<then>]) [game.rules.play.moves.decision.Move] 
g~~ <moveMessageType> ::= Propose | Vote [game.rules.play.moves.decision.MoveMessageType] 
g~~ <moveSimpleType> ::= Pass | PlayCard [game.rules.play.moves.decision.MoveSimpleType] 
g~~ <moveSiteType> ::= Add | Claim [game.rules.play.moves.decision.MoveSiteType] 
g~~ <nonDecision> ::= <effect> | <operator> [game.rules.play.moves.nonDecision.NonDecision] 
gd~ <effect.add> ::= (add [<moves.piece>] <moves.to> [count:<int>] [stack:<boolean>] [<then>]) [game.rules.play.moves.nonDecision.effect.Add] 
gd~ <apply>    ::= (apply if:<boolean>) | (apply <nonDecision>) | 
               (apply if:<boolean> <nonDecision>) [game.rules.play.moves.nonDecision.effect.Apply] 
gd~ <attract>  ::= (attract [<moves.from>] [<absoluteDirection>] [<then>]) [game.rules.play.moves.nonDecision.effect.Attract] 
gd~ <bet>      ::= (bet (<moves.player> | <roleType>) <range> [<then>]) [game.rules.play.moves.nonDecision.effect.Bet] 
gd~ <claim>    ::= (claim [<moves.piece>] <moves.to> [<then>]) [game.rules.play.moves.nonDecision.effect.Claim] 
gd~ <custodial> ::= (custodial [<moves.from>] [<absoluteDirection>] [<moves.between>] [<moves.to>] [<then>]) [game.rules.play.moves.nonDecision.effect.Custodial] 
gd~ <effect.deal> ::= (deal <dealableType> [<int>] [beginWith:<int>] [<then>]) [game.rules.play.moves.nonDecision.effect.Deal] 
gd~ <directional> ::= (directional [<moves.from>] [<direction>] [<moves.to>] [<then>]) [game.rules.play.moves.nonDecision.effect.Directional] 
g~~ <effect>   ::= <effect.add> | <addScore> | <attract> | <avoidStoredState> | 
               <bet> | <claim> | <custodial> | <effect.deal> | <directional> | 
               <do> | <enclose> | <firstMoveOnTrack> | <flip> | 
               <operators.foreach.forEach> | <forget> | <fromTo> | <hop> | 
               <intervene> | <leap> | <max.max> | <moveAgain> | <note> | 
               <pass> | <playCard> | <priority> | <promote> | <propose> | 
               <push> | <remember> | <effect.remove> | <roll> | <satisfy> | 
               <select> | <seq> | <effect.set.set> | <shoot> | <slide> | 
               <sow> | <effect.step> | <surround> | <swap.swap> | <take> | 
               <trigger> | <vote> | <while> [game.rules.play.moves.nonDecision.effect.Effect] 
gd~ <enclose>  ::= (enclose [<siteType>] [<moves.from>] [<direction>] [<moves.between>] [numException:<int>] [<then>]) [game.rules.play.moves.nonDecision.effect.Enclose] 
gd~ <flip>     ::= (flip [<siteType>] [<int>] [<then>]) [game.rules.play.moves.nonDecision.effect.Flip] 
gd~ <fromTo>   ::= (fromTo <moves.from> <moves.to> [count:<int>] [copy:<boolean>] [stack:<boolean>] [<roleType>] [<then>]) [game.rules.play.moves.nonDecision.effect.FromTo] 
gd~ <hop>      ::= (hop [<moves.from>] [<direction>] [<moves.between>] <moves.to> [stack:<boolean>] [<then>]) [game.rules.play.moves.nonDecision.effect.Hop] 
gd~ <intervene> ::= (intervene [<moves.from>] [<absoluteDirection>] [<moves.between>] [<moves.to>] [<then>]) [game.rules.play.moves.nonDecision.effect.Intervene] 
gd~ <leap>     ::= (leap [<moves.from>] {{<stepType>}} [forward:<boolean>] [rotations:<boolean>] <moves.to> [<then>]) [game.rules.play.moves.nonDecision.effect.Leap] 
gd~ <note>     ::= (note [player:<int> | player:<roleType>] (<string> | <int> | 
               <ints> | <float> | <boolean> | <sites> | <range> | <direction> | 
               <graph>) [to:<moves.player> | to:<roleType>]) [game.rules.play.moves.nonDecision.effect.Note] 
gd~ <pass>     ::= (pass [<then>]) [game.rules.play.moves.nonDecision.effect.Pass] 
gd~ <playCard> ::= (playCard [<then>]) [game.rules.play.moves.nonDecision.effect.PlayCard] 
gd~ <promote>  ::= (promote [<siteType>] [<int>] <moves.piece> [<moves.player> | 
               <roleType>] [<then>]) [game.rules.play.moves.nonDecision.effect.Promote] 
gd~ <propose>  ::= (propose (<string> | {<string>}) [<then>]) [game.rules.play.moves.nonDecision.effect.Propose] 
gd~ <push>     ::= (push [<moves.from>] <direction> [<then>]) [game.rules.play.moves.nonDecision.effect.Push] 
gd~ <random>   ::= (random <moves> num:<int>) | (random {<float>} {<moves>}) [game.rules.play.moves.nonDecision.effect.Random] 
gd~ <effect.remove> ::= (remove [<siteType>] (<int> | 
               <sites>) [level:<int>] [at:<whenType>] [count:<int>] [<then>]) [game.rules.play.moves.nonDecision.effect.Remove] 
gd~ <roll>     ::= (roll [<then>]) [game.rules.play.moves.nonDecision.effect.Roll] 
gd~ <satisfy>  ::= (satisfy (<boolean> | {<boolean>})) [game.rules.play.moves.nonDecision.effect.Satisfy] 
gd~ <select>   ::= (select <moves.from> [<moves.to>] [<roleType>] [<then>]) [game.rules.play.moves.nonDecision.effect.Select] 
gd~ <shoot>    ::= (shoot <moves.piece> [<moves.from>] [<absoluteDirection>] [<moves.between>] [<moves.to>] [<then>]) [game.rules.play.moves.nonDecision.effect.Shoot] 
gd~ <slide>    ::= (slide [<moves.from>] [<string>] [<direction>] [<moves.between>] [<moves.to>] [stack:<boolean>] [<then>]) [game.rules.play.moves.nonDecision.effect.Slide] 
gd~ <sow>      ::= (sow [<siteType>] [<int>] [count:<int>] [numPerHole:<int>] [<string>] [owner:<int>] [if:<boolean>] [sowEffect:<moves>] [apply:<nonDecision>] [includeSelf:<boolean>] [origin:<boolean>] [skipIf:<boolean>] [backtracking:<boolean> 
               | forward:<boolean>] [<then>]) [game.rules.play.moves.nonDecision.effect.Sow] 
gd~ <effect.step> ::= (step [<moves.from>] [<direction>] <moves.to> [stack:<boolean>] [<then>]) [game.rules.play.moves.nonDecision.effect.Step] 
gd~ <surround> ::= (surround [<moves.from>] [<relationType>] [<moves.between>] [<moves.to>] [except:<int>] [with:<moves.piece>] [<then>]) [game.rules.play.moves.nonDecision.effect.Surround] 
gd~ <then>     ::= (then <nonDecision> [applyAfterAllMoves:<boolean>]) [game.rules.play.moves.nonDecision.effect.Then] 
gd~ <trigger>  ::= (trigger <string> (<int> | <roleType>) [<then>]) [game.rules.play.moves.nonDecision.effect.Trigger] 
gd~ <vote>     ::= (vote (<string> | {<string>}) [<then>]) [game.rules.play.moves.nonDecision.effect.Vote] 
gd~ <avoidStoredState> ::= (avoidStoredState <moves> [<then>]) [game.rules.play.moves.nonDecision.effect.requirement.AvoidStoredState] 
gd~ <do>       ::= (do <moves> [next:<moves>] [ifAfterwards:<boolean>] [<then>]) [game.rules.play.moves.nonDecision.effect.requirement.Do] 
gd~ <firstMoveOnTrack> ::= (firstMoveOnTrack [<string>] [<roleType>] <moves> [<then>]) [game.rules.play.moves.nonDecision.effect.requirement.FirstMoveOnTrack] 
gd~ <priority> ::= (priority <moves> <moves> [<then>]) | 
               (priority {<moves>} [<then>]) [game.rules.play.moves.nonDecision.effect.requirement.Priority] 
gd~ <while>    ::= (while <boolean> <moves> [<then>]) [game.rules.play.moves.nonDecision.effect.requirement.While] 
gd~ <max.max>  ::= (max Distance [<string>] [<roleType>] <moves> [<then>]) | 
               (max <maxMovesType> [withValue:<boolean>] <moves> [<then>]) [game.rules.play.moves.nonDecision.effect.requirement.max.Max] 
g~~ <maxMovesType> ::= Captures | Moves [game.rules.play.moves.nonDecision.effect.requirement.max.MaxMovesType] 
gd~ <effect.set.set> ::= (set NextPlayer (<moves.player> | <ints>) [<then>]) | 
               (set Rotation [<moves.to>] [{<int>} | 
               <int>] [previous:<boolean>] [next:<boolean>] [<then>]) | 
               (set <setPlayerType> (<moves.player> | 
               <roleType>) <int> [<then>]) | (set TrumpSuit (<int> | 
               <intArray.math.difference>) [<then>]) | 
               (set Hidden [<hiddenData> | 
               {<hiddenData>}] [<siteType>] (at:<int> | 
               <sites>) [level:<int>] [<boolean>] (to:<moves.player> | 
               to:<roleType>) [<then>]) | 
               (set Team <int> {<roleType>} [<then>]) | 
               (set <setSiteType> [<siteType>] at:<int> [level:<int>] <int> [<then>]) 
               | (set <setValueType> [<int>] [<then>]) | 
               (set Var [<string>] [<int>] [<then>]) | (set Pending [<int> | 
               <sites>] [<then>]) [game.rules.play.moves.nonDecision.effect.set.Set] 
g~~ <setPlayerType> ::= Score | Value [game.rules.play.moves.nonDecision.effect.set.SetPlayerType] 
g~~ <setSiteType> ::= Count | State | Value [game.rules.play.moves.nonDecision.effect.set.SetSiteType] 
g~~ <setValueType> ::= Counter | Pot [game.rules.play.moves.nonDecision.effect.set.SetValueType] 
gd~ <addScore> ::= (addScore ({<int>} | {<roleType>}) {<int>} [<then>]) | 
               (addScore (<moves.player> | <roleType>) <int> [<then>]) [game.rules.play.moves.nonDecision.effect.state.AddScore] 
gd~ <moveAgain> ::= (moveAgain [<then>]) [game.rules.play.moves.nonDecision.effect.state.MoveAgain] 
gd~ <forget>   ::= (forget Value [<string>] <int> [<then>]) | 
               (forget Value [<string>] All [<then>]) [game.rules.play.moves.nonDecision.effect.state.forget.Forget] 
gd~ <remember> ::= (remember State [<then>]) | 
               (remember Value [<string>] <int> [unique:<boolean>] [<then>]) [game.rules.play.moves.nonDecision.effect.state.remember.Remember] 
gd~ <swap.swap> ::= (swap Players (<int> | <roleType>) (<int> | 
               <roleType>) [<then>]) | (swap Pieces [<int> <int>] [<then>]) [game.rules.play.moves.nonDecision.effect.state.swap.Swap] 
gd~ <take>     ::= (take Control (of:<roleType> | of:<int>) (by:<roleType> | 
               by:<int>) [at:<int> | to:<sites>] [<siteType>] [<then>]) | 
               (take Domino [<then>]) [game.rules.play.moves.nonDecision.effect.take.Take] 
g~~ <operator> ::= <allCombinations> | <logical.and> | <append> | <logical.if> | 
               <logical.or> [game.rules.play.moves.nonDecision.operator.Operator] 
gd~ <operators.foreach.forEach> ::= (forEach Direction [<moves.from>] [<direction>] [<moves.between>] (<moves.to> 
               | <moves>) [<then>]) | 
               (forEach Site <sites> <moves> [noMoveYet:<moves>] [<then>]) | 
               (forEach Value <ints> <moves> [<then>]) | 
               (forEach Level [<siteType>] <int> [<stackDirection>] <moves> [<then>]) 
               | (forEach Team <moves> [<then>]) | 
               (forEach Group [<siteType>] [<direction>] [if:<boolean>] <moves> [<then>]) 
               | 
               (forEach Die [<int>] [combined:<boolean>] [replayDouble:<boolean>] [if:<boolean>] <moves> [<then>]) 
               | (forEach <ints> <moves> [<then>]) | 
               (forEach Player <moves> [<then>]) | 
               (forEach Piece [on:<siteType>] [<string> | 
               {<string>}] [container:<int> | 
               <string>] [<moves>] [<moves.player> | 
               <roleType>] [top:<boolean>] [<then>]) | 
               (forEach Value min:<int> max:<int> <moves> [<then>]) [game.rules.play.moves.nonDecision.operators.foreach.ForEach] 
gd~ <allCombinations> ::= (allCombinations <moves> <moves> [<then>]) [game.rules.play.moves.nonDecision.operators.logical.AllCombinations] 
gd~ <logical.and> ::= (and {<moves>} [<then>]) | (and <moves> <moves> [<then>]) [game.rules.play.moves.nonDecision.operators.logical.And] 
gd~ <append>   ::= (append <nonDecision> [<then>]) [game.rules.play.moves.nonDecision.operators.logical.Append] 
gd~ <logical.if> ::= (if <boolean> <moves> [<moves>] [<then>]) [game.rules.play.moves.nonDecision.operators.logical.If] 
gd~ <logical.or> ::= (or {<moves>} [<then>]) | (or <moves> <moves> [<then>]) [game.rules.play.moves.nonDecision.operators.logical.Or] 
gd~ <seq>      ::= (seq {<moves>}) [game.rules.play.moves.nonDecision.operators.logical.Seq] 
gd~ <start.deal> ::= (deal <dealableType> [<int>]) [game.rules.start.Deal] 
gd~ <start>    ::= (start ({<startRule>} | <startRule>)) [game.rules.start.Start] 
g~~ <startRule> ::= <start.deal> | <forEach.forEach> | <place> | 
               <deductionPuzzle.set> | <start.set.set> | <split> [game.rules.start.StartRule] 
gd~ <deductionPuzzle.set> ::= (set [<siteType>] {{<int>}}) [game.rules.start.deductionPuzzle.Set] 
gd~ <forEach.forEach> ::= (forEach Player <startRule>) | 
               (forEach Value min:<int> max:<int> <startRule>) | 
               (forEach Site <sites> [if:<boolean>] <startRule>) | 
               (forEach <ints> <startRule>) | (forEach Team <startRule>) [game.rules.start.forEach.ForEach] 
gd~ <place>    ::= (place Stack (<string> | 
               items:{<string>}) [<string>] [<siteType>] [<int> | {<int>} | 
               <sites> | coord:<string> | {<string>}] [count:<int> | 
               counts:{<int>}] [state:<int>] [rotation:<int>] [value:<int>]) | 
               (place Random [<sites>] {<string>} [count:<int>] [state:<int>] [value:<int>] [<siteType>]) 
               | 
               (place <string> [<siteType>] [{<int>}] [<sites>] [{<string>}] [counts:{<int>}] [state:<int>] [rotation:<int>] [value:<int>]) 
               | 
               (place <string> [<string>] [<siteType>] [<int>] [coord:<string>] [count:<int>] [state:<int>] [rotation:<int>] [value:<int>]) 
               | 
               (place Random {<string>} [count:{<int>}] [state:<int>] [value:<int>] <int> [<siteType>]) 
               | (place Random {<math.count>} <int> [<siteType>]) [game.rules.start.place.Place] 
gd~ <start.set.set> ::= (set <setStartSitesType> <int> [<siteType>] (at:<int> | 
               to:<sites>)) | 
               (set <roleType> [<siteType>] [{<int>}] [<sites>] [{<string>}]) | 
               (set <roleType> [<siteType>] [<int>] [coord:<string>]) | 
               (set RememberValue [<string>] (<int> | 
               <sites>) [unique:<boolean>]) | (set Hidden [<hiddenData> | 
               {<hiddenData>}] [<siteType>] (at:<int> | 
               <sites>) [level:<int>] [<boolean>] to:<roleType>) | 
               (set <setStartPlayerType> [<roleType>] <int>) | 
               (set Team <int> {<roleType>}) [game.rules.start.set.Set] 
g~~ <setStartPlayerType> ::= Amount | Score [game.rules.start.set.SetStartPlayerType] 
g~~ <setStartSitesType> ::= Cost | Count | Phase [game.rules.start.set.SetStartSitesType] 
gd~ <split>    ::= (split Deck) [game.rules.start.split.Split] 
g~~ <basisType> ::= Brick | Celtic | Circle | Concentric | Dual | Hexagonal | 
               HexagonalPyramidal | Mesh | Morris | NoBasis | QuadHex | 
               Spiral | Square | SquarePyramidal | T31212 | T333333_33434 | 
               T33336 | T33344 | T33434 | T3464 | T3636 | T4612 | T488 | 
               Triangular [game.types.board.BasisType] 
g~~ <hiddenData> ::= Count | Rotation | State | Value | What | Who [game.types.board.HiddenData] 
g~~ <landmarkType> ::= BottomSite | CentreSite | FirstSite | LastSite | LeftSite | 
               RightSite | Topsite [game.types.board.LandmarkType] 
g~~ <puzzleElementType> ::= Cell | Edge | Hint | Vertex [game.types.board.PuzzleElementType] 
g~~ <regionTypeDynamic> ::= Empty | Enemy | NotEmpty | NotEnemy | NotOwn | Own [game.types.board.RegionTypeDynamic] 
g~~ <regionTypeStatic> ::= AllDirections | AllSites | Columns | Corners | 
               Diagonals | HintRegions | Layers | Regions | Rows | Sides | 
               SidesNoCorners | SubGrids | Touching | Vertices [game.types.board.RegionTypeStatic] 
g~m <relationType> ::= Adjacent | All | Diagonal | OffDiagonal | Orthogonal [game.types.board.RelationType] 
g~~ <shapeType> ::= Circle | Cross | Custom | Diamond | Hexagon | Limping | 
               NoShape | Polygon | Prism | Quadrilateral | Rectangle | 
               Regular | Rhombus | Spiral | Square | Star | Triangle | Wedge | 
               Wheel [game.types.board.ShapeType] 
g~m <siteType> ::= Cell | Edge | Vertex [game.types.board.SiteType] 
g~~ <stepType> ::= F | L | R [game.types.board.StepType] 
g~~ <storeType> ::= Inner | None | Outer [game.types.board.StoreType] 
g~~ <tilingBoardlessType> ::= Hexagonal | Square | Triangular [game.types.board.TilingBoardlessType] 
~~~ <trackStepType> ::= End | Off | Repeat [game.types.board.TrackStepType] 
g~~ <cardType> ::= Ace | Eight | Five | Four | Jack | Joker | King | Nine | Queen | 
               Seven | Six | Ten | Three | Two [game.types.component.CardType] 
g~~ <dealableType> ::= Cards | Dominoes [game.types.component.DealableType] 
~~m <suitType> ::= Clubs | Diamonds | Hearts | Spades [game.types.component.SuitType] 
~~~ <types.dummy> ::=  [game.types.dummy] 
g~~ <modeType> ::= Alternating | Simulation | Simultaneous [game.types.play.ModeType] 
g~~ <passEndType> ::= Draw | NoEnd [game.types.play.PassEndType] 
g~~ <prevType> ::= Mover | MoverLastTurn [game.types.play.PrevType] 
g~~ <repetitionType> ::= Positional | PositionalInTurn | Situational | 
               SituationalInTurn [game.types.play.RepetitionType] 
g~~ <resultType> ::= Abandon | Crash | Draw | Loss | Tie | Win [game.types.play.ResultType] 
g~m <roleType> ::= All | Ally | Each | Enemy | Friend | Mover | Neutral | Next | 
               NonMover | P1 | P10 | P11 | P12 | P13 | P14 | P15 | P16 | P2 | 
               P3 | P4 | P5 | P6 | P7 | P8 | P9 | Player | Prev | Shared | 
               Team1 | Team10 | Team11 | Team12 | Team13 | Team14 | Team15 | 
               Team16 | Team2 | Team3 | Team4 | Team5 | Team6 | Team7 | Team8 | 
               Team9 | TeamMover [game.types.play.RoleType] 
g~~ <whenType> ::= EndOfTurn | StartOfTurn [game.types.play.WhenType] 
~~~ <gameType> ::=  [game.types.state.GameType] 
g~~ <absoluteDirection> ::= Adjacent | All | Angled | Axial | Base | CCW | CW | D | 
               DE | DN | DNE | DNW | DS | DSE | DSW | DW | Diagonal | 
               Downward | E | ENE | ESE | In | N | NE | NNE | NNW | NW | 
               OffDiagonal | Orthogonal | Out | Rotational | S | SE | SSE | 
               SSW | SW | SameLayer | Support | U | UE | UN | UNE | UNW | US | 
               USE | USW | UW | Upward | W | WNW | WSW [game.util.directions.AbsoluteDirection] 
g~~ <compassDirection> ::= E | ENE | ESE | N | NE | NNE | NNW | NW | S | SE | SSE | 
               SSW | SW | W | WNW | WSW [game.util.directions.CompassDirection] 
g~~ <direction> ::= <absoluteDirection> | <directions.difference> | <directions> | 
               <directions.if> | <relativeDirection> | <directions.union> [game.util.directions.Direction] 
g~~ <directionFacing> ::= <compassDirection> | <rotationalDirection> | 
               <spatialDirection> [game.util.directions.DirectionFacing] 
~~~ <directionType> ::= (directionType <directionFacing>) [game.util.directions.DirectionType] 
g~~ <relativeDirection> ::= BL | BLL | BLLL | BR | BRR | BRRR | Backward | 
               Backwards | FL | FLL | FLLL | FR | FRR | FRRR | Forward | 
               Forwards | Leftward | Leftwards | OppositeDirection | 
               Rightward | Rightwards | SameDirection [game.util.directions.RelativeDirection] 
g~~ <rotationalDirection> ::= CCW | CW | In | Out [game.util.directions.RotationalDirection] 
g~~ <spatialDirection> ::= D | DE | DN | DNE | DNW | DS | DSE | DSW | DW | U | UE | 
               UN | UNE | UNW | US | USE | USW | UW [game.util.directions.SpatialDirection] 
g~~ <stackDirection> ::= FromBottom | FromTop [game.util.directions.StackDirection] 
~~~ <util.dummy> ::=  [game.util.dummy] 
gd~ <payoff>   ::= (payoff <roleType> <float>) [game.util.end.Payoff] 
gd~ <end.score> ::= (score <roleType> <int>) [game.util.end.Score] 
gd~ <equipment.card> ::= (card <cardType> rank:<int> value:<int> [trumpRank:<int>] [trumpValue:<int>] [biased:<int>]) [game.util.equipment.Card] 
gd~ <equipment.hint> ::= (hint <int> [<int>]) | (hint {<int>} [<int>]) [game.util.equipment.Hint] 
gd~ <equipment.values> ::= (values <siteType> <range>) [game.util.equipment.Values] 
~~~ <bucket>   ::= (bucket) [game.util.graph.Bucket] 
~~~ <graph.edge> ::= (edge int <vertex> <vertex>) [game.util.graph.Edge] 
~~~ <graph.face> ::= (face int) [game.util.graph.Face] 
gd~ <graph>    ::= (graph vertices:{{<float>}} [edges:{{<int>}}]) | (graph) | 
               (graph <graph>) | (graph) | <operators.add> | <basis> | 
               <brick> | <celtic> | <clip> | <complete> | <concentric> | 
               <dual> | <hex> | <hole> | <intersect> | <keep> | <layers> | 
               <makeFaces> | <merge> | <quadhex> | <recoordinate> | <regular> | 
               <operators.remove> | <renumber> | <repeat> | <rotate> | 
               <scale> | <shift> | <skew> | <spiral> | <splitCrossings> | 
               <square> | <subdivide> | <tiling> | <tri> | <trim> | 
               <operators.union> | <wedge> [game.util.graph.Graph] 
~~~ <graphElement> ::= <graph.edge> | <graph.face> | <vertex> [game.util.graph.GraphElement] 
~~~ <itemScore> ::= (itemScore int) [game.util.graph.ItemScore] 
~~~ <measureGraph> ::=  [game.util.graph.MeasureGraph] 
~~~ <perimeter> ::= (perimeter) [game.util.graph.Perimeter] 
gd~ <poly>     ::= (poly {{<dim>}} [rotns:<int>]) | (poly {{<float>}} [rotns:<int>]) [game.util.graph.Poly] 
~~~ <properties> ::= (properties) | (properties) | (properties <properties>) [game.util.graph.Properties] 
~~~ <radial>   ::= (radial {<graphElement>} <absoluteDirection>) [game.util.graph.Radial] 
~~~ <radials>  ::= (radials <siteType> int) [game.util.graph.Radials] 
~~~ <situation> ::= (situation) [game.util.graph.Situation] 
~~~ <graph.step> ::= (step <graphElement> <graphElement>) [game.util.graph.Step] 
~~~ <steps>    ::= (steps <siteType> int) [game.util.graph.Steps] 
~~~ <trajectories> ::= (trajectories) [game.util.graph.Trajectories] 
~~~ <vertex>   ::= (vertex int) | (vertex int) | (vertex int) | (vertex int) [game.util.graph.Vertex] 
gd~ <math.count> ::= (count <string> <int>) [game.util.math.Count] 
gd~ <math.pair> ::= (pair <string> <string>) | (pair <roleType> <roleType>) | 
               (pair <roleType> <int>) | (pair <int> <int>) | 
               (pair <string> <roleType>) | (pair <roleType> <landmarkType>) | 
               (pair <roleType> <string>) | (pair <int> <string>) [game.util.math.Pair] 
gd~ <moves.between> ::= (between [before:<int>] [<range>] [after:<int>] [if:<boolean>] [trail:<int>] [<apply>]) [game.util.moves.Between] 
gd~ <flips>    ::= (flips <int> <int>) [game.util.moves.Flips] 
gd~ <moves.from> ::= (from [<siteType>] [<sites> | 
               <int>] [level:<int>] [if:<boolean>]) [game.util.moves.From] 
gd~ <moves.piece> ::= (piece (<string> | <int> | {<string>} | {<int>}) [state:<int>]) [game.util.moves.Piece] 
gd~ <moves.player> ::= (player <int>) [game.util.moves.Player] 
gd~ <moves.to> ::= (to [<siteType>] [<sites> | 
               <int>] [level:<int>] [<rotations>] [if:<boolean>] [<apply>]) [game.util.moves.To] 
~~~ <optimiser> ::= (optimiser) [game.util.optimiser.Optimiser] 
~~~ <compareAllDistanceMetrics> ::= (compareAllDistanceMetrics) [gameDistance.CompareAllDistanceMetrics] 
~~~ <dataset>  ::=  [gameDistance.datasets.Dataset] 
~~~ <datasetUtils> ::= (datasetUtils) [gameDistance.datasets.DatasetUtils] 
~~~ <aIResultDataset> ::= (aIResultDataset) [gameDistance.datasets.bagOfWords.AIResultDataset] 
~~~ <compilationConceptDataset> ::= (compilationConceptDataset) [gameDistance.datasets.bagOfWords.CompilationConceptDataset] 
~~~ <importConceptDataset> ::= (importConceptDataset) [gameDistance.datasets.bagOfWords.ImportConceptDataset] 
~~~ <nGramDataset> ::= (nGramDataset <dataset> int) [gameDistance.datasets.bagOfWords.NGramDataset] 
~~~ <moveConceptDataset> ::= (moveConceptDataset) [gameDistance.datasets.sequence.MoveConceptDataset] 
~~~ <stateConceptDataset> ::= (stateConceptDataset) [gameDistance.datasets.sequence.StateConceptDataset] 
~~~ <ludemeDataset> ::= (ludemeDataset) [gameDistance.datasets.treeEdit.LudemeDataset] 
~~~ <distanceMetric> ::=  [gameDistance.metrics.DistanceMetric] 
~~~ <cosine>   ::= (cosine) [gameDistance.metrics.bagOfWords.Cosine] 
~~~ <jaccard>  ::= (jaccard) [gameDistance.metrics.bagOfWords.Jaccard] 
~~~ <jensenShannonDivergence> ::= (jensenShannonDivergence) [gameDistance.metrics.bagOfWords.JensenShannonDivergence] 
~~~ <overlap>  ::= (overlap) [gameDistance.metrics.bagOfWords.Overlap] 
~~~ <globalAlignment> ::= (globalAlignment) [gameDistance.metrics.sequence.GlobalAlignment] 
~~~ <levenshtein> ::= (levenshtein) [gameDistance.metrics.sequence.Levenshtein] 
~~~ <localAlignment> ::= (localAlignment) [gameDistance.metrics.sequence.LocalAlignment] 
~~~ <repeatedLocalAlignment> ::= (repeatedLocalAlignment) [gameDistance.metrics.sequence.RepeatedLocalAlignment] 
~~~ <apted>    ::= (apted) [gameDistance.metrics.treeEdit.Apted] 
~~~ <zhangShasha> ::= (zhangShasha) [gameDistance.metrics.treeEdit.ZhangShasha] 
~~~ <distanceUtils> ::= (distanceUtils) [gameDistance.utils.DistanceUtils] 
~~~ <costModel> ::=  [gameDistance.utils.apted.costmodel.CostModel] 
~~~ <perEditOperationStringNodeDataCostModel> ::= (perEditOperationStringNodeDataCostModel float float float) [gameDistance.utils.apted.costmodel.PerEditOperationStringNodeDataCostModel] 
~~~ <stringUnitCostModel> ::= (stringUnitCostModel) [gameDistance.utils.apted.costmodel.StringUnitCostModel] 
~~~ <aPTED>    ::= (aPTED) [gameDistance.utils.apted.distance.APTED] 
~~~ <allPossibleMappingsTED> ::= (allPossibleMappingsTED) [gameDistance.utils.apted.distance.AllPossibleMappingsTED] 
~~~ <node>     ::= (node) [gameDistance.utils.apted.node.Node] 
~~~ <nodeIndexer> ::= (nodeIndexer) [gameDistance.utils.apted.node.NodeIndexer] 
~~~ <stringNodeData> ::= (stringNodeData <string>) [gameDistance.utils.apted.node.StringNodeData] 
~~~ <bracketStringInputParser> ::= (bracketStringInputParser) [gameDistance.utils.apted.parser.BracketStringInputParser] 
~~~ <inputParser> ::=  [gameDistance.utils.apted.parser.InputParser] 
~~~ <correctnes> ::= (correctnes) [gameDistance.utils.apted.test.java.CorrectnessTest] 
~~~ <perEditOperationCorrectnes> ::= (perEditOperationCorrectnes) [gameDistance.utils.apted.test.java.PerEditOperationCorrectnessTest] 
~~~ <commandLine> ::= (commandLine) [gameDistance.utils.apted.util.CommandLine] 
~~~ <formatUtilities> ::= (formatUtilities) [gameDistance.utils.apted.util.FormatUtilities] 
~~m <metadata> ::= (metadata) | (metadata [<info>] [<graphics>] [<ai>] [<recon>]) [metadata.Metadata] 
~~m <metadataItem> ::=  [metadata.MetadataItem] 
~~m <aIItem>   ::=  [metadata.ai.AIItem] 
~~m <ai>       ::= (ai [<agent>] [<heuristics>] [trainedHeuristics:<heuristics>] [<features>] [trainedFeatures:<features>] [trainedFeatureTrees:<featureTrees>]) [metadata.ai.Ai] 
~~m <agent>    ::=  [metadata.ai.agents.Agent] 
~~m <bestAgent> ::= (bestAgent <string>) [metadata.ai.agents.BestAgent] 
~~m <mcts>     ::= (mcts [<selection>]) [metadata.ai.agents.mcts.Mcts] 
~~m <ag0>      ::= (ag0 [<float>]) [metadata.ai.agents.mcts.selection.Ag0] 
~~m <selection> ::= <ag0> | <ucb1> [metadata.ai.agents.mcts.selection.Selection] 
~~m <ucb1>     ::= (ucb1 [<float>]) [metadata.ai.agents.mcts.selection.Ucb1] 
~~m <alphaBeta> ::= (alphaBeta [<heuristics>]) [metadata.ai.agents.minimax.AlphaBeta] 
~~m <featureSet> ::= (featureSet <roleType> [selectionFeatures:{<misc.pair>}] [playoutFeatures:{<misc.pair>}] [tspgFeatures:{<misc.pair>}]) 
               | (featureSet <roleType> {<misc.pair>}) [metadata.ai.features.FeatureSet] 
~~m <features> ::= (features [{<featureSet>}]) | (features [<featureSet>]) [metadata.ai.features.Features] 
~~m <featureTrees> ::= (featureTrees [logitTrees:{<logitTree>}] [decisionTrees:{<decisionTree>}]) [metadata.ai.features.trees.FeatureTrees] 
~~m <binaryLeaf> ::= (binaryLeaf <float>) [metadata.ai.features.trees.classifiers.BinaryLeaf] 
~~m <decisionTree> ::= (decisionTree <roleType> <decisionTreeNode>) [metadata.ai.features.trees.classifiers.DecisionTree] 
~~m <decisionTreeNode> ::= <binaryLeaf> | <classifiers.if> | <classifiers.leaf> [metadata.ai.features.trees.classifiers.DecisionTreeNode] 
~~m <classifiers.if> ::= (if <string> then:<decisionTreeNode> else:<decisionTreeNode>) [metadata.ai.features.trees.classifiers.If] 
~~m <classifiers.leaf> ::= (leaf bottom25:<float> iqr:<float> top25:<float>) [metadata.ai.features.trees.classifiers.Leaf] 
~~m <logits.if> ::= (if <string> then:<logitNode> else:<logitNode>) [metadata.ai.features.trees.logits.If] 
~~m <logits.leaf> ::= (leaf {<misc.pair>}) [metadata.ai.features.trees.logits.Leaf] 
~~m <logitNode> ::= <logits.if> | <logits.leaf> [metadata.ai.features.trees.logits.LogitNode] 
~~m <logitTree> ::= (logitTree <roleType> <logitNode>) [metadata.ai.features.trees.logits.LogitTree] 
~~m <heuristics> ::= (heuristics [<heuristicTerm>]) | 
               (heuristics [{<heuristicTerm>}]) [metadata.ai.heuristics.Heuristics] 
~~m <centreProximity> ::= (centreProximity [transformation:<heuristicTransformation>] [weight:<float>] [pieceWeights:{<misc.pair>}]) [metadata.ai.heuristics.terms.CentreProximity] 
~~m <componentValues> ::= (componentValues [transformation:<heuristicTransformation>] [weight:<float>] [pieceWeights:{<misc.pair>}] [boardOnly:<boolean>]) [metadata.ai.heuristics.terms.ComponentValues] 
~~m <cornerProximity> ::= (cornerProximity [transformation:<heuristicTransformation>] [weight:<float>] [pieceWeights:{<misc.pair>}]) [metadata.ai.heuristics.terms.CornerProximity] 
~~m <currentMoverHeuristic> ::= (currentMoverHeuristic [transformation:<heuristicTransformation>] [weight:<float>]) [metadata.ai.heuristics.terms.CurrentMoverHeuristic] 
~~m <heuristicTerm> ::= <centreProximity> | <componentValues> | <cornerProximity> | 
               <currentMoverHeuristic> | <influence> | <influenceAdvanced> | 
               <intercept> | <lineCompletionHeuristic> | <material> | 
               <mobilityAdvanced> | <mobilitySimple> | <nullHeuristic> | 
               <ownRegionsCount> | <playerRegionsProximity> | 
               <playerSiteMapCount> | <regionProximity> | <terms.score> | 
               <sidesProximity> | <unthreatenedMaterial> [metadata.ai.heuristics.terms.HeuristicTerm] 
~~m <influence> ::= (influence [transformation:<heuristicTransformation>] [weight:<float>]) [metadata.ai.heuristics.terms.Influence] 
~~m <influenceAdvanced> ::= (influenceAdvanced [transformation:<heuristicTransformation>] [weight:<float>]) [metadata.ai.heuristics.terms.InfluenceAdvanced] 
~~m <intercept> ::= (intercept [transformation:<heuristicTransformation>] playerWeights:{<misc.pair>}) [metadata.ai.heuristics.terms.Intercept] 
~~m <lineCompletionHeuristic> ::= (lineCompletionHeuristic [transformation:<heuristicTransformation>] [weight:<float>] [targetLength:<int>]) [metadata.ai.heuristics.terms.LineCompletionHeuristic] 
~~m <material> ::= (material [transformation:<heuristicTransformation>] [weight:<float>] [pieceWeights:{<misc.pair>}] [boardOnly:<boolean>]) [metadata.ai.heuristics.terms.Material] 
~~m <mobilityAdvanced> ::= (mobilityAdvanced [transformation:<heuristicTransformation>] [weight:<float>]) [metadata.ai.heuristics.terms.MobilityAdvanced] 
~~m <mobilitySimple> ::= (mobilitySimple [transformation:<heuristicTransformation>] [weight:<float>]) [metadata.ai.heuristics.terms.MobilitySimple] 
~~m <nullHeuristic> ::= (nullHeuristic) [metadata.ai.heuristics.terms.NullHeuristic] 
~~m <ownRegionsCount> ::= (ownRegionsCount [transformation:<heuristicTransformation>] [weight:<float>]) [metadata.ai.heuristics.terms.OwnRegionsCount] 
~~m <playerRegionsProximity> ::= (playerRegionsProximity [transformation:<heuristicTransformation>] [weight:<float>] player:<int> [pieceWeights:{<misc.pair>}]) [metadata.ai.heuristics.terms.PlayerRegionsProximity] 
~~m <playerSiteMapCount> ::= (playerSiteMapCount [transformation:<heuristicTransformation>] [weight:<float>]) [metadata.ai.heuristics.terms.PlayerSiteMapCount] 
~~m <regionProximity> ::= (regionProximity [transformation:<heuristicTransformation>] [weight:<float>] region:<int> [pieceWeights:{<misc.pair>}]) [metadata.ai.heuristics.terms.RegionProximity] 
~~m <terms.score> ::= (score [transformation:<heuristicTransformation>] [weight:<float>]) [metadata.ai.heuristics.terms.Score] 
~~m <sidesProximity> ::= (sidesProximity [transformation:<heuristicTransformation>] [weight:<float>] [pieceWeights:{<misc.pair>}]) [metadata.ai.heuristics.terms.SidesProximity] 
~~m <unthreatenedMaterial> ::= (unthreatenedMaterial [transformation:<heuristicTransformation>] [weight:<float>] [pieceWeights:{<misc.pair>}]) [metadata.ai.heuristics.terms.UnthreatenedMaterial] 
~~m <divNumBoardSites> ::= (divNumBoardSites) [metadata.ai.heuristics.transformations.DivNumBoardSites] 
~~m <divNumInitPlacement> ::= (divNumInitPlacement) [metadata.ai.heuristics.transformations.DivNumInitPlacement] 
~~m <heuristicTransformation> ::=  [metadata.ai.heuristics.transformations.HeuristicTransformation] 
~~m <logisticFunction> ::= (logisticFunction) [metadata.ai.heuristics.transformations.LogisticFunction] 
~~m <tanh>     ::= (tanh) [metadata.ai.heuristics.transformations.Tanh] 
~~m <misc.pair> ::= (pair <string> <float>) [metadata.ai.misc.Pair] 
~~m <graphics> ::= (graphics (<graphicsItem> | {<graphicsItem>})) [metadata.graphics.Graphics] 
~~m <graphicsItem> ::=  [metadata.graphics.GraphicsItem] 
~~m <graphics.board.board> ::= (board Colour <boardGraphicsType> <colour>) | 
               (board <pieceGroundType> [image:<string>] [fillColour:<colour>] [edgeColour:<colour>] [scale:<float>] [scaleX:<float>] [scaleY:<float>] [rotation:<int>] [offsetX:<float>] [offsetY:<float>]) 
               | (board Checkered [<boolean>]) | 
               (board StyleThickness <boardGraphicsType> <float>) | 
               (board Style <containerStyleType> [replaceComponentsWithFilledCells:<boolean>]) 
               | 
               (board Placement [scale:<float>] [offsetX:<float>] [offsetY:<float>]) 
               | (board Curvature <float>) [metadata.graphics.board.Board] 
~~m <hand.hand> ::= (hand Placement <roleType> [scale:<float>] [offsetX:<float>] [offsetY:<float>] [vertical:<boolean>]) [metadata.graphics.hand.Hand] 
~~m <graphics.no.no> ::= (no <noBooleanType> [<boolean>]) [metadata.graphics.no.No] 
~~m <noBooleanType> ::= Animation | Board | Curves | DicePips | HandScale | 
               MaskedColour | Sunken [metadata.graphics.no.NoBooleanType] 
~~m <hiddenImage> ::= (hiddenImage <string>) [metadata.graphics.others.HiddenImage] 
~~m <stackType> ::= (stackType [<roleType>] [<string>] [<int>] [<siteType>] [sites:{<int>} 
               | 
               site:<int>] [state:<int>] [value:<int>] <pieceStackType> [<float>] [limit:<int>]) [metadata.graphics.others.StackType] 
~~m <suitRanking> ::= (suitRanking {<suitType>}) [metadata.graphics.others.SuitRanking] 
~~m <piece.piece> ::= (piece Colour [<roleType>] [<string>] [container:<int>] [state:<int>] [value:<int>] [fillColour:<colour>] [strokeColour:<colour>] [secondaryColour:<colour>]) 
               | 
               (piece <pieceGroundType> [<roleType>] [<string>] [container:<int>] [state:<int>] [value:<int>] [image:<string>] [text:<string>] [fillColour:<colour>] [edgeColour:<colour>] [scale:<float>] [scaleX:<float>] [scaleY:<float>] [rotation:<int>] [offsetX:<float>] [offsetY:<float>]) 
               | (piece Families {<string>}) | 
               (piece <pieceNameType> [<roleType>] [piece:<string>] [container:<int>] [state:<int>] [value:<int>] [<string>]) 
               | (piece Style [<roleType>] [<string>] <componentStyleType>) | 
               (piece Rotate [<roleType>] [<string>] [container:<int>] [state:<int>] [value:<int>] degrees:<int>) 
               | 
               (piece Scale [<roleType>] [<string>] [container:<int>] [state:<int>] [value:<int>] [<float>] [scaleX:<float>] [scaleY:<float>]) [metadata.graphics.piece.Piece] 
~~m <pieceGroundType> ::= Background | Foreground | Hidden [metadata.graphics.piece.PieceGroundType] 
~~m <pieceNameType> ::= AddStateToName | ExtendName | Hidden | Rename [metadata.graphics.piece.PieceNameType] 
~~m <player.player> ::= (player Name <roleType> <string>) | 
               (player Colour <roleType> <colour>) [metadata.graphics.player.Player] 
~~m <adversarialPuzzle> ::= (adversarialPuzzle [<boolean>]) [metadata.graphics.puzzle.AdversarialPuzzle] 
~~m <drawHint> ::= (drawHint <puzzleDrawHintType>) [metadata.graphics.puzzle.DrawHint] 
~~m <hintLocation> ::= (hintLocation <puzzleHintLocationType>) [metadata.graphics.puzzle.HintLocation] 
~~m <region.region> ::= (region Colour [<string>] [<roleType>] [<siteType>] [{<int>} 
               | 
               <int>] [<sites>] [regionSiteType:<siteType>] [<colour>] [scale:<float>]) [metadata.graphics.region.Region] 
~~m <show>     ::= (show Line {{<int>}} [<siteType>] [<lineStyle>] [<colour>] [scale:<float>] [curve:{<float>}] [<curveType>]) 
               | 
               (show Edges [<edgeType>] [<relationType>] [connection:<boolean>] [<lineStyle>] [<colour>]) 
               | (show <showBooleanType> [<boolean>]) | 
               (show Symbol [<string>] [text:<string>] [<string>] [<roleType>] [<siteType>] [{<int>} 
               | 
               <int>] [<sites>] [<boardGraphicsType>] [fillColour:<colour>] [edgeColour:<colour>] [scale:<float>] [scaleX:<float>] [scaleY:<float>] [rotation:<int>] [offsetX:<float>] [offsetY:<float>]) 
               | (show <showSiteDataType> [<siteType>] [<int>]) | 
               (show <showSiteDataType> {<int>} <holeType>) | 
               (show Score [<whenScoreType>] [<roleType>] [<int>] [<string>]) | 
               (show Check [<roleType>] [<string>]) | 
               (show Piece <showComponentDataType> [<roleType>] [<string>] [<valueLocationType>] [offsetImage:<boolean>] [valueOutline:<boolean>] [scale:<float>] [offsetX:<float>] [offsetY:<float>]) [metadata.graphics.show.Show] 
~~m <showBooleanType> ::= Cost | CurvedEdges | EdgeDirections | Hints | 
               LocalStateHoles | Pits | PlayerHoles | PossibleMoves | 
               RegionOwner | StraightEdges [metadata.graphics.show.ShowBooleanType] 
~~m <showComponentDataType> ::= State | Value [metadata.graphics.show.ShowComponentDataType] 
~~m <showSiteDataType> ::= AsHoles | SiteIndex [metadata.graphics.show.ShowSiteDataType] 
~~m <showSiteType> ::= Cell | Sites [metadata.graphics.show.ShowSiteType] 
~~m <boardGraphicsType> ::= InnerEdges | InnerVertices | OuterEdges | 
               OuterVertices | Phase0 | Phase1 | Phase2 | Phase3 | Phase4 | 
               Phase5 | Symbols [metadata.graphics.util.BoardGraphicsType] 
~~m <componentStyleType> ::= Card | Die | Domino | ExtendedShogi | ExtendedXiangqi | 
               LargePiece | NativeAmericanDice | Piece | Text | Tile [metadata.graphics.util.ComponentStyleType] 
~~m <containerStyleType> ::= Backgammon | Board | Boardless | Chess | Connect4 | 
               ConnectiveGoal | Deck | Dice | Futoshiki | Go | Graph | Hand | 
               Hashi | HoundsAndJackals | Isometric | Janggi | Kakuro | Lasca | 
               Mancala | PenAndPaper | Puzzle | Shibumi | Shogi | 
               SnakesAndLadders | Spiral | Sudoku | Surakarta | Table | Tafl | 
               UltimateTicTacToe | Xiangqi [metadata.graphics.util.ContainerStyleType] 
~~m <controllerType> ::= BasicController | PyramidalController [metadata.graphics.util.ControllerType] 
~~m <curveType> ::= Bezier | Spline [metadata.graphics.util.CurveType] 
~~m <edgeInfoGUI> ::= (edgeInfoGUI <lineStyle>) [metadata.graphics.util.EdgeInfoGUI] 
~~m <edgeType> ::= All | Inner | Interlayer | Outer [metadata.graphics.util.EdgeType] 
~~m <holeType> ::= Oval | Square [metadata.graphics.util.HoleType] 
~~m <lineStyle> ::= Hidden | Thick | ThickDashed | ThickDotted | Thin | ThinDashed | 
               ThinDotted [metadata.graphics.util.LineStyle] 
~~m <metadataFunctions> ::= (metadataFunctions) [metadata.graphics.util.MetadataFunctions] 
~~m <metadataImageInfo> ::= (metadataImageInfo int <siteType> <string> float) | 
               (metadataImageInfo int <siteType> <string> float) | 
               (metadataImageInfo {<int>} float {<float>} <siteType> <curveType> <lineStyle>) 
               | (metadataImageInfo {<int>} <siteType> float) | 
               (metadataImageInfo int <siteType> <string> float) | 
               (metadataImageInfo int <siteType> <siteType> float) | 
               (metadataImageInfo int <siteType> <boardGraphicsType>) | 
               (metadataImageInfo int <siteType> <string> <string> float float int float float) 
               | 
               (metadataImageInfo int <siteType> <string> float float int float float) 
               | 
               (metadataImageInfo int <siteType> <string> float int float float) 
               | (metadataImageInfo int <siteType> <string> float int) [metadata.graphics.util.MetadataImageInfo] 
~~m <util.pieceColourType> ::= Edge | Fill | Secondary [metadata.graphics.util.PieceColourType] 
~~m <pieceStackType> ::= Backgammon | Count | CountColoured | Default | 
               DefaultAndCount | Fan | FanAlternating | Ground | 
               GroundDynamic | None | Reverse | Ring | TowardsCenter [metadata.graphics.util.PieceStackType] 
~~m <puzzleDrawHintType> ::= Default | NextTo | None | TopLeft [metadata.graphics.util.PuzzleDrawHintType] 
~~m <puzzleHintLocationType> ::= BetweenVertices | Default [metadata.graphics.util.PuzzleHintLocationType] 
~~m <scoreDisplayInfo> ::= (scoreDisplayInfo <whenScoreType> <roleType> <int> <string>) 
               | (scoreDisplayInfo) [metadata.graphics.util.ScoreDisplayInfo] 
~~m <stackPropertyType> ::= Limit | Scale | Type [metadata.graphics.util.StackPropertyType] 
~~m <valueDisplayInfo> ::= (valueDisplayInfo <valueLocationType> boolean boolean float float float) 
               | (valueDisplayInfo) [metadata.graphics.util.ValueDisplayInfo] 
~~m <valueLocationType> ::= CornerLeft | CornerRight | Middle | None | Top [metadata.graphics.util.ValueLocationType] 
~~m <whenScoreType> ::= Always | AtEnd | Never [metadata.graphics.util.WhenScoreType] 
~~m <colour>   ::= (colour <int> <int> <int>) | (colour <int> <int> <int> <int>) | 
               (colour <string>) | (colour <userColourType>) [metadata.graphics.util.colour.Colour] 
~~m <colourRoutines> ::= (colourRoutines) [metadata.graphics.util.colour.ColourRoutines] 
~~m <userColourType> ::= BabyBlue | Black | BlackSabbath | Blue | Bronze | Brown | 
               Burgundy | Cream | Cyan | Dark | DarkBlue | DarkBrown | 
               DarkGreen | DarkGrey | DarkRed | DeepPurple | Gold | Green | 
               Grey | GunMetal | Hidden | HumanDark | HumanLight | IceBlue | 
               KingCrimson | LightBlue | LightGreen | LightGrey | LightOrange | 
               LightRed | LightTan | Magenta | Orange | Pink | PinkFloyd | 
               Purple | Red | Silver | TangerineDream | Turquoise | 
               VeryDarkBrown | VeryDarkGrey | VeryLightBlue | VeryLightGrey | 
               White | Yellow [metadata.graphics.util.colour.UserColourType] 
~~m <info>     ::= (info (<infoItem> | {<infoItem>})) [metadata.info.Info] 
~~m <infoItem> ::=  [metadata.info.InfoItem] 
~~m <aliases>  ::= (aliases {<string>}) [metadata.info.database.Aliases] 
~~m <author>   ::= (author <string>) [metadata.info.database.Author] 
~~m <classification> ::= (classification <string>) [metadata.info.database.Classification] 
~~m <credit>   ::= (credit <string>) [metadata.info.database.Credit] 
~~m <date>     ::= (date <string>) [metadata.info.database.Date] 
~~m <description> ::= (description <string>) [metadata.info.database.Description] 
~~m <database.id> ::= (id <string>) [metadata.info.database.Id] 
~~m <origin>   ::= (origin <string>) [metadata.info.database.Origin] 
~~m <publisher> ::= (publisher <string>) [metadata.info.database.Publisher] 
~~m <database.rules> ::= (rules <string>) [metadata.info.database.Rules] 
~~m <source>   ::= (source <string>) [metadata.info.database.Source] 
~~m <version>  ::= (version <string>) [metadata.info.database.Version] 
~~m <recon>    ::= (recon (<reconItem> | {<reconItem>})) [metadata.recon.Recon] 
~~m <reconItem> ::=  [metadata.recon.ReconItem] 
~~m <concept>  ::= (concept <string> minValue:<float> maxValue:<float>) | 
               (concept <string> (<float> | <boolean>)) [metadata.recon.concept.Concept] 
~~~ <directionUniqueName> ::= CCW | CW | D | DE | DN | DNE | DNW | DS | DSE | DSW | 
               DW | E | ENE | ESE | In | N | NE | NNE | NNW | NW | Out | S | 
               SE | SSE | SSW | SW | U | UE | UN | UNE | UNW | US | USE | USW | 
               UW | W | WNW | WSW [game.util.directions.DirectionUniqueName] 
g~~ <ints>     ::= {<int>} | <array> | <intArray.math.difference> | 
               <intArray.math.if> | <intArray.math.intersection> | 
               <intArray.players.players> | <regions> | <results> | 
               <rotations> | <sizes> | <team> | <intArray.math.union> | 
               <values.values> [int] 

